<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huangyuye.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="HYY">
<meta property="og:url" content="https://huangyuye.github.io/page/2/index.html">
<meta property="og:site_name" content="HYY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuye Huang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://huangyuye.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HYY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HYY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何进行单元测试"><a href="#如何进行单元测试" class="headerlink" title="如何进行单元测试"></a>如何进行单元测试</h2><p><strong>参考链接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn">https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn</a></p>
<p><strong>单元测试”称为“开发阶段的自动化测试“。</strong></p>
<ol>
<li> 由开发同学完成</li>
<li>测试是自动化的</li>
<li>不一定是只验证一个“单元”的正确性</li>
</ol>
<p><strong>单元测试在市面上的介绍存在的问题</strong></p>
<ol>
<li>仅集中在介绍某个工具或者框架怎么用（比如JUnit，mockito，jest等）</li>
<li>一些理论上的对这种测试好处的介绍，通篇是“应该做测试”，“这么做了就容易得到高内聚的代码“</li>
<li>只拿“纯函数”的测试举例子，几乎没有复杂的依赖（无法贴合实际项目：业务逻辑、数据分析的job代码）<ol>
<li>函数的输入就是其所有可见的上下文了。对于一个纯函数，开发者者很容易构造其<strong>上下文</strong>。</li>
</ol>
</li>
<li><strong>很少有关于真正为什么这个事情难以落地的讨论</strong></li>
</ol>
<p><strong>实践起来常见问题</strong></p>
<ol>
<li>没想明白要验证什么</li>
<li>对依赖的处理方式的拿捏是测试里最难的地方。（对不纯的依赖都要尽量mock）<ol>
<li>比如：验证一个下单打折的函数是否能计算出正确的折扣，往往先要从DB获取折扣数据(依赖)，才能做计算。</li>
<li>如果mock掉这个DB查询的依赖，那这个单元测试的假设是：<strong>“读取折扣的SQL本身是肯定没错的，因此不验证它，只验证读到折扣数据后，根据输入金额得到折扣金额的逻辑是正确的“</strong></li>
<li>如果不mock掉DB查询的依赖，即使用真的生产DB做验证，这里测试的目标就从“<strong>验证计算折扣的逻辑</strong>”变成“<strong>验证计算折扣这个功能是否正确</strong>“。<ol>
<li>這裏已经不是“单元”了，而是一个函数 + 一句SQL执行 + DB功能正确的（局部）“集成”测试，是几个组件一起测试才能实现这个验证。这样的测试代价是必须部署一个真的数据库，还要准备数据和<strong>后门</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>到底要不要做”局部集成测试“而非实际的单元测试？</strong></p>
<ul>
<li>你的目标就是要测“一小段代码是不是正确”。你可以很有信心的保证其他依赖的正确性都能保证。那明显，这时就不用花精力做集成了。怎么简单怎么来。这样的测试甚至都不需要启动Spring这类框架，运行速度会很快。</li>
<li>你在开发一个小的lib。这个lib就很纯，没有任何复杂的依赖，那么单元测试就足够了。</li>
<li>如果团队已经安排了专人做这块的集成测试，开发人员就没必要做重复劳动了。如果这块测试的不好，应该优先去和那个测试同学沟通，看看怎么改善。沟通无效，在manager知情和同意下，再自己补。</li>
<li>如果开发自己做集成可以更容易构造全集成，而测试不太容易构造的例子，那么还是自己集成测试一下比较好。性价比高。</li>
<li>如果是要测试一个端到端的接口返回正确，那么唯一的办法就是集成测试——真的启动server，使用真的数据库、Redis、队列……，做端到端的测试。这时也许docker可以帮助你一键启动全套环境。</li>
<li>如果一个测试涉及到依赖的核心功能，也必须得做集成测试。比如要测试一个Exception是不是会让当前事务真的回滚，同时发生的其他事务因为隔离级别不会受到影响，那么你必须引入真的，和生产一模一样的支持事务的数据库才行。</li>
<li>如果是前端测试，基本上也必须得做集成测试。就算可以mock掉所有的后端接口，也得引入浏览器或者App框架才能测试。</li>
</ul>
<p><strong>单元测试目的</strong></p>
<p>验证“自己写的一小段代码是不是符合设计逻辑的“。</p>
<p><strong>单元测试的出发点</strong></p>
<p>开发人员为了保证代码质量应该怎样做</p>
<p><strong>单元测试怎么做？</strong></p>
<ul>
<li>确定测试的目标，到底想验证什么</li>
<li>基于这个目标，找到和维护需要的工具，比如Runner，Mock，覆盖率统计工具等，Embedded数据库等</li>
<li>留足给测试的时间，并通过code review的手段来保证写有效的测试</li>
<li>给一些典型的场景如何做测试写一写文档，积累经验（比如如何测试要模拟时间的案例？）</li>
<li>统计测试同学给开发同学报bug的数据，盯紧代码质量不高的同学，多做沟通</li>
<li>根据出现bug的数量和scope来推动部分关键代码的测试质量的改善</li>
<li>在能达成测试目标的前提下，看看能够整合一些工具，降低维护测试依赖的成本</li>
</ul>
<p><strong>单元测试的好处</strong></p>
<ol>
<li>让你写出更好的代码：只有高内聚、低耦合而且接口设计合理的代码才易于测试；</li>
<li>让你在修改代码时更有信心。</li>
</ol>
<h2 id="单元测试概念"><a href="#单元测试概念" class="headerlink" title="单元测试概念"></a>单元测试概念</h2><h3 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h3><h4 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h4><p>基本框架</p>
<h4 id="testNG"><a href="#testNG" class="headerlink" title="testNG"></a>testNG</h4><p>可以很容易地编写自定义测试。</p>
<p>如果您拥有执行测试所需的测试数据，TestNG可以轻松获取要编写单元测试的测试数据。</p>
<h3 id="模拟框架"><a href="#模拟框架" class="headerlink" title="模拟框架"></a>模拟框架</h3><h4 id="EasyMock"><a href="#EasyMock" class="headerlink" title="EasyMock"></a>EasyMock</h4><p>Mockito的替代品</p>
<ol>
<li>录制：EasyMock.expect(mock.someMethod())</li>
<li>执行：EasyMock.replay(mock)</li>
<li>验证期望：EasyMock.verify(mock)</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h4 id="Mockito-amp-JMockit"><a href="#Mockito-amp-JMockit" class="headerlink" title="Mockito &amp; JMockit"></a>Mockito &amp; JMockit</h4><ol>
<li><h1 id="先进行Stub：when-mock-someMethod-then"><a href="#先进行Stub：when-mock-someMethod-then" class="headerlink" title="先进行Stub：when(mock.someMethod()).then()"></a>先进行Stub：when(mock.someMethod()).then()</h1><h4 id="Mockito-Vs-JMockit"><a href="#Mockito-Vs-JMockit" class="headerlink" title="Mockito Vs JMockit"></a>Mockito Vs JMockit</h4></li>
</ol>
<ol>
<li><p>Stub：when(mock.someMethod()).then()</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>验证行为：verify(mock).someMethod()</p>
</li>
</ol>
<h4 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h4><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>用于模拟复杂场景<br>=======<br>模拟复杂场景</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>想要模拟静态方法、构造函数和私有方法时，Powermock非常有用。</p>
<h3 id="结合项目框架使用的mock框架"><a href="#结合项目框架使用的mock框架" class="headerlink" title="结合项目框架使用的mock框架"></a>结合项目框架使用的mock框架</h3><p>Spring 有 Spring Test、Spring MVC Test</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h4 id="AssertJ-Hamcrest"><a href="#AssertJ-Hamcrest" class="headerlink" title="AssertJ / Hamcrest"></a>AssertJ / Hamcrest</h4><p>Hamcrest提供了AssertJ的替代方案来编写断言。</p>
<h3 id="Spring-Unit"><a href="#Spring-Unit" class="headerlink" title="Spring Unit"></a>Spring Unit</h3><p>Web层- Spring MockMVC</p>
<p>数据层- DataJpaTest</p>
<p>业务层-基于Mockito的测试，最好不要启动Spring Context</p>
<h3 id="断言JSON响应"><a href="#断言JSON响应" class="headerlink" title="断言JSON响应"></a>断言JSON响应</h3><h4 id="JSONAssert-JSONPath"><a href="#JSONAssert-JSONPath" class="headerlink" title="JSONAssert / JSONPath"></a>JSONAssert / JSONPath</h4><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>Cobertura</p>
<h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><p>利用 jenkins 等持续集成工具定时/有代码变更时运行单元测试，保证修改不会破坏已有的代码功能。</p>
<h3 id="Test-Doubles：Fakes、Mocks-以及-Stubs"><a href="#Test-Doubles：Fakes、Mocks-以及-Stubs" class="headerlink" title="Test Doubles：Fakes、Mocks 以及 Stubs"></a>Test Doubles：Fakes、Mocks 以及 Stubs</h3><p><strong>double：</strong>极相似的对应物</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>double存在的意义：用来对系统(或者将粒度放小为模块，单元)进行隔离<br>=======<br>用来对系统(或者将粒度放小为模块，单元)进行隔离</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Dummy</strong></p>
<p>对象被四处传递，但是从不被真正使用。通常他们只是用来填充参数列表。</p>
<p><strong>Fake</strong><br>Fakes are objects that have working implementations, but not same as production one. Usually they take some shortcut and have simplified version of production code.Fake 是那些包含了生产环境下具体实现的简化版本的对象。（用于Test的测试实现类）</p>
<p><strong>Stub</strong></p>
<p>Stub is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don’t want to involve objects that would answer with real data or have undesirable side effects.Stub 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。（提供Query数据的对象）</p>
<p>stub是state-based，关注的是输入和输出。</p>
<p>stub意为踩熄</p>
<p><strong>Mock</strong></p>
<p>Mocks are objects that register calls they receive. In test assertion we can verify on Mocks that all expected actions were performed.Mocks 代指那些仅记录它们的调用信息的对象，在测试断言中我们需要验证 Mocks 被进行了符合期望的调用。(模拟行为的对象)</p>
<p>mock是interaction-based，关注的是交互过程。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26942686">https://zhuanlan.zhihu.com/p/26942686</a></p>
<h3 id="Classical-和-Mockist-TDD-测试风格"><a href="#Classical-和-Mockist-TDD-测试风格" class="headerlink" title="Classical 和 Mockist  TDD 测试风格"></a>Classical 和 Mockist  TDD 测试风格</h3><p>验证状态 vs 验证行为</p>
<h3 id="SUT-amp-UUT-amp-AUT"><a href="#SUT-amp-UUT-amp-AUT" class="headerlink" title="SUT &amp; UUT &amp; AUT"></a>SUT &amp; UUT &amp; AUT</h3><p>SUT（system under test，被测试系统）</p>
<p>UUT（unit under test，被测试单元）</p>
<p>AUT（application under test，被测试应用软件）</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ol>
<li><p>《单元测试之道》</p>
</li>
<li><p>《修改代码的艺术》</p>
</li>
<li><p>Mocks Aren’t Stubs</p>
</li>
</ol>
<h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67801427">https://zhuanlan.zhihu.com/p/67801427</a></p>
<p><a target="_blank" rel="noopener" href="http://tengj.top/2017/12/28/springboot12/">http://tengj.top/2017/12/28/springboot12/</a></p>
<h3 id="场景一、测试控制层"><a href="#场景一、测试控制层" class="headerlink" title="场景一、测试控制层"></a>场景一、测试控制层</h3><h5 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h5><ol>
<li>生成<code>TargetController</code>的单元测试类<code>TargetControllerTest</code>（一般包括整个controller的所有方法的testCase）</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>2. 生成目标方法<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code><br>=======<br>2. 生成<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ol start="3">
<li><p>注解声明单元测试类</p>
<ol>
<li>方式一</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明测试是在spring环境下运行的，这样就可以启用Spring的相关支持。</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 注解负责扫描配置来构建测试用的Spring上下文环境。它默认搜索@SpringBootConfiguration类，除非我们通过classes属性指定配置类，或者通过自定义内嵌的@Configuration类来指定配置。</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>方式二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 实例化一个MockMvc的bean + 可指定只实例化某一到多个Controller（但是同样也会遵从配置类的注解去做更多的工作）</span></span><br><span class="line"><span class="meta">@WebMvcTest(AppCustomerController.class)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>准备MockMvc对象</p>
<ol>
<li><p>方式一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mvc = MockMvcBuilders.webAppContextSetup(wac).build(); <span class="comment">//初始化MockMvc对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<ol>
<li>可直接使用@WebMvcTest实例化的mockMvcBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>只实例化目标类，避免其他无关类的实例化开销（自定义内嵌的@Configuration类来指定配置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;xxx&quot;,</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false,</span></span><br><span class="line"><span class="meta">        includeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.REGEX,</span></span><br><span class="line"><span class="meta">                pattern = &#123;&quot;xxx.TargetController&quot;&#125;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解决TargetController被测对象的其他依赖问题</p>
</li>
<li><p>将测试目标的所有依赖bean声明为<strong>模拟的bean</strong>，这些模拟的bean将<strong>被注入测试目标bean</strong>。</p>
</li>
<li><p>构建MockHttpSession，解决请求过程中的用户验证问题</p>
</li>
<li><p>绝大部分的方法受限于公司封装的底层框架，必须实例化对应的bean，且为带参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部嵌套javaConfig类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringContext <span class="title">springContext</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringContext(beanFactory); <span class="comment">// 由SqlContext实例化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">BaseService baseService;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">CustomerSessionService customerSessionService;</span><br></pre></td></tr></table></figure></li>
<li><p>Mockito.spy()方法模拟出来的对象，调用该模拟对象的方法时，若该方法没有被”打桩“（预设），则会实际调用该方法真实逻辑。相比Mockito.mock()出来的模拟对象，若调用mock对象的方法没有被打桩，则返回默认值。</p>
</li>
<li><p>doReturn().when()与when().thenReturn()</p>
<ol>
<li>spy模拟对象<ol>
<li>when(…) thenReturn(…)会调用真实的方法</li>
<li> doReturn(…) when(…) 不会调用真实方法</li>
</ol>
</li>
</ol>
</li>
<li><p>2.1.0版本以前的<strong>Mockito</strong>是<strong>不能mock final类和final方法的</strong>，之后的也要通过配置一些相关文件才行(<a target="_blank" rel="noopener" href="https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mock-the-unmockable-opt-in-mocking-of-final-classesmethods">Mock the unmockable: opt-in mocking of final classes/methods</a>)。因此，它的补充框架PowerMock也应运而生。</p>
<ol>
<li>创建配置文件 src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker</li>
<li>文件内容：mock-maker-inline</li>
</ol>
</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>12. powerMock（未实践）<br>=======<br>12. powerMock</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span> <span class="comment">// 替代SpringRunner.class</span></span><br><span class="line"><span class="comment">// // powermock使用了自定义的PowerMockRunner，与spring集成时，可以代理至SpringJUnit4ClassRunner。</span></span><br><span class="line"><span class="meta">@PowerMockRunnerDelegate(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// @PowerMockRunnerDelegate(Parameterized.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;StaticService.class&#125;)</span> <span class="comment">// 包含静态类的方法</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="13">
<li>powerMock + org.mockito.plugins.MockMaker 冲突问题<ol>
<li>org.mockito.internal.configuration.plugins.PluginLoader：java.lang.ClassNotFoundException: mock-maker-inline</li>
<li>删掉扩展文件后：java.lang.NoSuchMethodError: org.mockito.MockingDetails.getMockCreationSettings()</li>
</ol>
</li>
<li>@Mock 和 @InjectMocks 搭配使用（而非@MockBean）</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>    1. 而 @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）<br>=======<br>    1. @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MockBean(name = &quot;guide.SgGuide&quot;)</span></span><br><span class="line">SgGuide sgGuide;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="16">
<li><p>ArgumentMatchers.any() vs Mockito.any() 是同一个东西，<strong>Mockito 继承了 ArgumentMatchers</strong></p>
</li>
<li><p>doxxx().when() 不能用于 @MockBean 场景下??? （given().willReturn()）</p>
</li>
<li><p><strong>mockMvc添加过滤器</strong></p>
<ol>
<li>mMockMvc = MockMvcBuilders.webAppContextSetup(context).addFilter(new UserFilter()).build();</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200914-Excel%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200914-Excel%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>HSSF (Horrible SpreadSheet Format（电子表格格式）的缩写)<ol>
<li>对应.xls 文件，兼容 Office97-2003 版本 ）（一个sheet最大行数65536，最大列数256）</li>
</ol>
</li>
<li>XSSF<ol>
<li>容 Office2007及以后版本 （一个sheet最大行数1048576，最大列数16384）</li>
</ol>
</li>
<li><strong>SXSSF</strong> （低内存占用的操作方式）<ol>
<li>SXSSFWorkbook w3= new SXSSFWorkbook(100);//内存中保留100条数据，其余写入硬盘临时文件</li>
</ol>
</li>
</ol>
<h2 id="文档结构类"><a href="#文档结构类" class="headerlink" title="文档结构类"></a>文档结构类</h2><p>HSSFWorkbook excel文档对象<br>HSSFSheet excel的sheet<br>HSSFRow excel的行<br>HSSFCell excel的单元格<br>HSSFFont excel字体<br>HSSFName 名称<br>HSSFDataFormat 日期格式<br>HSSFHeader sheet头<br>HSSFFooter sheet尾<br>HSSFCellStyle cell样式<br>HSSFDateUtil 日期<br>HSSFPrintSetup 打印<br>HSSFErrorConstants 错误信息表</p>
<h3 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h3><h3 id="easyExcel"><a href="#easyExcel" class="headerlink" title="easyExcel"></a>easyExcel</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java">https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java</a></p>
<h3 id="easyPoi"><a href="#easyPoi" class="headerlink" title="easyPoi"></a>easyPoi</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/lemur/easypoi">https://gitee.com/lemur/easypoi</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200925-Git%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200925-Git%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="git常用场景使用技巧"><a href="#git常用场景使用技巧" class="headerlink" title="git常用场景使用技巧"></a><strong>git常用场景使用技巧</strong></h3><ol>
<li><p>功能开发到一半，突然要修复线上问题 （保存现场）</p>
<ol>
<li>在开发分支上：<code>git stash</code> = <code>git stash save</code> 保存未提交的内容（<strong>前提是修改的文件已被版本库追踪过</strong>）<ol>
<li>想要添加保存信息则执行：<code>git stash save -a “message”</code> （git stash save 命令将来会被git stash push 代替）</li>
<li>默认情况下，<code>git stash</code> 只会贮藏已修改和暂存的 <strong>已跟踪</strong> 文件。如果指定 –include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。</li>
</ol>
</li>
<li>切换到其他分支修复bug</li>
<li>修复完后回到原开发分支，并执行 <code>git stash pop</code> (<code>git stash pop</code> = <code>git stash apply  stash@&#123;0&#125;</code> + <code>git stash drop  stash@&#123;0&#125;</code>)</li>
</ol>
</li>
<li><p>不小心把代码提交到错的分支上 （<strong>假设错误分支为test，目标分支为 dev</strong> ）</p>
<ol>
<li><strong>简易操作</strong>：切换到在目标分支dev下执行-&gt; <code>git cherry-pick commitId1 commitId2</code> …</li>
<li><strong>git rebase</strong>：<code>git rebase --onto dev &lt;开始的commitId&gt; &lt;结束的commitId&gt; </code><ol start="2">
<li>执行上述操作后，实际上git 会将dev作为基底分支，将 &lt;开始的commitId&gt; &lt;结束的commitId&gt;  做的相应改变重做一遍，重做的commitId可能跟旧的commitId不一样（若是能ff，则commitId一样），重做后，HEAD指针指向最新的commitId上（游离状态，没有指向任何分支上）</li>
<li>切换到目标分支 <code> git checkout dev</code></li>
<li>将dev分支指向重做的最新的提交点上 <code>git reset --hard  commitId</code> （也属于变基操作，会产生线性提交历史）</li>
</ol>
</li>
</ol>
</li>
<li><p>需要将其他分支的文件复用过来：</p>
<ol>
<li><code>git checkout source_path(其他分支) filename1 filename2 ... (其他分支的文件) </code></li>
</ol>
</li>
<li><p>需要删除中途某次提交：git revert </p>
<ol>
<li><code>git revert commitID</code> 使用一次新的commit来回滚之前的commit</li>
<li>revert 是逆向回放</li>
</ol>
</li>
<li><p><strong>本地仓库</strong>需要回退到某个版本（亦可用于版本前进）：git reset</p>
<ol>
<li> <code>git reset --hard commitId</code> ： 将 commitId 和 commitId 之后的所有提交记录均删除；但是如果 merge 其他老的分支到该分支，commitId后面被回滚的commit应该还会被引入<strong>（一般在提交点push到公共分支之前操作）</strong></li>
<li><code>git reset --soft commitId</code>：此次提交之后的修改会被退回到暂存区。(回退版本<strong>commitId后的修改还保留在本地工作空间</strong>)</li>
<li><code>git reset commitId</code> 默认使用选项 –mixed，此次提交之后的修改会被退回到工作区</li>
<li><code>git reset</code> 用于将当前分支指向任意提交点，包括其他分支的提交点，即可在任意提交点来回穿梭</li>
</ol>
</li>
<li><p>代码版本回退错误，想要重新回到最新提交点，但是提交历史已丢失了（通过git log 查看不到提交记录）</p>
<ol>
<li>使用 <code>git reflog</code> 查看历史操作记录，找到对应要恢复的提交点，执行 git reset 相关方法</li>
</ol>
</li>
<li><p>已经推送到远程公共分支的代码版本正确的回退姿势（<strong>暂时未理解原理</strong>）</p>
<ol>
<li><code>git reset --hard commitId1</code>（要回退的版本）：该操作把 working, index, HEAD 都强行置为 commitId1</li>
<li><code>git reset --soft commitId2</code>（最新提交点）</li>
</ol>
</li>
<li><p><strong>本地仓库</strong>，存在多余的提交，想要压缩成一次提交</p>
<ol>
<li>将上一次提交和这次提交作为一次提交 <code>git commit --amend</code> </li>
<li>多次提交压缩：<code>git rebase -i HEAD~n</code>  (n表示要合并的最近提交的次数)</li>
<li><strong>（一般在提交点push到公共分支之前操作）</strong></li>
</ol>
</li>
<li><p><code>git merge</code> 合并时建议使用 <code>--no--ff</code> 选项保留完整的提交历史（<strong>否则该命令默认策略：“优先–ff，若不能ff则–no-ff”</strong>）</p>
</li>
<li><p>比较各个区域的修改差异</p>
<ol>
<li>git diff – cached：比较缓存区与本地库最近一次commit内容</li>
</ol>
<ul>
<li>git diff：比较缓存区与工作区 </li>
<li>git diff HEAD | git diff commitId 比较工作区与本地最近一次commit内容 （工作区会包含已暂存和未暂存的文件内容）</li>
</ul>
</li>
<li><p>想要查看某次提交做了哪些改动</p>
<ol>
<li><code>git show commitId</code> (相较以下命令常用)</li>
<li><code>git show HEAD@&#123;5&#125;</code>  查看仓库中 HEAD 在五次前的所指向的提交</li>
</ol>
</li>
<li><p>版本迭代发布之际，需要合并其他分支的代码时，查看哪些分支已合并或未合并到当前分支</p>
<ol>
<li>查看哪些分支已经合并到当前分支：git branch –merged </li>
<li>查看哪些分支没有合并到当前分支 git branch –no-merged </li>
</ol>
</li>
<li><p>查看某分支还有哪些提交尚未合并到主分支？</p>
<ol>
<li><strong>双点</strong>：<ol>
<li>在 feature 分支中而不在 master 分支中的提交：<code>git log master..feature</code> </li>
<li>在你当前分支中而不在远程 <code>origin</code> 中的提交：<code>git log origin/master..HEAD</code></li>
</ol>
</li>
<li><strong>三点</strong>：<ol>
<li>想看 master 或者 feature 中包含的但不是两者共有的提交：<code>git log master...feature</code> </li>
<li>增加 –left-right 选项可以显示每个提交到底处于哪一侧的分支</li>
</ol>
</li>
<li><strong>多点</strong>：<ol>
<li>^ 字符或者 –not 来指明你不希望提交被包含其中的分支（以下命令等价）<ol>
<li>git log refA..refB</li>
<li>git log ^refA refB</li>
<li>git log refB –not refA</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>概念</strong></p>
<ol>
<li>本地跟踪分支、远程跟踪分支、远程分支 （pull = fetch + merge）</li>
</ol>
<hr>
<h3 id="其他知识点补充"><a href="#其他知识点补充" class="headerlink" title="其他知识点补充"></a><strong>其他知识点补充</strong></h3><ol>
<li><p>变基 &amp; git merge 区别、commitId 的时间线是否有序</p>
<ol>
<li>变基：以另一个分支为基底分支，保留基底分支在共同祖先之后的提交，再将两个分支<strong>最近的</strong>一个<strong>共同祖先</strong>之后的属于”当前变基操作分支”的提交点，<strong>重做</strong>到基底分支上(<strong>commitId会发生变化</strong>)，均作为当前变基操作分支的内容。</li>
<li>变基后将内容merge 到另一个分支时会丢失该分支提交历史</li>
</ol>
</li>
<li><p>git rebase –onto master &lt;开始的commitId&gt; &lt;结束的commitId&gt; （游离指针 HEAD)</p>
<ol>
<li>git rebase master feature ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍 （省去切换分支到feature上的操作）</li>
<li>git rebase –onto master feature feature-child1 ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍，但暂时并不想合并 feature-child1 中的修改 （feature-child1一般是feature的子分支）</li>
</ol>
</li>
<li><p>Git 合并两个分支时，<strong>如果顺着一个分支走下去可以到达另一个分支的话</strong>，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）（<strong>如果不能到达另一个分支，则会执行 –no-ff</strong> ）</p>
<ol>
<li>非ff：Merge made by the ‘recursive’ strategy. （通过“递归”策略进行合并）</li>
<li>merge 时可以指定提交信息 -m</li>
</ol>
</li>
<li><p>git reset –hard commitId 用于将当前分支指向任意提交点，包括其他分支的提交点</p>
</li>
<li><p>git checkout 可以将 HEAD 引用 指向到任意提交点（游离状态-HEAD指针没有指向对象的分支）</p>
</li>
<li><p>Git push 时如何避免出现 “Merge branch ‘master’ of …”</p>
<ol>
<li>每次从远程分支 pull 新的变动，其实都会执行一次 git merge &lt;远程仓库&gt;/&lt;远程分支&gt;</li>
<li>git pull = git fetch + git merge ：若你本地的远程跟踪分支落后于远程分支，且在这段时间你还在本地分支进行开发并且做了提交，之后你使用git fetch 拉取远程最新的改动，这个时候你的远程跟踪分支与本地开发分支的提交历史就会产生分叉，执行 git pull 或 git merge origin/master的话就会产生合并记录（**–no-ff**）</li>
<li>可以使用 git pull –rebase （git fetch + git rebase） 变基方式去除自动生成的 log 信息<ol>
<li>从 remote 分支拉取更新到本地时，使用 rebase。</li>
<li>当完成 bug 修复或新功能时，使用 merge 将子分支合并到主分支。</li>
<li>没有人应该 rebase 一根共享的分支。</li>
</ol>
</li>
</ol>
</li>
<li><p>HEAD：</p>
<ol>
<li>HEAD就是当前活跃分支的游标。</li>
<li>HEAD并非只能指向分支的最顶端，实际上它可以指向任何一个提交节点，它就是 Git内部用来追踪当前位置的东东。</li>
</ol>
</li>
<li><p><code>git checkout -b mybranch origin/mybranch</code> (可以指定本地分支名)</p>
<p>= <code>git checkout --track origin/mybranch</code></p>
<p>= <code>git checkout origin/mybranch</code> </p>
</li>
<li><p>查看某次提交的改动</p>
<ol>
<li><code>git show commitId</code></li>
</ol>
</li>
<li><p>查看二进制对象文件：</p>
<ol>
<li>git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li>
</ol>
</li>
<li><p>通过具体指定一个提交来拉取该文件的对应版本：</p>
<ol>
<li><code>git reset eb43bf file.txt</code></li>
</ol>
</li>
<li><p>查看某个文件中内容的更改记录：</p>
<ol>
<li>git blame -L 69,82 Makefile （每一行分别来自哪个提交和提交者，-L可以指定行数）</li>
</ol>
</li>
<li><p>二分查找 git bisect</p>
</li>
<li><p> <code>--patch</code> 选项</p>
</li>
<li><p>打包本地仓库：git bundle create repo.bundle HEAD master</p>
</li>
<li><p>git 撤销commit中单个文件的修改：（未验证）</p>
<ul>
<li>git log <fileName>（首先查询这个文件的log）</li>
<li>git reset <commit-id> <fileName> （其次查找到这个文件的上次commit id xxx，并对其进行reset操作）</li>
<li> git checkout <fileName> 撤销对此文件的修改</li>
<li>git commit –amend + git push origin <remoteBranch> （最后amend一下，再push上去）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Git开发工作流"><a href="#Git开发工作流" class="headerlink" title="Git开发工作流"></a>Git开发工作流</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903635533594632#heading-0">https://juejin.im/post/6844903635533594632#heading-0</a></p>
<ol>
<li>可以 <strong>在本地</strong> 随便重写历史记录（推送到远程公共分支之前）。 但是在对提交内容感到满意并准备与他人分享之前，应当避免推送你的工作。</li>
</ol>
<h3 id="GIt工具"><a href="#GIt工具" class="headerlink" title="GIt工具"></a>GIt工具</h3><ol>
<li><p>如何选择修订版本（即提交点）</p>
<ol>
<li><strong>简短的 SHA-1</strong>：可使用简短的 SHA-1来指定唯一的修订版本</li>
<li><strong>祖先引用</strong>：使用 ~ 或者 ^ 指定上一个父提交，~n 或者 ^ n指向前N个父提交，用法如下<ol>
<li>HEAD~3：当前HEAD指针指向的提交点的第三父提交</li>
<li>commitId~~：该提交点的第二父提交点</li>
</ol>
</li>
</ol>
</li>
<li><p>交互式暂存 <code>git add -i</code> 更友好的操作界面</p>
</li>
<li><p>贮藏与清理</p>
<ol>
<li>从贮藏创建一个分支：git stash branch testchanges</li>
<li>清理工作目录：<ol>
<li>git clean；默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 </li>
<li>git clean -i：交互式清理</li>
<li> git clean -f -d：移除工作目录中所有未追踪的文件以及空的子目录。</li>
<li>git clean -n（或者–dry-run）：“做一次演习然后告诉你 将要 移除什么”；要查看空目录需加上-d选项</li>
</ol>
</li>
</ol>
</li>
<li><p>重写历史：</p>
<ol>
<li>修改提交记录：git rebase -i （可以压缩提交或者拆分提交）<ol>
<li>squash 压缩提交到前一次提交</li>
<li>edit 进入对应提交点上，可以在做相应修改并提交到历史线上。</li>
</ol>
</li>
<li>修改大批量的提交：(<strong>未测试通过</strong>)<ol>
<li>删除某次提交中引入的某个文件（如密码文件），且在所有的提交点中都恢复不了该文件： <code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD</code></li>
</ol>
</li>
</ol>
</li>
<li><p>关于重置（ <code>reset</code> 和 <code>checkout</code>）</p>
<ol>
<li>首先要了解git中的三棵树：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">上一次提交的快照，下一次提交的父结点</span><br><span class="line">Index</span><br><span class="line">预期的下一次提交的快照</span><br><span class="line">Working Directory</span><br><span class="line">沙盒</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>HEAD</strong> 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。<ol>
<li>递归查看树结构：git ls-tree -r HEAD</li>
<li>查看二进制对象文件：git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li>
</ol>
</li>
<li><strong>索引</strong>是你的 预期的下一次提交。 <ol>
<li>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。（<strong>git的每次提交都是全量文件的快照</strong>） 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。</li>
<li>git ls-files -s</li>
</ol>
</li>
<li>可以把<strong>工作目录</strong>当做 沙盒。<ol>
<li>HEAD、索引树 将工作区的文件的内容存储在 .git 文件夹中。而工作目录会将它们解包为实际的文件以便编辑。</li>
<li>在将修改提交到暂存区并记录到历史之前，可以随意更改工作目录的文件内容。</li>
</ol>
</li>
<li><strong>切换分支或克隆的过程：</strong>当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照， 然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</li>
<li>git reset 到底做了什么？<ol>
<li>先了解文件提交到版本库的链路：工作树 -&gt; 索引树 -&gt; 对象区(HEAD所指向)；回退的链路则反之</li>
<li>移动 HEAD的指向：与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支所指向的提交点。（<strong>可以理解为，HEAD是一个引用/指针，指针指向分支对象，相当于HEAD的实际对象是分支对象，reset 是修改这个HEAD对象的commitId属性（调用分支对象的setter方法）；而checkout相当于修改HEAD的引用，引用另一个对象</strong>）</li>
<li>git reset –soft：（移动 HEAD 分支的指向）撤销了上一次 git commit 命令，<strong>然后停止</strong>；HEAD树回退到上一次提交的版本，工作区、索引树不变。</li>
<li>git reset –mixed：（使索引看起来像 HEAD）撤销 commit、取消暂存 add ，<strong>然后停止</strong></li>
<li>git reset –hard：（使工作目录看起来像索引）撤销 commit、取消暂存 add ，还原工作区内容</li>
</ol>
</li>
<li>通过具体指定一个提交来拉取该文件的对应版本：<ol>
<li><code>git reset eb43bf file.txt</code> (更新索引)</li>
<li><code>git checkout eb43bf file.txt</code>  (更新索引树和工作空间)</li>
</ol>
</li>
</ol>
</li>
<li><p>git commit操作逻辑：</p>
<ol>
<li>取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象</li>
<li>最后更新 master 来指向本次提交 （HEAD会一直指向当前分支，而该分支会指向最后一次提交的快照（即对象区的内容））</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201027-%E5%AE%B9%E5%99%A8&%E5%90%8C%E6%AD%A5&%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201027-%E5%AE%B9%E5%99%A8&%E5%90%8C%E6%AD%A5&%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="20201027-并发-amp-同步容器"><a href="#20201027-并发-amp-同步容器" class="headerlink" title="20201027-并发&amp;同步容器"></a>20201027-并发&amp;同步容器</h1><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>nanos 毫微秒</p>
<p>nil 零/无</p>
<p>Deque  双端队列容器</p>
<h2 id="常用容器相关超类"><a href="#常用容器相关超类" class="headerlink" title="常用容器相关超类"></a>常用容器相关超类</h2><ul>
<li>Iterator(迭代器)<ul>
<li>不同类型的集合的操作方法基本上都是使用抽象迭代器来遍历集合元素进行相关操作，需要具体的迭代器实现类来实现迭代细节。（Iterator中没有涉及具体的数据结构和算法）</li>
</ul>
</li>
<li>Collection(单个元素对象的序列，下面三个子接口设计目的：最大程度抽象出元素的操作)<ul>
<li>List：一个有序的Collection（或者叫做序列）</li>
<li>Set</li>
<li>Queue</li>
</ul>
</li>
<li>Map(“键值对”映射表)</li>
</ul>
<h3 id="Map（散列表）"><a href="#Map（散列表）" class="headerlink" title="Map（散列表）"></a>Map（散列表）</h3><ul>
<li>遍历函数<ul>
<li><strong>keySet：Set<K></strong> （hashSet又由HashMap实现）</li>
<li>values：Set<V></li>
<li>entrySet：Set&lt;Map.Entry&lt;K, V&gt;&gt;</li>
</ul>
</li>
<li>类型<ul>
<li>HashMap<ul>
<li>tab hash数组</li>
<li>hash冲突链表保存元素</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>继承HashMap</li>
</ul>
</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>函数</p>
<ul>
<li>add()：<ul>
<li>modCount ++ </li>
<li>扩容检查（涉及数组复制）</li>
</ul>
</li>
<li>remove()：<ul>
<li>modCount++;</li>
<li>把需要删除index后面的都往前移一位然后再把最后一个去掉。<ul>
<li>numMoved = size - index - 1</li>
<li>System.arraycopy(elementData, index+1, elementData, index, numMoved)</li>
<li>elementData[–size] = null; </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>有序，可以重复</p>
<p>List包含特殊的遍历器：ListIterator，支持双向访问、允许从一个指定位置开始遍历</p>
<p><strong>ArrayList 继承了AbstractList且实现了List，但是AbstractList已经实现了List</strong></p>
<p><strong>AbstractList 内部类：</strong>Itr implements ListIterator；ListItr extends  Itr</p>
<p>equals 和 contains方法都使用了迭代器遍历来实现</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>HashSet<ul>
<li><strong>使用HashMap实现</strong>，value是默认对象</li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>继承hashSet</li>
<li>使用LinkedHashMap实现</li>
<li>LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。这个顺序不是元素的大小顺序，而是可以保证2次遍历的顺序是一样的。</li>
</ul>
</li>
<li>TreeSet<ul>
<li>TreeSet内的元素必须实现Comparable接口</li>
</ul>
</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>AbstractCollection<E>;、AbstractMap&lt;K,V&gt;、AbstractList<E>和AbstractSet<E></p>
<p>各个集合的关键区别就在每个集合所使用的数据结构和算法上，所以在<strong>抽象类</strong>层面都没有涉及具体的数据结构和算法，只对操作这些数据结构的方法做了基本实现。</p>
<h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList<E></h2><p><strong>AbstractList 内部类：</strong>Itr implements ListIterator；ListItr extends  Itr</p>
<h2 id="AbstractMap-lt-K-V-gt"><a href="#AbstractMap-lt-K-V-gt" class="headerlink" title="AbstractMap&lt;K,V&gt;"></a>AbstractMap&lt;K,V&gt;</h2><p>implements Map&lt;K,V&gt;，实现了除entrySet()方法外的基本所有方法；</p>
<p>返回键集的Set<K> keySet()和返回值集的Collection<V> values()：返回来一个实现Set<K>或Collection<V>的类对象，类对象的所有操作都是在原映射表的基础上进行的，这种操作叫视图。（重写AbstractSet的一个匿名内部类返回）</p>
<h2 id="ArrayList-amp-LinkList"><a href="#ArrayList-amp-LinkList" class="headerlink" title="ArrayList &amp; LinkList"></a>ArrayList &amp; LinkList</h2><p>ArrayList<E>通过数组实现：数组中元素间的内存地址是连续的、只能存储一种类数据类型的元素。数组长度固定</p>
<p>LinkList<E>使用了双向链表；LinkList继承了Deque<E>接口，实现<strong>双端队列</strong>头尾进出的特点。</p>
<p>链表的特点：长度不固定，可以随时增加和减少、链表中的元素在内存地址上可以是连续的，也可以是不连续的</p>
<p>ArrayList 继承了AbstractList且实现了List</p>
<p>ArrayList  在添加元素之前会进行容量检查；扩容目标容量大小为原容量的1.5倍；扩容涉及数组的复制</p>
<p>在遍历元素上ArrayList<E>存在更有效的方式，他实现了RandomAccess接口，代表ArrayList<E>支持快速访问。 RandomAccess本身是一个空接口，这种接口一般用来代表一类特征，RandomAccess代表实现类具有快速访问的特征。</p>
<p>LinkedList 添加对象时需要创建Node对象而开辟内存空间；</p>
<p>LinkedList元素在将元素插入到链表中间位置的场景耗时很久；插入到头部最快。</p>
<p>LinkedList添加第一个元素的时候，first=last=newNode;</p>
<p>LinkedList add(i, ele)时，将下标为i的元素的prev元素节点（如果为null，则ele为first节点），作为ele的prev元素节点，当前元素ele的next节点指向下标为i的元素；再将下标为i的元素的节点的prev元素节点指向当前元素ele；（linkBefore）</p>
<p>LinkedList根据下标i索引元素的方式：对比下标跟链表长度的一半，判断是在前半部分还是后半部分，若是前半部分，则从first节点向后遍历；否则从last节点前序遍历</p>
<p><strong>问题：</strong></p>
<p>1、为什么链表将元素插入到链表中间位置耗时最近？</p>
<p>2、为很么链表将元素插入到链表头部的时间与插入到尾部的时间不一致？</p>
<h2 id="红黑树、TreeMap与TreeSet"><a href="#红黑树、TreeMap与TreeSet" class="headerlink" title="红黑树、TreeMap与TreeSet"></a>红黑树、TreeMap与TreeSet</h2><p>Map&amp;Set: 不能添加重复元素的集，不能通过索引来访问的集; (由数组实现的散列表+链表/红黑树)</p>
<p>Set由Map实现,但是Set继承自Collection集合,而map为键值映射</p>
<p>TreeMap: 每次put元素时会遍历比较key值,优先使用比较器进行比较,后使用默认的compareTo方法比较;<strong>TreeMap.Entry</strong> implements Map.Entry, 即红黑树</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteList&lt;&gt;(); <span class="comment">// list引用地址 #list001, list.array引用地址 # array001</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.sort(Integer.compareTo()); <span class="comment">// list引用地址不变，list.array引用地址 #array002</span></span><br><span class="line">list.add(<span class="number">2</span>); <span class="comment">// list引用地址不变，list.array引用地址 #array003</span></span><br></pre></td></tr></table></figure>

<ol>
<li>ArrayList 在add元素时不会修改数组的指向</li>
<li>ArrayList 和 CopyOnWriteList 在sort时都会修改数组的指向</li>
<li>ArrayList 在使用iterator遍历时，首先会记录当前list修改操作的次数n，后续遍历执行next()时会检查n是否修改，如果修改，则抛出ConcurrentModificationException（遍历外部类的最新数组）；CopyOnWriteList 则能正常遍历，因为遍历的是旧的引用数组。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201031-springCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201031-springCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="spring-技术体系演变"><a href="#spring-技术体系演变" class="headerlink" title="spring 技术体系演变"></a>spring 技术体系演变</h2><ol>
<li>spring</li>
<li>springboot</li>
<li>spring cloud netflix</li>
<li>spring cloud alibaba （微服务开发的一站式解决方案）</li>
</ol>
<h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><ul>
<li><p>配置管理</p>
</li>
<li><p>服务管理</p>
</li>
</ul>
<p>服务注册中心 + 配置中心（涉及CAP理论）</p>
<h2 id="feign"><a href="#feign" class="headerlink" title="feign"></a>feign</h2><p>feign = ribbon + hystricx</p>
<p>feign 对微服务的调用实际上也是类似使用 restTemplate 进行http 调用，只是进行了封装。</p>
<h2 id="gateway-amp-feign"><a href="#gateway-amp-feign" class="headerlink" title="gateway &amp; feign"></a>gateway &amp; feign</h2><p>gateway(API路由管理方式)： 提供统一的路由方式，基于filter链的方式提供网关基本功能（如安全、监控/指标，和限流）</p>
<h2 id="sentinal"><a href="#sentinal" class="headerlink" title="sentinal"></a>sentinal</h2><p>以流量为切入点，从流量控制、熔断降级、系统负载保护等多维度保护服务的稳定性</p>
<p>sentinal的限流配置可以与nacos配合使用（除此之外，sentinal还有很多配置的持久化方式）</p>
<h2 id="fescar"><a href="#fescar" class="headerlink" title="fescar"></a>fescar</h2><p>即seata，分布式事务解决方案</p>
<h2 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h2><p>服务链路追踪</p>
<p>常见的<strong>APM</strong>系统对比：zipkin vs pinpoint vs skywalking （Application Performance Management应用性能管理）</p>
<h2 id="gateway、sentinal、feign的关系和配合？？"><a href="#gateway、sentinal、feign的关系和配合？？" class="headerlink" title="gateway、sentinal、feign的关系和配合？？"></a>gateway、sentinal、feign的关系和配合？？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201110-smartDoc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201110-smartDoc/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="smart-doc-实践"><a href="#smart-doc-实践" class="headerlink" title="smart-doc 实践"></a>smart-doc 实践</h2><h3 id="maven-插件原理"><a href="#maven-插件原理" class="headerlink" title="maven 插件原理"></a>maven 插件原理</h3><p><strong>场景1：</strong></p>
<ul>
<li>pom文件未指定包含插件 xxxPlugin </li>
<li>执行maven命令的时候时候会提示 xxxPlugin.jar 不存在</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201124-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201124-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>单元测试</strong></p>
<p>单元测试是指对软件中的<strong>最小可测单元</strong>进行检查和验证；</p>
<p>根据测试金字塔原理，越往上层的测试，所需测试投入比例越大，效果也越差。单测成本小，且更容易发现问题。（效果：单元测试 &gt; 集成测试 &gt; UI测试）</p>
<p><strong>分层测试</strong></p>
<p>Service =&gt; Biz层 =&gt; （外部服务访问层、DAO层、Redis访问层）</p>
<p>每一层均使用mock 框架屏蔽下层的具体实现。</p>
<p><strong>单元测试过程</strong></p>
<p>数据准备 =&gt; 构造参数（+打桩）=&gt; 执行测试 =&gt; 结果验证 =&gt; 清理（必要）</p>
<ol>
<li>数据准备：测试用例需要依赖一些数据，数据来源一般是数据库，而又不能依赖DAO层的代码，需要使用原生jdbc去插入数据，<strong>测试代码编写效率低</strong></li>
<li>构造参数：入参赋值（<strong>代码行数多</strong>）</li>
<li>执行测试：直接调用被测方法</li>
<li>结果验证：验证方法的返回值、数据库数据是否正确、某外部方法是否被调用过n次等</li>
<li>必要的清理：对打桩进行清理、对数据库脏数据进行清理</li>
</ol>
<p><strong>痛点</strong></p>
<ol>
<li>重构代码需要改写大量单元测试用例<ol>
<li>大量的Service 层单元测试,biz层单元测试都要重写；有时候Service调用biz层接口时，参数传错了，而由于开发人员编写单元测试时不规范，参数匹配使用了 anyxxx()，导致参数传错的bug未被发现。</li>
</ol>
</li>
<li>测试库数据随意修改导致的单元测试不稳定<ol>
<li>DAO层单元测试直连测试库，由于测试库的数据可以被任意修改，从而导致测试依赖的数据被更改，单元测试不通过，另外开发在编写单元测试时，没有清理意识，导致测试库大量垃圾数据。</li>
</ol>
</li>
<li>单元测试结果校验缺失<ol>
<li>例如一个SaveItem()接口，执行完成后除了要验证执行成功以外，还应该验证落库数据的正确性，而编写这部分测试代码需要大量的使用原生jdbc 接口查询sql，并逐字段验证正确性，代码编写效率低下。</li>
</ol>
</li>
</ol>
<p><strong>参考文章</strong>-《有赞单元测试实践》</p>
<p><a target="_blank" rel="noopener" href="https://tech.youzan.com/youzan-test-practice/">https://tech.youzan.com/youzan-test-practice/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201209-jenkins%20vs%20teamCity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201209-jenkins%20vs%20teamCity/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20210309-cas%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20210309-cas%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jasig.cas.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cas-client.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/dos%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/dos%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 16:17:12" itemprop="dateCreated datePublished" datetime="2021-05-09T16:17:12+00:00">2021-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">理解计算机</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuye Huang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huangyuye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huangyuye" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:747776824@qq.com" title="E-Mail → mailto:747776824@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/huangyuye/qzf3af" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;huangyuye&#x2F;qzf3af" rel="noopener" target="_blank">语雀</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuye Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
