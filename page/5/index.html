<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="referrer" content="no-referrer" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huangyuye.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="HYY">
<meta property="og:url" content="https://huangyuye.github.io/page/5/index.html">
<meta property="og:site_name" content="HYY">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuye Huang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://huangyuye.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HYY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HYY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/09/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200925-Git%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200925-Git%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">Git内容</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-25T00:00:00+00:00">2020-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="git常用场景使用技巧"><a href="#git常用场景使用技巧" class="headerlink" title="git常用场景使用技巧"></a><strong>git常用场景使用技巧</strong></h3><ol>
<li><p>功能开发到一半，突然要修复线上问题 （保存现场）</p>
<ol>
<li>在开发分支上：<code>git stash</code> = <code>git stash save</code> 保存未提交的内容（<strong>前提是修改的文件已被版本库追踪过</strong>）<ol>
<li>想要添加保存信息则执行：<code>git stash save -a “message”</code> （git stash save 命令将来会被git stash push 代替）</li>
<li>默认情况下，<code>git stash</code> 只会贮藏已修改和暂存的 <strong>已跟踪</strong> 文件。如果指定 –include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。</li>
</ol>
</li>
<li>切换到其他分支修复bug</li>
<li>修复完后回到原开发分支，并执行 <code>git stash pop</code> (<code>git stash pop</code> = <code>git stash apply  stash@&#123;0&#125;</code> + <code>git stash drop  stash@&#123;0&#125;</code>)</li>
</ol>
</li>
<li><p>不小心把代码提交到错的分支上 （<strong>假设错误分支为test，目标分支为 dev</strong> ）</p>
<ol>
<li><strong>简易操作</strong>：切换到在目标分支dev下执行-&gt; <code>git cherry-pick commitId1 commitId2</code> …</li>
<li><strong>git rebase</strong>：<code>git rebase --onto dev &lt;开始的commitId&gt; &lt;结束的commitId&gt; </code><ol start="2">
<li>执行上述操作后，实际上git 会将dev作为基底分支，将 &lt;开始的commitId&gt; &lt;结束的commitId&gt;  做的相应改变重做一遍，重做的commitId可能跟旧的commitId不一样（若是能ff，则commitId一样），重做后，HEAD指针指向最新的commitId上（游离状态，没有指向任何分支上）</li>
<li>切换到目标分支 <code> git checkout dev</code></li>
<li>将dev分支指向重做的最新的提交点上 <code>git reset --hard  commitId</code> （也属于变基操作，会产生线性提交历史）</li>
</ol>
</li>
</ol>
</li>
<li><p>需要将其他分支的文件复用过来：</p>
<ol>
<li><code>git checkout source_path(其他分支) filename1 filename2 ... (其他分支的文件) </code></li>
</ol>
</li>
<li><p>需要删除中途某次提交：git revert </p>
<ol>
<li><code>git revert commitID</code> 使用一次新的commit来回滚之前的commit</li>
<li>revert 是逆向回放</li>
</ol>
</li>
<li><p><strong>本地仓库</strong>需要回退到某个版本（亦可用于版本前进）：git reset</p>
<ol>
<li> <code>git reset --hard commitId</code> ： 将 commitId 和 commitId 之后的所有提交记录均删除；但是如果 merge 其他老的分支到该分支，commitId后面被回滚的commit应该还会被引入<strong>（一般在提交点push到公共分支之前操作）</strong></li>
<li><code>git reset --soft commitId</code>：此次提交之后的修改会被退回到暂存区。(回退版本<strong>commitId后的修改还保留在本地工作空间</strong>)</li>
<li><code>git reset commitId</code> 默认使用选项 –mixed，此次提交之后的修改会被退回到工作区</li>
<li><code>git reset</code> 用于将当前分支指向任意提交点，包括其他分支的提交点，即可在任意提交点来回穿梭</li>
</ol>
</li>
<li><p>代码版本回退错误，想要重新回到最新提交点，但是提交历史已丢失了（通过git log 查看不到提交记录）</p>
<ol>
<li>使用 <code>git reflog</code> 查看历史操作记录，找到对应要恢复的提交点，执行 git reset 相关方法</li>
</ol>
</li>
<li><p>已经推送到远程公共分支的代码版本正确的回退姿势（<strong>暂时未理解原理</strong>）</p>
<ol>
<li><code>git reset --hard commitId1</code>（要回退的版本）：该操作把 working, index, HEAD 都强行置为 commitId1</li>
<li><code>git reset --soft commitId2</code>（最新提交点）</li>
</ol>
</li>
<li><p><strong>本地仓库</strong>，存在多余的提交，想要压缩成一次提交</p>
<ol>
<li>将上一次提交和这次提交作为一次提交 <code>git commit --amend</code> </li>
<li>多次提交压缩：<code>git rebase -i HEAD~n</code>  (n表示要合并的最近提交的次数)</li>
<li><strong>（一般在提交点push到公共分支之前操作）</strong></li>
</ol>
</li>
<li><p><code>git merge</code> 合并时建议使用 <code>--no--ff</code> 选项保留完整的提交历史（<strong>否则该命令默认策略：“优先–ff，若不能ff则–no-ff”</strong>）</p>
</li>
<li><p>比较各个区域的修改差异</p>
<ol>
<li>git diff – cached：比较缓存区与本地库最近一次commit内容</li>
</ol>
<ul>
<li>git diff：比较缓存区与工作区 </li>
<li>git diff HEAD | git diff commitId 比较工作区与本地最近一次commit内容 （工作区会包含已暂存和未暂存的文件内容）</li>
</ul>
</li>
<li><p>想要查看某次提交做了哪些改动</p>
<ol>
<li><code>git show commitId</code> (相较以下命令常用)</li>
<li><code>git show HEAD@&#123;5&#125;</code>  查看仓库中 HEAD 在五次前的所指向的提交</li>
</ol>
</li>
<li><p>版本迭代发布之际，需要合并其他分支的代码时，查看哪些分支已合并或未合并到当前分支</p>
<ol>
<li>查看哪些分支已经合并到当前分支：git branch –merged </li>
<li>查看哪些分支没有合并到当前分支 git branch –no-merged </li>
</ol>
</li>
<li><p>查看某分支还有哪些提交尚未合并到主分支？</p>
<ol>
<li><strong>双点</strong>：<ol>
<li>在 feature 分支中而不在 master 分支中的提交：<code>git log master..feature</code> </li>
<li>在你当前分支中而不在远程 <code>origin</code> 中的提交：<code>git log origin/master..HEAD</code></li>
</ol>
</li>
<li><strong>三点</strong>：<ol>
<li>想看 master 或者 feature 中包含的但不是两者共有的提交：<code>git log master...feature</code> </li>
<li>增加 –left-right 选项可以显示每个提交到底处于哪一侧的分支</li>
</ol>
</li>
<li><strong>多点</strong>：<ol>
<li>^ 字符或者 –not 来指明你不希望提交被包含其中的分支（以下命令等价）<ol>
<li>git log refA..refB</li>
<li>git log ^refA refB</li>
<li>git log refB –not refA</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>概念</strong></p>
<ol>
<li>本地跟踪分支、远程跟踪分支、远程分支 （pull = fetch + merge）</li>
</ol>
<hr>
<h3 id="其他知识点补充"><a href="#其他知识点补充" class="headerlink" title="其他知识点补充"></a><strong>其他知识点补充</strong></h3><ol>
<li><p>变基 &amp; git merge 区别、commitId 的时间线是否有序</p>
<ol>
<li>变基：以另一个分支为基底分支，保留基底分支在共同祖先之后的提交，再将两个分支<strong>最近的</strong>一个<strong>共同祖先</strong>之后的属于”当前变基操作分支”的提交点，<strong>重做</strong>到基底分支上(<strong>commitId会发生变化</strong>)，均作为当前变基操作分支的内容。</li>
<li>变基后将内容merge 到另一个分支时会丢失该分支提交历史</li>
</ol>
</li>
<li><p>git rebase –onto master &lt;开始的commitId&gt; &lt;结束的commitId&gt; （游离指针 HEAD)</p>
<ol>
<li>git rebase master feature ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍 （省去切换分支到feature上的操作）</li>
<li>git rebase –onto master feature feature-child1 ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍，但暂时并不想合并 feature-child1 中的修改 （feature-child1一般是feature的子分支）</li>
</ol>
</li>
<li><p>Git 合并两个分支时，<strong>如果顺着一个分支走下去可以到达另一个分支的话</strong>，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）（<strong>如果不能到达另一个分支，则会执行 –no-ff</strong> ）</p>
<ol>
<li>非ff：Merge made by the ‘recursive’ strategy. （通过“递归”策略进行合并）</li>
<li>merge 时可以指定提交信息 -m</li>
</ol>
</li>
<li><p>git reset –hard commitId 用于将当前分支指向任意提交点，包括其他分支的提交点</p>
</li>
<li><p>git checkout 可以将 HEAD 引用 指向到任意提交点（游离状态-HEAD指针没有指向对象的分支）</p>
</li>
<li><p>Git push 时如何避免出现 “Merge branch ‘master’ of …”</p>
<ol>
<li>每次从远程分支 pull 新的变动，其实都会执行一次 git merge &lt;远程仓库&gt;/&lt;远程分支&gt;</li>
<li>git pull = git fetch + git merge ：若你本地的远程跟踪分支落后于远程分支，且在这段时间你还在本地分支进行开发并且做了提交，之后你使用git fetch 拉取远程最新的改动，这个时候你的远程跟踪分支与本地开发分支的提交历史就会产生分叉，执行 git pull 或 git merge origin/master的话就会产生合并记录（**–no-ff**）</li>
<li>可以使用 git pull –rebase （git fetch + git rebase） 变基方式去除自动生成的 log 信息<ol>
<li>从 remote 分支拉取更新到本地时，使用 rebase。</li>
<li>当完成 bug 修复或新功能时，使用 merge 将子分支合并到主分支。</li>
<li>没有人应该 rebase 一根共享的分支。</li>
</ol>
</li>
</ol>
</li>
<li><p>HEAD：</p>
<ol>
<li>HEAD就是当前活跃分支的游标。</li>
<li>HEAD并非只能指向分支的最顶端，实际上它可以指向任何一个提交节点，它就是 Git内部用来追踪当前位置的东东。</li>
</ol>
</li>
<li><p><code>git checkout -b mybranch origin/mybranch</code> (可以指定本地分支名)</p>
<p>= <code>git checkout --track origin/mybranch</code></p>
<p>= <code>git checkout origin/mybranch</code> </p>
</li>
<li><p>查看某次提交的改动</p>
<ol>
<li><code>git show commitId</code></li>
</ol>
</li>
<li><p>查看二进制对象文件：</p>
<ol>
<li>git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li>
</ol>
</li>
<li><p>通过具体指定一个提交来拉取该文件的对应版本：</p>
<ol>
<li><code>git reset eb43bf file.txt</code></li>
</ol>
</li>
<li><p>查看某个文件中内容的更改记录：</p>
<ol>
<li>git blame -L 69,82 Makefile （每一行分别来自哪个提交和提交者，-L可以指定行数）</li>
</ol>
</li>
<li><p>二分查找 git bisect</p>
</li>
<li><p> <code>--patch</code> 选项</p>
</li>
<li><p>打包本地仓库：git bundle create repo.bundle HEAD master</p>
</li>
<li><p>git 撤销commit中单个文件的修改：（未验证）</p>
<ul>
<li>git log <fileName>（首先查询这个文件的log）</li>
<li>git reset <commit-id> <fileName> （其次查找到这个文件的上次commit id xxx，并对其进行reset操作）</li>
<li> git checkout <fileName> 撤销对此文件的修改</li>
<li>git commit –amend + git push origin <remoteBranch> （最后amend一下，再push上去）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Git开发工作流"><a href="#Git开发工作流" class="headerlink" title="Git开发工作流"></a>Git开发工作流</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903635533594632#heading-0">https://juejin.im/post/6844903635533594632#heading-0</a></p>
<ol>
<li>可以 <strong>在本地</strong> 随便重写历史记录（推送到远程公共分支之前）。 但是在对提交内容感到满意并准备与他人分享之前，应当避免推送你的工作。</li>
</ol>
<h3 id="GIt工具"><a href="#GIt工具" class="headerlink" title="GIt工具"></a>GIt工具</h3><ol>
<li><p>如何选择修订版本（即提交点）</p>
<ol>
<li><strong>简短的 SHA-1</strong>：可使用简短的 SHA-1来指定唯一的修订版本</li>
<li><strong>祖先引用</strong>：使用 ~ 或者 ^ 指定上一个父提交，~n 或者 ^ n指向前N个父提交，用法如下<ol>
<li>HEAD~3：当前HEAD指针指向的提交点的第三父提交</li>
<li>commitId~~：该提交点的第二父提交点</li>
</ol>
</li>
</ol>
</li>
<li><p>交互式暂存 <code>git add -i</code> 更友好的操作界面</p>
</li>
<li><p>贮藏与清理</p>
<ol>
<li>从贮藏创建一个分支：git stash branch testchanges</li>
<li>清理工作目录：<ol>
<li>git clean；默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 </li>
<li>git clean -i：交互式清理</li>
<li> git clean -f -d：移除工作目录中所有未追踪的文件以及空的子目录。</li>
<li>git clean -n（或者–dry-run）：“做一次演习然后告诉你 将要 移除什么”；要查看空目录需加上-d选项</li>
</ol>
</li>
</ol>
</li>
<li><p>重写历史：</p>
<ol>
<li>修改提交记录：git rebase -i （可以压缩提交或者拆分提交）<ol>
<li>squash 压缩提交到前一次提交</li>
<li>edit 进入对应提交点上，可以在做相应修改并提交到历史线上。</li>
</ol>
</li>
<li>修改大批量的提交：(<strong>未测试通过</strong>)<ol>
<li>删除某次提交中引入的某个文件（如密码文件），且在所有的提交点中都恢复不了该文件： <code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD</code></li>
</ol>
</li>
</ol>
</li>
<li><p>关于重置（ <code>reset</code> 和 <code>checkout</code>）</p>
<ol>
<li>首先要了解git中的三棵树：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">上一次提交的快照，下一次提交的父结点</span><br><span class="line">Index</span><br><span class="line">预期的下一次提交的快照</span><br><span class="line">Working Directory</span><br><span class="line">沙盒</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>HEAD</strong> 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。<ol>
<li>递归查看树结构：git ls-tree -r HEAD</li>
<li>查看二进制对象文件：git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li>
</ol>
</li>
<li><strong>索引</strong>是你的 预期的下一次提交。 <ol>
<li>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。（<strong>git的每次提交都是全量文件的快照</strong>） 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。</li>
<li>git ls-files -s</li>
</ol>
</li>
<li>可以把<strong>工作目录</strong>当做 沙盒。<ol>
<li>HEAD、索引树 将工作区的文件的内容存储在 .git 文件夹中。而工作目录会将它们解包为实际的文件以便编辑。</li>
<li>在将修改提交到暂存区并记录到历史之前，可以随意更改工作目录的文件内容。</li>
</ol>
</li>
<li><strong>切换分支或克隆的过程：</strong>当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照， 然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</li>
<li>git reset 到底做了什么？<ol>
<li>先了解文件提交到版本库的链路：工作树 -&gt; 索引树 -&gt; 对象区(HEAD所指向)；回退的链路则反之</li>
<li>移动 HEAD的指向：与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支所指向的提交点。（<strong>可以理解为，HEAD是一个引用/指针，指针指向分支对象，相当于HEAD的实际对象是分支对象，reset 是修改这个HEAD对象的commitId属性（调用分支对象的setter方法）；而checkout相当于修改HEAD的引用，引用另一个对象</strong>）</li>
<li>git reset –soft：（移动 HEAD 分支的指向）撤销了上一次 git commit 命令，<strong>然后停止</strong>；HEAD树回退到上一次提交的版本，工作区、索引树不变。</li>
<li>git reset –mixed：（使索引看起来像 HEAD）撤销 commit、取消暂存 add ，<strong>然后停止</strong></li>
<li>git reset –hard：（使工作目录看起来像索引）撤销 commit、取消暂存 add ，还原工作区内容</li>
</ol>
</li>
<li>通过具体指定一个提交来拉取该文件的对应版本：<ol>
<li><code>git reset eb43bf file.txt</code> (更新索引)</li>
<li><code>git checkout eb43bf file.txt</code>  (更新索引树和工作空间)</li>
</ol>
</li>
</ol>
</li>
<li><p>git commit操作逻辑：</p>
<ol>
<li>取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象</li>
<li>最后更新 master 来指向本次提交 （HEAD会一直指向当前分支，而该分支会指向最后一次提交的快照（即对象区的内容））</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/09/18/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200918-Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200918-Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-18T00:00:00+00:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>git merge  加不加 –no-ff：fast-forward<br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904013326991368">https://juejin.im/post/6844904013326991368</a></p>
<p>git rebase 推不推荐使用<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29682134">https://zhuanlan.zhihu.com/p/29682134</a></p>
<p>git 中HEAD的概念, 经过merge, pull等操作后, HEAD会否改变<br><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903493078089736">https://juejin.im/entry/6844903493078089736</a></p>
<h2 id="git-基础"><a href="#git-基础" class="headerlink" title="git 基础"></a>git 基础</h2><h3 id="git-是什么？"><a href="#git-是什么？" class="headerlink" title="git 是什么？"></a>git 是什么？</h3><p>分布式版本控制系统</p>
<h3 id="git-有什么用？"><a href="#git-有什么用？" class="headerlink" title="git 有什么用？"></a>git 有什么用？</h3><p>分布式：相比集中式，有去中心化的优势<br>安全性：每个人电脑里都有完整的版本库</p>
<p>强大的分支管理？往下看</p>
<h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>自己从官网下载</p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li><p><code>repository</code>: Git仓库，是commit的集合，仅此而已</p>
</li>
<li><p><code>working tree</code>: 当前文件系统的工作目录，不包括.git</p>
</li>
<li><p><code>index</code>: 暂存区，即将成为一个新的commit的临时节点</p>
</li>
<li><p><code>commit</code>: 可以理解为working tree在某个时间点的一个快照(snapshot)，当然只记录了增量的文件修改</p>
</li>
<li><p><code>branch</code>: Git分支，实质是指向某个commit的指针，有一个别名如<strong>dev</strong>，随着这个分支的提交，这个分支对应指针会指向新的HEAD</p>
</li>
<li><p><code>tag</code>: tag和branch都是指向某个commit的指针，也有一个别名，唯一区别是，tag指向一个commit，指针不会再移动。</p>
</li>
<li><p><code>master</code>: 提交主要分支，系统建立的第一个分支</p>
</li>
<li><p>```plaintext<br>HEAD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重要概念：一个commit指针，用于记录工作区当前checkout的分支状态</span><br><span class="line"></span><br><span class="line">  - 若checkout的是一个branch，那么HEAD指针直接指向该branch</span><br><span class="line">  - 若checkout的是一个tag或是一个commit的hash id，那么HEAD处于detatch状态</span><br><span class="line"></span><br><span class="line">- &#96;tree&#96;: Git中的的树形结构，类似于目录，tree可以包含多个tree，也可以包含blob，blob是叶子节点，tree是非叶子节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三个空间</span><br><span class="line"></span><br><span class="line">工作目录、暂存区域以及 Git 仓库</span><br><span class="line"></span><br><span class="line">- 工作区是对项目的某个版本独立提取出来的内容。</span><br><span class="line">- 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</span><br><span class="line">- Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 开始用Git</span><br><span class="line"></span><br><span class="line">### 命令说明</span><br><span class="line"></span><br><span class="line">git help &lt;verb&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 基本配置</span><br><span class="line"></span><br><span class="line">#### git config </span><br><span class="line"></span><br><span class="line">查看或设置：git config &lt;--system&#x2F;--global&#x2F;--local&gt; &lt;var-name&gt; &lt;var-value&gt; </span><br><span class="line"></span><br><span class="line">系统变量 -- global ：&#x2F;etc&#x2F;gitconfig</span><br><span class="line"></span><br><span class="line">用户变量 -- system：~&#x2F;.gitconfig</span><br><span class="line"></span><br><span class="line">仓库变量 -- local：.git&#x2F;config </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 查看所有的配置以及它们所在的配置文件路径</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;console</span><br><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><p>user.name</p>
<p>user.email</p>
<p>命令别名：alias.co checkout （设置checkout别名为co)</p>
<h4 id="配置忽略版本控制"><a href="#配置忽略版本控制" class="headerlink" title="配置忽略版本控制"></a>配置忽略版本控制</h4><p>.gitignore 列出要忽略的文件的模式</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li>
</ul>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>命令说明：将尚未进行版本控制的本地目录转换为 Git 仓库；</p>
<p>命令结果：创建一个名为 <code>.git</code> 的子目录，含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p>
<h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库</p>
<h3 id="GIt的三种状态"><a href="#GIt的三种状态" class="headerlink" title="GIt的三种状态"></a>GIt的三种状态</h3><p>（已跟踪 或 未跟踪）</p>
<p>（未修改）已修改（modified）  已暂存（staged）已提交（committed）</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p>
<h3 id="使用git管理文件"><a href="#使用git管理文件" class="headerlink" title="使用git管理文件"></a>使用git管理文件</h3><h4 id="查看仓库文件状态"><a href="#查看仓库文件状态" class="headerlink" title="查看仓库文件状态"></a>查看仓库文件状态</h4><p><code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出</p>
<h4 id="查看仓库文件详细修改"><a href="#查看仓库文件详细修改" class="headerlink" title="查看仓库文件详细修改"></a>查看仓库文件详细修改</h4><p>git diff：比较工作目录中当前文件和<strong>暂存区域快照</strong>之间的差异</p>
<p>git diff –staged：比对已暂存文件与最后一次提交的文件差异</p>
<h4 id="提交暂存区的变化"><a href="#提交暂存区的变化" class="headerlink" title="提交暂存区的变化"></a>提交暂存区的变化</h4><p>git commit：提交时记录的是放在<strong>暂存区域的快照</strong>。</p>
<p>跳过使用暂存区域：git commit -a （跳过git add）</p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>git rm：从 Git 中移除某个文件，即从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 </p>
<p>git rm –cached：从 Git 仓库中删除（亦即从暂存区域移除），但仍然保留在当前工作目录中</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>git log：列出每个提交的 SHA-1 校验和、提交时间以及提交说明。</p>
<p>git log -patch：显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。</p>
<p>git log -stat：看到每次提交的简略统计信息</p>
<p>git log –pretty：使用不同于默认格式的方式展示提交历史（git log –pretty=oneline）</p>
<p>git log –graph：添加了一些 ASCII 字符串来形象地展示你的分支、合并历史（图形化）</p>
<h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>git commit –amend：最新的提交将代替上一次提交的结果。（且将当前暂存区中的文件提交）</p>
<p>git restore <file> ：to discard changes in working directory</p>
<p>git restore –staged <file>…：to unstage</p>
<p>git reset –hard HEAD^ / <commitId>：撤销提交</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="查看远程服务器列表"><a href="#查看远程服务器列表" class="headerlink" title="查看远程服务器列表"></a>查看远程服务器列表</h4><p>git remote</p>
<p>git remote -v：详细信息</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>git remote add <shortname> <url> （shortname是别名、简写）</p>
<p>命令行中使用<strong>简写</strong>来代替整个 URL</p>
<p>git remote rename <shortname> <new-shortname></p>
<p>git remote remove <shortname></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>先不学它</p>
<h3 id="git特性-分支特性"><a href="#git特性-分支特性" class="headerlink" title="git特性-分支特性"></a>git特性-分支特性</h3><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>快照</strong> 。</p>
<p>在进行提交操作时，Git 会保存一个<strong>提交对象</strong>（commit object）。提交对象会包含一个指向暂存内容快照的指针。提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的<strong>父对象的指针</strong>。</p>
<ul>
<li>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象 </li>
</ul>
<p><code>git add</code> ：暂存操作会为每一个文件计算校验和（ <strong>SHA-1 哈希算法，长度为 40 的 SHA-1 值字符串</strong>），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 <strong><em>blob</em> 对象</strong>来保存它们），最终将校验和加入到暂存区域等待提交。</p>
<p><code>git commit</code> :</p>
<ol>
<li>Git 会先计算每一个子目录的校验和， 然后在 Git 仓库中这些校验和保存为树对象。</li>
<li>随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</li>
</ol>
<p><strong>Git 仓库包含对象</strong>：blob 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>是一个指针，指向当前所在的本地分支</p>
<h4 id="检出操作"><a href="#检出操作" class="headerlink" title="检出操作"></a>检出操作</h4><ol>
<li>使 HEAD 指回 <code>master</code> 分支</li>
<li>将工作目录恢复成 <code>master</code> 分支所指向的快照内容</li>
</ol>
<p>git log –oneline –decorate –graph –all</p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>git merge</p>
<h5 id="快速合并—快进（fast-forward）"><a href="#快速合并—快进（fast-forward）" class="headerlink" title="快速合并—快进（fast-forward）"></a>快速合并—快进（fast-forward）</h5><p>简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧</p>
<h5 id="三方合并"><a href="#三方合并" class="headerlink" title="三方合并"></a>三方合并</h5><p>若当前分支所在提交并不是待合并分支所在提交的直接祖先，git不会进行 <code>ff</code>， 而会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p>
<p>Git 将三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。（指向 父提交对象 + 新的暂存文件快照？ ）</p>
<h5 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h5><p><code>HEAD</code> 所指示的版本即当前分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支</p>
<p>图形化工具：git mergetool</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch -v：查看每一个分支的最后一次提交</p>
<p>–merged 与 –no-merged 可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</p>
<h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p> <code>git ls-remote &lt;remote&gt;</code> ：显式地获得远程引用的完整列表</p>
<p> <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息</p>
<h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><p>本地会有指向远程分支的不可以修改的<strong>指针</strong>-跟踪分支（使用git fetch来同步本地和远程指针）</p>
<p>可以运行 <code>git merge 远程仓库别名/x远程分支名</code> 将这些工作合并到当前所在的分支。（远程跟踪分支）</p>
<p>如果想要在远程分支上工作，可以将其建立在远程跟踪分支之上</p>
<p><code>git checkout -b 本地分支名 远程仓库别名/远程分支名</code></p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>远程跟踪分支 vs 跟踪分支</p>
<p><code>git checkout -b 本地分支名 远程仓库别名/远程分支名</code></p>
<p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>git checkout -b <branch> <remote>/<branch> 的简化操作：</p>
<p>git checkout –track <remote>/<branch></p>
<p>git checkout <remote>/<branch></p>
<h5 id="设置上游分支"><a href="#设置上游分支" class="headerlink" title="设置上游分支"></a>设置上游分支</h5><p>git branch -u <remote>/<branch></p>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项</p>
<p>git fetch –all; git branch -vv</p>
<ol>
<li>每次 git add 操作，暂存区 .git/index 文件 都会修改</li>
<li>每次 git commit 操作<ol>
<li>.git\refs\heads${分支名} 记录的 commitId会修改</li>
<li>./git/COMMIT_EDITMSG 保存提交信息；logs 保存分支详细的提交信息</li>
<li>对象区 .git/objects  都会增加对应的 对象二进制文件 （名称等于当前commitId的二进制文件 + 其他文件对象的二进制文件）<ol>
<li>数量跟文件数量 + 1 不一致</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/09/14/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200914-Excel%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200914-Excel%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Excel操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-14T00:00:00+00:00">2020-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>HSSF (Horrible SpreadSheet Format（电子表格格式）的缩写)<ol>
<li>对应.xls 文件，兼容 Office97-2003 版本 ）（一个sheet最大行数65536，最大列数256）</li>
</ol>
</li>
<li>XSSF<ol>
<li>容 Office2007及以后版本 （一个sheet最大行数1048576，最大列数16384）</li>
</ol>
</li>
<li><strong>SXSSF</strong> （低内存占用的操作方式）<ol>
<li>SXSSFWorkbook w3= new SXSSFWorkbook(100);//内存中保留100条数据，其余写入硬盘临时文件</li>
</ol>
</li>
</ol>
<h2 id="文档结构类"><a href="#文档结构类" class="headerlink" title="文档结构类"></a>文档结构类</h2><p>HSSFWorkbook excel文档对象<br>HSSFSheet excel的sheet<br>HSSFRow excel的行<br>HSSFCell excel的单元格<br>HSSFFont excel字体<br>HSSFName 名称<br>HSSFDataFormat 日期格式<br>HSSFHeader sheet头<br>HSSFFooter sheet尾<br>HSSFCellStyle cell样式<br>HSSFDateUtil 日期<br>HSSFPrintSetup 打印<br>HSSFErrorConstants 错误信息表</p>
<h3 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h3><h3 id="easyExcel"><a href="#easyExcel" class="headerlink" title="easyExcel"></a>easyExcel</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java">https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java</a></p>
<h3 id="easyPoi"><a href="#easyPoi" class="headerlink" title="easyPoi"></a>easyPoi</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/lemur/easypoi">https://gitee.com/lemur/easypoi</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/09/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-09T00:00:00+00:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何进行单元测试"><a href="#如何进行单元测试" class="headerlink" title="如何进行单元测试"></a>如何进行单元测试</h2><p><strong>参考链接：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn">https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn</a></p>
<p><strong>单元测试”称为“开发阶段的自动化测试“。</strong></p>
<ol>
<li> 由开发同学完成</li>
<li>测试是自动化的</li>
<li>不一定是只验证一个“单元”的正确性</li>
</ol>
<p><strong>单元测试在市面上的介绍存在的问题</strong></p>
<ol>
<li>仅集中在介绍某个工具或者框架怎么用（比如JUnit，mockito，jest等）</li>
<li>一些理论上的对这种测试好处的介绍，通篇是“应该做测试”，“这么做了就容易得到高内聚的代码“</li>
<li>只拿“纯函数”的测试举例子，几乎没有复杂的依赖（无法贴合实际项目：业务逻辑、数据分析的job代码）<ol>
<li>函数的输入就是其所有可见的上下文了。对于一个纯函数，开发者者很容易构造其<strong>上下文</strong>。</li>
</ol>
</li>
<li><strong>很少有关于真正为什么这个事情难以落地的讨论</strong></li>
</ol>
<p><strong>实践起来常见问题</strong></p>
<ol>
<li>没想明白要验证什么</li>
<li>对依赖的处理方式的拿捏是测试里最难的地方。（对不纯的依赖都要尽量mock）<ol>
<li>比如：验证一个下单打折的函数是否能计算出正确的折扣，往往先要从DB获取折扣数据(依赖)，才能做计算。</li>
<li>如果mock掉这个DB查询的依赖，那这个单元测试的假设是：<strong>“读取折扣的SQL本身是肯定没错的，因此不验证它，只验证读到折扣数据后，根据输入金额得到折扣金额的逻辑是正确的“</strong></li>
<li>如果不mock掉DB查询的依赖，即使用真的生产DB做验证，这里测试的目标就从“<strong>验证计算折扣的逻辑</strong>”变成“<strong>验证计算折扣这个功能是否正确</strong>“。<ol>
<li>這裏已经不是“单元”了，而是一个函数 + 一句SQL执行 + DB功能正确的（局部）“集成”测试，是几个组件一起测试才能实现这个验证。这样的测试代价是必须部署一个真的数据库，还要准备数据和<strong>后门</strong>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>到底要不要做”局部集成测试“而非实际的单元测试？</strong></p>
<ul>
<li>你的目标就是要测“一小段代码是不是正确”。你可以很有信心的保证其他依赖的正确性都能保证。那明显，这时就不用花精力做集成了。怎么简单怎么来。这样的测试甚至都不需要启动Spring这类框架，运行速度会很快。</li>
<li>你在开发一个小的lib。这个lib就很纯，没有任何复杂的依赖，那么单元测试就足够了。</li>
<li>如果团队已经安排了专人做这块的集成测试，开发人员就没必要做重复劳动了。如果这块测试的不好，应该优先去和那个测试同学沟通，看看怎么改善。沟通无效，在manager知情和同意下，再自己补。</li>
<li>如果开发自己做集成可以更容易构造全集成，而测试不太容易构造的例子，那么还是自己集成测试一下比较好。性价比高。</li>
<li>如果是要测试一个端到端的接口返回正确，那么唯一的办法就是集成测试——真的启动server，使用真的数据库、Redis、队列……，做端到端的测试。这时也许docker可以帮助你一键启动全套环境。</li>
<li>如果一个测试涉及到依赖的核心功能，也必须得做集成测试。比如要测试一个Exception是不是会让当前事务真的回滚，同时发生的其他事务因为隔离级别不会受到影响，那么你必须引入真的，和生产一模一样的支持事务的数据库才行。</li>
<li>如果是前端测试，基本上也必须得做集成测试。就算可以mock掉所有的后端接口，也得引入浏览器或者App框架才能测试。</li>
</ul>
<p><strong>单元测试目的</strong></p>
<p>验证“自己写的一小段代码是不是符合设计逻辑的“。</p>
<p><strong>单元测试的出发点</strong></p>
<p>开发人员为了保证代码质量应该怎样做</p>
<p><strong>单元测试怎么做？</strong></p>
<ul>
<li>确定测试的目标，到底想验证什么</li>
<li>基于这个目标，找到和维护需要的工具，比如Runner，Mock，覆盖率统计工具等，Embedded数据库等</li>
<li>留足给测试的时间，并通过code review的手段来保证写有效的测试</li>
<li>给一些典型的场景如何做测试写一写文档，积累经验（比如如何测试要模拟时间的案例？）</li>
<li>统计测试同学给开发同学报bug的数据，盯紧代码质量不高的同学，多做沟通</li>
<li>根据出现bug的数量和scope来推动部分关键代码的测试质量的改善</li>
<li>在能达成测试目标的前提下，看看能够整合一些工具，降低维护测试依赖的成本</li>
</ul>
<p><strong>单元测试的好处</strong></p>
<ol>
<li>让你写出更好的代码：只有高内聚、低耦合而且接口设计合理的代码才易于测试；</li>
<li>让你在修改代码时更有信心。</li>
</ol>
<h2 id="单元测试概念"><a href="#单元测试概念" class="headerlink" title="单元测试概念"></a>单元测试概念</h2><h3 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h3><h4 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h4><p>基本框架</p>
<h4 id="testNG"><a href="#testNG" class="headerlink" title="testNG"></a>testNG</h4><p>可以很容易地编写自定义测试。</p>
<p>如果您拥有执行测试所需的测试数据，TestNG可以轻松获取要编写单元测试的测试数据。</p>
<h3 id="模拟框架"><a href="#模拟框架" class="headerlink" title="模拟框架"></a>模拟框架</h3><h4 id="EasyMock"><a href="#EasyMock" class="headerlink" title="EasyMock"></a>EasyMock</h4><p>Mockito的替代品</p>
<ol>
<li>录制：EasyMock.expect(mock.someMethod())</li>
<li>执行：EasyMock.replay(mock)</li>
<li>验证期望：EasyMock.verify(mock)</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h4 id="Mockito-amp-JMockit"><a href="#Mockito-amp-JMockit" class="headerlink" title="Mockito &amp; JMockit"></a>Mockito &amp; JMockit</h4><ol>
<li><h1 id="先进行Stub：when-mock-someMethod-then"><a href="#先进行Stub：when-mock-someMethod-then" class="headerlink" title="先进行Stub：when(mock.someMethod()).then()"></a>先进行Stub：when(mock.someMethod()).then()</h1><h4 id="Mockito-Vs-JMockit"><a href="#Mockito-Vs-JMockit" class="headerlink" title="Mockito Vs JMockit"></a>Mockito Vs JMockit</h4></li>
</ol>
<ol>
<li><p>Stub：when(mock.someMethod()).then()</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>验证行为：verify(mock).someMethod()</p>
</li>
</ol>
<h4 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h4><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>用于模拟复杂场景<br>=======<br>模拟复杂场景</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>想要模拟静态方法、构造函数和私有方法时，Powermock非常有用。</p>
<h3 id="结合项目框架使用的mock框架"><a href="#结合项目框架使用的mock框架" class="headerlink" title="结合项目框架使用的mock框架"></a>结合项目框架使用的mock框架</h3><p>Spring 有 Spring Test、Spring MVC Test</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h4 id="AssertJ-Hamcrest"><a href="#AssertJ-Hamcrest" class="headerlink" title="AssertJ / Hamcrest"></a>AssertJ / Hamcrest</h4><p>Hamcrest提供了AssertJ的替代方案来编写断言。</p>
<h3 id="Spring-Unit"><a href="#Spring-Unit" class="headerlink" title="Spring Unit"></a>Spring Unit</h3><p>Web层- Spring MockMVC</p>
<p>数据层- DataJpaTest</p>
<p>业务层-基于Mockito的测试，最好不要启动Spring Context</p>
<h3 id="断言JSON响应"><a href="#断言JSON响应" class="headerlink" title="断言JSON响应"></a>断言JSON响应</h3><h4 id="JSONAssert-JSONPath"><a href="#JSONAssert-JSONPath" class="headerlink" title="JSONAssert / JSONPath"></a>JSONAssert / JSONPath</h4><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>Cobertura</p>
<h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><p>利用 jenkins 等持续集成工具定时/有代码变更时运行单元测试，保证修改不会破坏已有的代码功能。</p>
<h3 id="Test-Doubles：Fakes、Mocks-以及-Stubs"><a href="#Test-Doubles：Fakes、Mocks-以及-Stubs" class="headerlink" title="Test Doubles：Fakes、Mocks 以及 Stubs"></a>Test Doubles：Fakes、Mocks 以及 Stubs</h3><p><strong>double：</strong>极相似的对应物</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>double存在的意义：用来对系统(或者将粒度放小为模块，单元)进行隔离<br>=======<br>用来对系统(或者将粒度放小为模块，单元)进行隔离</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Dummy</strong></p>
<p>对象被四处传递，但是从不被真正使用。通常他们只是用来填充参数列表。</p>
<p><strong>Fake</strong><br>Fakes are objects that have working implementations, but not same as production one. Usually they take some shortcut and have simplified version of production code.Fake 是那些包含了生产环境下具体实现的简化版本的对象。（用于Test的测试实现类）</p>
<p><strong>Stub</strong></p>
<p>Stub is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don’t want to involve objects that would answer with real data or have undesirable side effects.Stub 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。（提供Query数据的对象）</p>
<p>stub是state-based，关注的是输入和输出。</p>
<p>stub意为踩熄</p>
<p><strong>Mock</strong></p>
<p>Mocks are objects that register calls they receive. In test assertion we can verify on Mocks that all expected actions were performed.Mocks 代指那些仅记录它们的调用信息的对象，在测试断言中我们需要验证 Mocks 被进行了符合期望的调用。(模拟行为的对象)</p>
<p>mock是interaction-based，关注的是交互过程。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26942686">https://zhuanlan.zhihu.com/p/26942686</a></p>
<h3 id="Classical-和-Mockist-TDD-测试风格"><a href="#Classical-和-Mockist-TDD-测试风格" class="headerlink" title="Classical 和 Mockist  TDD 测试风格"></a>Classical 和 Mockist  TDD 测试风格</h3><p>验证状态 vs 验证行为</p>
<h3 id="SUT-amp-UUT-amp-AUT"><a href="#SUT-amp-UUT-amp-AUT" class="headerlink" title="SUT &amp; UUT &amp; AUT"></a>SUT &amp; UUT &amp; AUT</h3><p>SUT（system under test，被测试系统）</p>
<p>UUT（unit under test，被测试单元）</p>
<p>AUT（application under test，被测试应用软件）</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ol>
<li><p>《单元测试之道》</p>
</li>
<li><p>《修改代码的艺术》</p>
</li>
<li><p>Mocks Aren’t Stubs</p>
</li>
</ol>
<h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67801427">https://zhuanlan.zhihu.com/p/67801427</a></p>
<p><a target="_blank" rel="noopener" href="http://tengj.top/2017/12/28/springboot12/">http://tengj.top/2017/12/28/springboot12/</a></p>
<h3 id="场景一、测试控制层"><a href="#场景一、测试控制层" class="headerlink" title="场景一、测试控制层"></a>场景一、测试控制层</h3><h5 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h5><ol>
<li>生成<code>TargetController</code>的单元测试类<code>TargetControllerTest</code>（一般包括整个controller的所有方法的testCase）</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>2. 生成目标方法<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code><br>=======<br>2. 生成<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ol start="3">
<li><p>注解声明单元测试类</p>
<ol>
<li>方式一</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明测试是在spring环境下运行的，这样就可以启用Spring的相关支持。</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 注解负责扫描配置来构建测试用的Spring上下文环境。它默认搜索@SpringBootConfiguration类，除非我们通过classes属性指定配置类，或者通过自定义内嵌的@Configuration类来指定配置。</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>方式二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 实例化一个MockMvc的bean + 可指定只实例化某一到多个Controller（但是同样也会遵从配置类的注解去做更多的工作）</span></span><br><span class="line"><span class="meta">@WebMvcTest(AppCustomerController.class)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>准备MockMvc对象</p>
<ol>
<li><p>方式一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mvc = MockMvcBuilders.webAppContextSetup(wac).build(); <span class="comment">//初始化MockMvc对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<ol>
<li>可直接使用@WebMvcTest实例化的mockMvcBean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>只实例化目标类，避免其他无关类的实例化开销（自定义内嵌的@Configuration类来指定配置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;xxx&quot;,</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false,</span></span><br><span class="line"><span class="meta">        includeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.REGEX,</span></span><br><span class="line"><span class="meta">                pattern = &#123;&quot;xxx.TargetController&quot;&#125;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解决TargetController被测对象的其他依赖问题</p>
</li>
<li><p>将测试目标的所有依赖bean声明为<strong>模拟的bean</strong>，这些模拟的bean将<strong>被注入测试目标bean</strong>。</p>
</li>
<li><p>构建MockHttpSession，解决请求过程中的用户验证问题</p>
</li>
<li><p>绝大部分的方法受限于公司封装的底层框架，必须实例化对应的bean，且为带参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部嵌套javaConfig类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringContext <span class="title">springContext</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringContext(beanFactory); <span class="comment">// 由SqlContext实例化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">BaseService baseService;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">CustomerSessionService customerSessionService;</span><br></pre></td></tr></table></figure></li>
<li><p>Mockito.spy()方法模拟出来的对象，调用该模拟对象的方法时，若该方法没有被”打桩“（预设），则会实际调用该方法真实逻辑。相比Mockito.mock()出来的模拟对象，若调用mock对象的方法没有被打桩，则返回默认值。</p>
</li>
<li><p>doReturn().when()与when().thenReturn()</p>
<ol>
<li>spy模拟对象<ol>
<li>when(…) thenReturn(…)会调用真实的方法</li>
<li> doReturn(…) when(…) 不会调用真实方法</li>
</ol>
</li>
</ol>
</li>
<li><p>2.1.0版本以前的<strong>Mockito</strong>是<strong>不能mock final类和final方法的</strong>，之后的也要通过配置一些相关文件才行(<a target="_blank" rel="noopener" href="https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mock-the-unmockable-opt-in-mocking-of-final-classesmethods">Mock the unmockable: opt-in mocking of final classes/methods</a>)。因此，它的补充框架PowerMock也应运而生。</p>
<ol>
<li>创建配置文件 src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker</li>
<li>文件内容：mock-maker-inline</li>
</ol>
</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>12. powerMock（未实践）<br>=======<br>12. powerMock</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span> <span class="comment">// 替代SpringRunner.class</span></span><br><span class="line"><span class="comment">// // powermock使用了自定义的PowerMockRunner，与spring集成时，可以代理至SpringJUnit4ClassRunner。</span></span><br><span class="line"><span class="meta">@PowerMockRunnerDelegate(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// @PowerMockRunnerDelegate(Parameterized.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;StaticService.class&#125;)</span> <span class="comment">// 包含静态类的方法</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="13">
<li>powerMock + org.mockito.plugins.MockMaker 冲突问题<ol>
<li>org.mockito.internal.configuration.plugins.PluginLoader：java.lang.ClassNotFoundException: mock-maker-inline</li>
<li>删掉扩展文件后：java.lang.NoSuchMethodError: org.mockito.MockingDetails.getMockCreationSettings()</li>
</ol>
</li>
<li>@Mock 和 @InjectMocks 搭配使用（而非@MockBean）</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>    1. 而 @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）<br>=======<br>    1. @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MockBean(name = &quot;guide.SgGuide&quot;)</span></span><br><span class="line">SgGuide sgGuide;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="16">
<li><p>ArgumentMatchers.any() vs Mockito.any() 是同一个东西，<strong>Mockito 继承了 ArgumentMatchers</strong></p>
</li>
<li><p>doxxx().when() 不能用于 @MockBean 场景下??? （given().willReturn()）</p>
</li>
<li><p><strong>mockMvc添加过滤器</strong></p>
<ol>
<li>mMockMvc = MockMvcBuilders.webAppContextSetup(context).addFilter(new UserFilter()).build();</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/09/06/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200906-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCPU%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200906-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCPU%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Java并发编程之CPU缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-06T00:00:00+00:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>多线程操作共享变量，变量值不一致。</p>
</li>
<li><p>使用volatile关键字修饰共享变量，保证共享变量在线程之间的可见性。</p>
<ul>
<li>synchronized 关键字也能保证共享变量在多个线程之间的可见性</li>
<li>CAS 机制也能保证共享变量在多个线程之间的可见性</li>
</ul>
</li>
<li><p>CPU读写模型是引发变量可见性的原因</p>
<ul>
<li> 主存RAM存取速度比 CPU操作慢得多，为避免CPU高速处理能力不能充分发挥作用，所以CPU处理器引入了高速缓冲存储器。（造价高，容量较主存小）</li>
<li>程序局部性原理（？？？）：CPU试图访问主存的某一单元时，会认为临近单元后续被利用的可能性很大，所以CPU在存取主存单元时，计算机硬件会自动把包括该单元在内的那一组单元调入高速缓存，之后CPU就可以直接对高速缓存数据进行存取。（一组单元称为内存块<code>block</code>，通常是连续的64个字节）</li>
</ul>
</li>
<li><p>CPU Cache相关术语</p>
<ul>
<li>Cache Line &amp; Slot &amp; Hot Data &amp; Cache Hit<ul>
<li>Cache Line = Slot </li>
<li>高速缓存会将其存储单元均分成若干等份，每一等份就是一个缓存行，如今主流CPU的缓存行一般都是64个字节</li>
<li>被缓存行缓存的数据称之为热点数据（hot data）</li>
</ul>
</li>
<li>Cache Hit &amp; Cache Miss &amp; Hit Latency<ul>
<li>Cache Hit：当CPU通过<code>寄存器</code>中存储的数据地址请求访问数据时（包括读操作和写操作），首先会在Cache中查找，如果找到了则直接返回Cache中存储的数据，这称为<strong>缓存命中</strong>（cache hit），根据操作类型又可分为读缓存命中和写缓存命中。</li>
<li>Hit Latency：命中延迟是指判断Cache中是否缓存了目标数据所花的时间。</li>
</ul>
</li>
<li>Cache分级：速度— L1 &gt; L2 &gt; L3（L3在CPU的多个核心之间共享）</li>
<li>Cache替换算法 &amp; Cache Line Conflict<ul>
<li>常用的算法：“最近最少使用算法”（LRU算法）least recently used；原理：为每行设置一个计数器，把名中行的计数器清零，其他各行计数器加1，当需要替换时淘汰行计数器计数值最大的数据行出局</li>
</ul>
</li>
<li>时钟周期：完成一次存取操作所需的时间—主频倒数（寄存器、高速缓存、主存都有主频）</li>
</ul>
</li>
<li><p>Cache结构设计和缓存关联性（<code>关联主内存</code>）</p>
<ul>
<li><strong>CPU高速缓存组成</strong>：整个Cache被分为S个组，每个组又有E行个最小的存储单元——Cache Line；而一个Cache Line中有B（B=64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据</li>
<li><strong>Cache Line组成</strong>：包含1个有效位（valid bit）、t个标记位（tag bit）、数据<ul>
<li>— valid bit用来表示该缓存行是否有效；tag bit用来协助寻址，唯一标识存储在Cache Line中的块；而Cache Line里的64个字节其实是对应内存地址中的数据拷贝。</li>
</ul>
</li>
<li>将高速缓存内的数据映射到主内存的数据（<strong>缓存关联性</strong>）<ul>
<li>完全关联(Fully associative cache) <ul>
<li>以32位操作系统（意味着到内存寻址时是通过32位地址）为例，，比如有一个0101…10 000000 - 0101…10 111111（为了节省版面省略了高26位中的部分bit位，这个区间代表高26位相同但低6位不同的64个地址，即64字节的内存块（主内存的存储单元：连续的64个字节））内存块需要缓存，那么它将会被随机存放到一个可用的Slot中，并将高26位作为该Slot的tag bit（前文说到每行除了存储内存块的64字节Cache Line，还额外有1个bit标识该行是否有效和t个bit作为该行的唯一ID，本例中t就是26）。这样当内存需要存取这个地址范围内的数据地址时，首先会去Cache中找是否缓存了高26位（tag bit）为0101…10的Slot，如果找到了再根据数据地址的低6位定位到Cache Line的某个存储单元上，这个低6位称为字节偏移（word offset）。<ul>
<li>6位字节偏移(2^6=64个字节)——<strong>主内存的存储单元block的大小固定位64个字节</strong></li>
<li>26位 tag bit 作为数据块唯一标识，用于寻址时轮询所有缓存行(slot)并匹配数据块</li>
</ul>
</li>
</ul>
</li>
<li>直接映射(Direct mapped cache) <ul>
<li>包含tag bit 位数据地址 + slot offset(定位slot) + word offset 字节偏移（缓存行）</li>
<li>对于给定的32位数据地址，首先不管低6位，取出中间的<code>slot offset</code>个bit位，定位出是哪一个Slot，然后比较该Slot的<code>tag bit</code>是否和数据地址的剩余高位匹配，如果匹配那么表示Cache Hit，最后在根据低6位从该Slot的Cache Line中找到具体的存储单元进行存取数据。</li>
<li>缺点：低位相同但高位不同的内存块会被映射到同一个Slot上（因为对SlotCount取模之后结果相同），如果碰巧CPU请求存取这些内存块，那么将只有一个内存块能够被缓存到Cache中对应的Slot上，也就是说容易发生Cache Line Conflict。</li>
</ul>
</li>
<li>N路组关联(N-way set associative cache) <ul>
<li>对Direct Mapped Cache和Full Associative Cache的一个结合，思路是不要对于给定的数据地址就定死了放在哪个Slot上。</li>
<li>先将Cache均分成S个组，每个组都有E个Slot。假设将我的L1 Cache 128KB按16个Slot划分为一个组，那么组数为：<code>128 * 1024 / 64</code>（Slot数）/ 16 = 128 个组（我们将每个组称为一个Set，表示一组Slot的集合）；与Direct Mapped Cache不同的地方就是将原本表示映射到哪个Slot的11个中间bit位改成了用7个bit位表示映射到哪个Set上，在确定Set之后，内存块将被放入该Set的哪个Slot是随机的（可能当时哪个可以用就放到哪个了），然后以剩余的高位19个bit位作为最终存放该内存块的<code>tag bit</code>。</li>
<li>对于一个给定的数据地址只会将其映射到特定的Set上，这样就大大减小了Cache Line Conflict的几率，并且CPU在查找Slot时只需在具体的某个Set中线性查找，而Set中的Slot个数较少（分组分得越多，每个组的Slot就越少），这样线性查找的时间复杂度也近似O(1)了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何编写对Cache Hit友好的程序？为提高Cache命中率，要充分发挥局部性原理。</p>
<ul>
<li><p><strong>时间局部性</strong>：对于同一数据可能被多次使用，自第一次加载到Cache Line后，后面的访问就可以多次从Cache Line中命中，从而提高读取速度（而不是从下层缓存读取）。</p>
</li>
<li><p><strong>空间局部性</strong>：一个Cache Line有64字节块，我们可以充分利用一次加载64字节的空间，把程序后续会访问的数据，一次性全部加载进来，从而提高Cache Line命中率（而不是重新去寻址读取）。</p>
</li>
<li><p>实际操作：读取时尽量读取相邻的数据地址</p>
<ul>
<li><p>以上操作带来的负面影响：造成缓存一致性问题。</p>
</li>
<li><p>解决方案：（缓存一致性协议）</p>
<ul>
<li><pre><code>这是一个跟踪每个缓存行的状态的缓存子系统。该系统使用一个称为 “总线动态监视” 或者称为*“总线嗅探”* 的技术来监视在系统总线上发生的所有事务，以检测缓存中的某个地址上何时发生了读取或写入操作。
当这个缓存子系统在系统总线上检测到对缓存中加载的内存区域进行的读取操作时，它会将该缓存行的状态更改为 “shared”。如果它检测到对该地址的写入操作时，会将缓存行的状态更改为 “invalid”。
该缓存子系统想知道，当该系统在监视系统总线时，系统是否在其缓存中包含数据的惟一副本。如果数据由它自己的 CPU 进行了更新，那么这个缓存子系统会将缓存行的状态从 “exclusive” 更改为 “modified”。如果该缓存子系统检测到另一个处理器对该地址的读取，它会阻止访问，更新系统内存中的数据，然后允许该处理的访问继续进行。它还允许将该缓存行的状态标记为 shared。
</code></pre>
</li>
<li><p>各CPU都会通过总线嗅探来监视其他CPU，一旦某个CPU对自己Cache中缓存的共享变量做了修改（能做修改的前提是共享变量所在的缓存行的状态不是无效的），那么就会导致其他缓存了该共享变量的CPU将该变量所在的Cache Line置为无效状态，在下次CPU访问无效状态的缓存行时会首先要求对共享变量做了修改的CPU将修改从Cache写回主存，然后自己再从主存中将最新的共享变量读到自己的缓存行中。（这里的CPU指的是CPU核心）</p>
</li>
<li><p>并且，缓存一致性协议通过缓存锁定来保证CPU修改缓存行中的共享变量并通知其他CPU将对应缓存行置为无效这一操作的原子性，即当某个CPU修改位于自己缓存中的共享变量时会禁止其他也缓存了该共享变量的CPU访问自己缓存中的对应缓存行，并在缓存锁定结束前通知这些CPU将对应缓存行置为无效状态。</p>
</li>
<li><p>在缓存锁定出现之前，是通过总线锁定来实现CPU之间的同步的，即CPU在回写主存时会锁定总线不让其他CPU访问主存，但是这种机制开销较大，一个CPU对共享变量的操作会导致其他CPU对其他共享变量的访问。(锁粒度由总线细化到CPU核心)</p>
</li>
</ul>
</li>
<li><p>缓存一致性协议带来的问题：<strong>伪共享</strong>——不同CPU核心对同一缓存行的不同字节数据的操作可能会导致缓存锁定（变成串行程序，降低了并发性（乒乓效应））</p>
</li>
<li><p>伪共享问题解决方案：</p>
<ul>
<li>缓存行填充（Cache Line Padding），通过增加两个变量的地址距离使之位于两个不同的缓存行上，如此对共享变量X和Y的操作不会相互影响。</li>
<li>线程不直接操作全局共享变量，而是将全局共享变量读取一份副本到自己的局部变量，局部变量在线程之间是不可见的因此随你线程怎么玩，最后线程再将玩出来的结果写回全局变量。（再进行锁定）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并发编程的三要素是：原子性、可见性、有序性。</p>
</li>
<li><p><strong>锁释放有着volatile域写语义</strong>？？ &amp; 原子类CAS更新有着volatile域写语义</p>
</li>
<li><p>Unsafe类中的CAS自旋</p>
<ul>
<li>CAS操作在x86上是由cmpxchg（Compare Exchange）实现的（不同指令集有所不同）</li>
<li>JDK提供的AtomicXxx`系列原子操作类已能满足大多数需求</li>
<li><strong>原子类封装了一个volatile域</strong>：将改写立即刷新到主存；将改写立即刷新到主存</li>
</ul>
</li>
<li><p>volatile禁止重排序</p>
<ul>
<li>volatile产生的汇编指令lock具有个指令屏障使得该屏障之前的指令不能重排序到屏障之后。</li>
<li>volatile的作用案例：使用单例模式的并发优化案例<ul>
<li>懒加载模式<ul>
<li>利用类加载过程的初始化阶段会执行<strong>类构造器</strong><clinit>，按照显式声明为<strong>静态变量</strong>初始化的特点。</li>
<li><strong>当类被主动引用时应当立即对其初始化</strong>！！！</li>
<li>对类的主动引用：<ul>
<li>new、getStatic、putStatic、invokeStatic</li>
<li>通过java.lang.reflect包的方法对该类进行反射调用时</li>
<li>当初始化一个类时，如果他的父类没被初始化，那么先初始化其父类</li>
<li>当JVM启动时，首先会初始化main函数所在的类</li>
</ul>
</li>
<li>对类的被动引用：<ul>
<li>通过子类访问父类静态变量，子类不会被立即初始化</li>
<li>通过数组定义引用的类不会被立即初始化</li>
<li>访问某个类的常量，该类不会被立即初始化（因为经过编译阶段的常量传播优化，该常量已被复制一份到当前类的常量池中了）</li>
</ul>
</li>
</ul>
</li>
<li>饿汉模式1</li>
<li>饿汉模式2</li>
<li>DoubleCheckedLocking</li>
<li>DCL2</li>
<li>InstanceHolder</li>
<li>枚举实例的构造器只会被调用一次</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/08/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200827-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200827-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91/" class="post-title-link" itemprop="url">Java并发编程视频</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-27T00:00:00+00:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>synchronized 默认是非公平锁，与线程申请锁顺序和等待锁时间无关</li>
<li>reentrantLock可实现公平锁，tryLock，lockInterruptablly</li>
<li>wait与notify结合与synchronized关键字使用建立同步模型<ol>
<li>避免在获得obj锁后才能够去调用obj的wait与notify/notifyAll三个方法，否则就会报错。（即synchronized代码块内）</li>
<li>在调用wait的时候，线程自动释放其占有的对象锁，同时不会去申请对象锁。当线程被唤醒的时候，它才再次获得了去获得对象锁的权利。（<strong>要等到获得锁后才真正可执行</strong>）</li>
<li>notify仅唤醒一个线程并允许它去获得锁（<strong>由JVM确定唤醒哪个线程</strong>），notifyAll是唤醒所有等待这个对象的线程并允许它们去获得对象锁。（<strong>要等到获得锁后才真正可执行</strong>）</li>
<li>notifyAll，虽然是对每个wait的对象都调用一次notify，但是这个还是<strong>有顺序的</strong>，每个对象都保存这一个等待对象链，调用的顺序就是这个链的顺序。</li>
<li>当线程B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1,A2,A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2,A3中的一个才有机会获得锁继续执行。（<strong>由JVM确定哪个线程获得锁-非公平</strong>）</li>
<li>永远选择使用notifyAll而非notify，notify容易造成死锁，所有线程都在wait</li>
</ol>
</li>
<li>生产者消费者问题：<ol>
<li>synchronized 同步生产方法，生产者线程获得锁进入代码块后，若容器容量达到上限，则调用对象.wait()方法释放锁，其他生产者线程可以获得对象锁并进入同步生成方法，再次判断容器元素数量，达到上限则同样调用wait()方法并释放锁。此时多个生产者线程均在wait()，等待被唤醒。</li>
<li>基于条件1情况下，此时消费者线程进入消费方法，消费了容器元素，并调用notifyAll()方法唤醒所有等待线程，此时等待中的所有生产者线程被唤醒，但是都在等待获得对象锁才能继续往前执行，得到对象锁的生产者线程需要再次判断元素数量，避免导致超出容器容量。</li>
</ol>
</li>
<li>使用 lock 和 condition 代替 synchronized + wait/notify<ol>
<li>lock.lock()，condition.await()，condition.signalAll() 一起使用</li>
<li>lock可以精确指定唤醒的线程</li>
</ol>
</li>
<li>ThreadLocal 线程局部变量<ol>
<li>内存泄漏：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903683751149582">https://juejin.im/post/6844903683751149582</a></li>
<li>空间换时间</li>
</ol>
</li>
<li>socket长连接（TCP&amp;UDP）</li>
<li>Java的线程池是基于并发容器实现的</li>
<li>线程安全的单例模式—以下方式既不用加锁，也能实现懒加载<ol>
<li>使用静态内部类：访问静态内部类的时候才会加载静态内部类</li>
</ol>
</li>
<li>并发容器<ol>
<li>ConcurrentHashMap（分段同步锁，默认16段，细化锁的粒度；1.8后node cas替代了section分段锁）— HashTable 锁住整个容器对象</li>
<li>高并发且有排序需求，使用ConcurrentSkipMap替代TreeMap(SortedMap)<ol>
<li>排序map：插入慢</li>
</ol>
</li>
<li>CopyOnWriteList 对比 ArrayList和Vector<ol>
<li>适合写少读多的场景（如监听器队列）</li>
<li>写时复制列表：<ol>
<li>读的效率高，写效率低</li>
<li>写的时候，复制一份新的数据，不影响其他线程读数据旧的数据，写完后，将旧对象的引用指向新数据对象。</li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/java-copy-on-write/">http://ifeve.com/java-copy-on-write/</a></li>
</ol>
</li>
</ol>
</li>
<li>queue 英 [kjuː] 并发场景使用的队列分为以下两种<ol>
<li>ConcurrentLinkedQueue  （并发<strong>加锁</strong>且<strong>无界</strong>单向队列-单向链表）<ol>
<li>offer() // 同 add 方法</li>
<li>poll()   //  获取第一个元素，且删除</li>
<li>peek() //  获取第一个元素，但不删除</li>
</ol>
</li>
<li>BlockingQueue 阻塞队列<ol>
<li>队列实现<ol>
<li>LinkedBlockingQueue (-)</li>
<li>ArrayBlockingQueue (有界)</li>
</ol>
</li>
<li>方法<ol>
<li>put()：如果满了，线程会等待</li>
<li>take()：如果空了，线程会等待</li>
<li>add()：如果满了，线程会抛异常</li>
<li>offer() // 同 add 方法，不会抛异常，而是返回添加结果boolean</li>
</ol>
</li>
</ol>
</li>
<li>DelayQueue 延迟队列，元素根据可消费时间排序<ol>
<li>元素要实现Delayed接口（Delayed接口实现了Comparable接口）</li>
<li>适用场景：执行定时任务</li>
</ol>
</li>
<li>TransferQueue：（效率较高）<ol>
<li>transfer() 场景：实时消息处理，生产者生产数据直接传送给消费者，若没有消费者或消费者来不及处理时，则生产者阻塞（如游戏服务器上接收消息传达给客户端）</li>
<li>put()：不会阻塞，直接放入队列</li>
<li>take()：消费</li>
</ol>
</li>
<li>SynchronousQueue：（特殊的TransferQueue，容量为0，生产者生产数据时必须要有消费者消费）<ol>
<li>put()：若没有消费者则阻塞</li>
<li>add()：若没有消费者会抛异常</li>
</ol>
</li>
</ol>
</li>
<li>deque 英 [dek] 双端队列 </li>
</ol>
</li>
<li>线程池<ol>
<li>需从Executor顶层接口说起，定义标准接口execute(Runnable r)</li>
<li>ExecutorService（interface 服务，执行任务）<ol>
<li>submit(Runnable r)</li>
<li>submit(Callable c)</li>
</ol>
</li>
<li>Runnable &amp; Callable<ol>
<li>Callable：有返回值，且可以捕获checked异常</li>
</ol>
</li>
<li>Executors：工具类（工厂方法&amp;工具方法）</li>
<li>ThreadPool 线程池<ol>
<li>ExecutorService executorService = Executors.newFixedThreadPool(size); // 固定线程数量线程池</li>
<li>Executors.newCachedThreadPool(); // 弹性数量的线程池，新增任务，若池子里没有空闲的线程，则新增线程执行任务，线程的空闲时间超过N秒后自动销毁，N秒可在创建线程池时可指定。</li>
<li>Executors.newScheduledThreadPool(); // 英 [ˈʃedjuːl] 美 [ˈskedʒuːl] 定时执行任务，参考DelayQueue，替代Timer（Scheduled复用线程，Timer每次都新起线程），定时模式如下：<ol>
<li>固定频率执行</li>
</ol>
</li>
<li>Executors.newSingleThreadPool();  // 任务需顺序执行的场景</li>
<li>Executors.newWorkStealingPool();  // daemon守护线程线程池（精灵线程、后台线程） （若没有非守护线程工作，则销毁？）// 0、1、2、3 四个线程<ol>
<li>内部机制：ForkJoinPool</li>
</ol>
</li>
<li>ForkJoinPool（精灵线程）</li>
</ol>
</li>
<li>Future &amp; FutureTask<ol>
<li>FutureTask 是 <strong>Future</strong> 和 <strong>Runnable 的实现类</strong>；FutureTask的重写的run方法中执行了Callable.call()方法</li>
<li>FutureTask <strong>包含Callable引用</strong>，包含Callable形参的构造器；</li>
<li>FutureTask.get()阻塞获取返回值的原理：(Future阻塞拿到返回值的原理)<ol>
<li>循环等待Task任务的结果(用outcome表示执行结果，state变量表示任务运行状态)</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li>synchronized是悲观锁，juc包中的原子类使用的是乐观锁测试，使用cas算法，由硬件直接支持原子性。<ol>
<li>存在ABA问题：A-&gt;B  的过程中已被其他线程执行了 A-&gt;B-&gt;A 操作</li>
<li>ABA漏洞可以采用 java 原子引用类解决？？</li>
</ol>
</li>
<li>越大的素数，需要计算的时间越长：</li>
</ol>
<p><code>for(int i=2;i&lt;num/2;i++)&#123;if(num%i==0) return false&#125;</code></p>
<ol start="14">
<li>创建线程、销毁线程都要操作系统的用户态-&gt;内核态（消耗系统资源）</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>Java多线程之wait(),notify(),notifyAll()：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alex197963/article/details/6863662">https://blog.csdn.net/alex197963/article/details/6863662</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/08/26/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200826-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200826-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)/" class="post-title-link" itemprop="url">Java并发编程(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-26T00:00:00+00:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发历史"><a href="#并发历史" class="headerlink" title="并发历史"></a>并发历史</h2><ol>
<li>早期计算机执行程序时，只会顺序执行，且顺序使用计算机资源，其他空闲资源没有被充分利用。(其他程序不会得到执行)</li>
<li>操作系统的出现为程序带来了 并发性，使得计算机能同时运行多个程序，同时使用计算机资源。</li>
</ol>
<p>操作系统实现多个程序同时运行解决了单个程序无法做到的问题：</p>
<ol>
<li>资源利用率：单个进程存在资源浪费的情况，其他进程会等待正在执行的进程完成任务</li>
<li>公平性？操作系统会为不同的程序划分时间片来使用资源，每个进程都有能够公平享有资源的权利，且操作系统可以决定不同进程的优先级（低优先级进程会出现进程饥饿问题）</li>
<li>进程间信息交换</li>
</ol>
<p>单进程顺序编程-串行编程的好处：直观性、简单性。</p>
<p>多进程出现的同时，促使着线程的出现：</p>
<p><strong>进程是一个应用程序，而线程是应用程序中的一条顺序流</strong>。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一种<code>轻量级</code>的进程，轻量级体现在线程的创建和销毁要比进程的开销小很多。</p>
<p>线程私有：程序计数器、寄存器、堆栈、局部变量</p>
<p>线程会共享进程范围内的资源：xxx 不了解</p>
<p>单个CPU情况下，应用程序想要并发执行多个任务的话，会经历多次状态暂存任务切换，CPU在多个任务之间进行切换。</p>
<p>Java 很好的在<strong>用户空间</strong>实现了开发工具包，并在<strong>内核空间</strong>提供系统调用来支持多线程编程。Java 支持了丰富的类库 <code>java.util.concurrent</code> 和跨平台的<code>内存模型</code></p>
<p><strong>问题：</strong></p>
<p><strong>理解进程、线程、CPU、核心、寄存器、指令的关系：</strong> ？</p>
<p>指令是在 CPU 中执行的，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行；</p>
<p>CPU 内部是寄存器的构造；</p>
<h2 id="并发为什么会出现"><a href="#并发为什么会出现" class="headerlink" title="并发为什么会出现"></a>并发为什么会出现</h2><p>CPU、内存和 I/O 设备一直存在速度差异性问题。</p>
<p>CPU 内部是寄存器的构造，寄存器的访问速度要高于CPU<code>高速缓存</code>，高速缓存的访问速度要高于内存（主存RAM），最慢的是磁盘访问。</p>
<p>因为 CPU 速度太快了，所以为了发挥 CPU 的速度优势，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li><strong>CPU</strong> 使用<strong>缓存</strong>来中和和内存的访问速度差异（CPU缓存）</li>
<li>操作系统提供<strong>进程和线程调度</strong>，让 CPU 在执行指令的同时分时复用线程，让内存和磁盘不断交互，不同的 <code>CPU 时间片</code> 能够执行不同的任务，从而均衡这三者的差异</li>
<li>编译程序提供优化指令的执行顺序，让缓存能够合理的使用？</li>
</ul>
<h2 id="线程带来的安全性问题"><a href="#线程带来的安全性问题" class="headerlink" title="线程带来的安全性问题"></a>线程带来的安全性问题</h2><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>单核时代，单核CPU调度多个线程执行任务，CPU缓存和主内存是一一对应关系，CPU缓存数据跟主内存数据版本一致。线程写操作会将数据同时写到CPU缓存和主内存，<strong>且多个线程共享同一个CPU下的缓存？？</strong></p>
<p>多核时代，每个CPU核心都有自己的缓存，当每个CPU分配时间片给线程执行时，每个线程都是直接读取CPU缓存，这时CPU缓存和内存的<strong>线程共享数据</strong>存在不一致问题。</p>
<p><code>synchronized</code>的<strong>锁释放-获取</strong>和<strong>CAS修改-读取</strong>都有着和<code>volatile</code>域的<strong>写-读</strong>有相同的语义。</p>
<h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>典型的 i++操作：（<strong>复合类操作</strong>）</p>
<ol>
<li>先读取到i值 （存储到CPU<strong>寄存器</strong>）</li>
<li>再进行 i+1操作 （此时可能发生线程切换）</li>
<li>将i+1赋值给i （将结果写入内存）</li>
</ol>
<p>线程的切换是产生线程安全性的必要条件。</p>
<p>线程切换是导致竞态条件出现的诱导因素。（<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong> ）</p>
<h3 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h3><p><strong>如果一组线程中的每个线程都在等待一个事件的发生，而这个事件只能由该组中正在等待的线程触发，这种情况会导致死锁</strong>。</p>
<h3 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h3><p>线程间的等待，以及无限等待造成死锁</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>与活跃性问题密切相关的是 <code>性能</code> 问题，如果说活跃性问题关注的是最终的结果，那么性能问题关注的就是造成结果的过程，性能问题有很多方面：比如<strong>服务时间过长，吞吐率过低，资源消耗过高</strong>，在多线程中这样的问题同样存在。</p>
<p><strong>最大的影响性能的因素：线程切换/上下文切换</strong></p>
<ol>
<li><p>挂起当前线程</p>
</li>
<li><p>保存和恢复上下文：</p>
<ol>
<li>保存线程、寄存器、程序计数器等状态</li>
<li>线程调度器：选择一个合适的线程</li>
<li>线程：加载程序计数器</li>
</ol>
</li>
</ol>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>多个线程可以同时安全调用的代码称为线程安全的，如果一段代码是安全的，那么这段代码就不存在 <code>竞态条件</code>。仅仅当多个线程共享资源时，才会出现竞态条件。</p>
<p><strong>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的</strong>。</p>
<h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为 <code>内置锁(Instrinsic Lock)</code>或者 <code>监视器锁(Monitor Lock)</code>。</p>
<p>synchronized 是同步锁即互斥锁或独占锁，也是可重入锁，也是非公平锁。</p>
<p>锁重入支持子类和父类之间的重入；</p>
<p>volatile 是一种轻量级的 synchronized；volatile 的执行成本要比 <code>synchronized</code> 低很多，因为 volatile 不会引起线程的上下文切换。volatile 通过保证共享变量的可见性对对象进行加锁。（线程通信，保证可见性）；</p>
<p>还可以使用<code>原子类</code> 来保证线程安全；还可以使用 <code>java.util.concurrent</code> 工具包下的线程安全的集合类（并发容器）来确保线程安全。</p>
<h2 id="竞态条件和关键区域"><a href="#竞态条件和关键区域" class="headerlink" title="竞态条件和关键区域"></a>竞态条件和关键区域</h2><p>竞态条件是在关键代码区域发生的一种特殊条件。</p>
<p>关键区域是由多个线程同时执行的代码部分；</p>
<p>如果多个线程执行一段关键代码，而这段关键代码会因为执行线程的顺序不同而造成不同的结果时，那么这段代码就会包含竞争条件。</p>
<p>竞态条件：<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong></p>
<h2 id="并发模型和分布式系统很相似"><a href="#并发模型和分布式系统很相似" class="headerlink" title="并发模型和分布式系统很相似"></a>并发模型和分布式系统很相似</h2><p>并发模型中是<code>线程</code>彼此进行通信；</p>
<p>在分布式系统模型中是 <code>进程</code> 彼此进行通信；</p>
<h2 id="共享状态-amp-独立状态"><a href="#共享状态-amp-独立状态" class="headerlink" title="共享状态&amp;独立状态"></a>共享状态&amp;独立状态</h2><p>并发模型的一个重要的方面是，线程是否应该<code>共享状态</code>，是具有<code>共享状态</code>还是<code>独立状态</code>。共享状态也就意味着在不同线程之间共享某些状态。</p>
<p>状态其实就是<code>数据</code>，比如一个或者多个对象。当线程要共享数据时，就会造成 <code>竞态条件</code> 或者 <code>死锁</code> 等问题。</p>
<h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><h3 id="并行-Worker"><a href="#并行-Worker" class="headerlink" title="并行 Worker"></a>并行 Worker</h3><p>客户端会把任务交给 <code>代理人(Delegator)</code>，然后由代理人把工作分配给不同的 <code>工人(worker)</code>。</p>
<p>Delegator 负责接收来自客户端的任务并把任务下发，交给具体的 Worker 进行处理，Worker 处理完成后把结果返回给 Delegator，在 Delegator 接收到 Worker 处理的结果后对其进行汇总，然后交给客户端。</p>
<p><strong>优点</strong>：</p>
<p>将一个任务拆分成多个小任务，并发执行，Delegator 在接受到 Worker 的处理结果后就会返回给 Client，整个 Worker -&gt; Delegator -&gt; Client 的过程是<code>异步</code>的。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>共享状态会变得很复杂</li>
<li>无状态的 worker（worker 必须在每次操作共享状态时重新读取）</li>
<li>作业顺序是不确定的</li>
</ol>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p><strong>流水线并发模型：</strong>像是工厂中装配线中的 worker，每个 worker 只完成全部工作的一部分，完成一部分后，worker 会将工作转发给下一个 worker。</p>
<p>每道程序都在自己的线程中运行，彼此之间不会共享状态，这种模型也被称为无共享并发模型。</p>
<p>使用流水线并发模型通常被设计为<code>非阻塞I/O</code>，也就是说，当没有给 worker 分配任务时，worker 会做其他工作。非阻塞I/O 意味着当 worker 开始 I/O 操作，例如从网络中读取文件，worker 不会等待 I/O 调用完成。因为 I/O 操作很慢，所以等待 I/O 非常耗费时间。在等待 I/O 的同时，CPU 可以做其他事情，I/O 操作完成后的结果将传递给下一个 worker。</p>
<p>使用流水线模型的系统有时也被称为 <code>响应式</code> 或者 <code>事件驱动系统</code>，这种模型会根据外部的事件作出响应，事件可能是某个 HTTP 请求或者某个文件完成加载到内存中。</p>
<h4 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h4><p>一个参与者<code>Actor</code>对接收到的消息做出响应，然后可以创建出更多的 Actor 或发送更多的消息，同时准备接收下一条消息。</p>
<h4 id="Channels-模型"><a href="#Channels-模型" class="headerlink" title="Channels 模型"></a>Channels 模型</h4><p>在 Channel 模型中，worker 通常不会直接通信，与此相对的，他们通常将事件发送到不同的 <code>通道(Channel)</code>上，然后其他 worker 可以在这些通道上获取消息；</p>
<p>有的时候 worker 不需要明确知道接下来的 worker 是谁，他们只需要将数据写入通道中，监听 Channel 的 worker 可以订阅或者取消订阅，这种方式<strong>降低</strong>了 worker 和 worker 之间的<strong>耦合性</strong>。（worker完成任务后回调channels（<strong>阿里云发送日志接口采用回调方式</strong>））</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol>
<li>worker间不存在共享状态</li>
<li>单个worker有状态（无需再获取数据，执行更快）</li>
<li>更好的硬件整合：有状态的 worker 通常在 CPU 中缓存数据，这样可以更快地访问缓存的数据。</li>
</ol>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>worker分散</li>
<li>编写困难：设计嵌套回调</li>
</ol>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>可以对流水线并发模型中的任务进行排序，一般用来日志的写入和恢复。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol>
<li>有状态：单个个体有状态</li>
<li>共享状态：多个个体共享数据</li>
</ol>
<h2 id="函数性并行"><a href="#函数性并行" class="headerlink" title="函数性并行"></a>函数性并行</h2><p>使用函数调用来实现</p>
<p>消息的传递就相当于是函数的调用。传递给函数的参数都会被拷贝，因此在函数之外的任何实体都无法操纵函数内的数据。这使得函数执行类似于<code>原子</code>操作。每个函数调用都可以独立于任何其他函数调用执行。</p>
<p>当每个函数调用独立执行时，每个函数都可以在单独的 CPU 上执行。这也就是说，函数式并行并行相当于是各个 CPU 单独执行各自的任务。</p>
<p>stream </p>
<h2 id="创建并启动线程"><a href="#创建并启动线程" class="headerlink" title="创建并启动线程"></a>创建并启动线程</h2><ol>
<li><strong>thread.join()<strong>：等待线程</strong>thread</strong>执行完毕<ol>
<li>导致当前运行的线程停止执行，直到它加入的线程<strong>thread</strong>完成其任务。</li>
</ol>
</li>
<li>继承Thread &amp; 实现 Runnable<ol>
<li>使用继承方式创建线程的优势：编写比较简单；可以使用 <code>this</code> 关键字直接指向当前线程，而无需使用 <code>Thread.currentThread()</code> 来获取当前线程。</li>
</ol>
</li>
<li>Callable 有返回值的线程 &amp; Runnable<ol>
<li>Callable（重写）的方法是 call 方法，而 Runnable（重写）的方法是 run 方法。</li>
<li>call 方法可以抛出异常，而 Runnable 方法不能抛出异常</li>
</ol>
</li>
<li><code>顶级接口 </code>Executor<ol>
<li> Executor 在客户端和任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor 允许你管理<code>异步</code>任务的执行，而无须显示地管理线程的生命周期。</li>
<li>线程池好处：<ol>
<li>复用线程、控制最大并发数</li>
<li>实现任务线程队列缓存策略和拒绝机制？ （CachedThreadPool）</li>
<li>实现某些与时间相关的功能，如定时执行、周期执行等。</li>
<li>隔离线程环境。（开启不同的线程池）</li>
</ol>
</li>
<li><code>ExecutorService</code> 是 Executor 的默认实现，也是 Executor 的扩展接口，ThreadPoolExecutor 类提供了线程池的扩展实现<ol>
<li><code>CachedThreadPool</code> 会为每个任务都创建一个线程</li>
<li>FixedThreadPool 使你可以使用有限的线程集来启动多线程 （固定线程数量）</li>
<li>SingleThreadExecutor 就是线程数量为 1 的 FixedThreadPool<ol>
<li>SingleThreadPool 会序列化所有提交给他的任务，并会维护它自己(隐藏)的悬挂队列。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>后台/守护线程</strong>（daemon 英 [ˈdiːmən）：若无非守护线程执行，所有守护线程将终止执行</li>
<li>线程异常捕获：<ol>
<li>Thread.UncaughtExceptionHandler，允许你在每个 Thread 上都附着一个异常处理器。</li>
<li>Thread.UncaughtExceptionHandler.uncaughtException() 会在线程因未捕获临近死亡时被调用。</li>
</ol>
</li>
</ol>
<h3 id="线程执行控制"><a href="#线程执行控制" class="headerlink" title="线程执行控制"></a>线程执行控制</h3><ol>
<li>sleep 线程休眠 TimeUnit.sleep()</li>
<li>线程优先级：可以通过设置线程的优先级状态，告诉线程调度器哪个线程的执行优先级比较高（Thread.MAX_PRIORITY）</li>
<li>作出让步-Thread.yield()：建议执行切换CPU，而不是强制执行CPU切换。</li>
<li>后台线程：<code>后台(daemon) </code>线程，是指运行时在后台提供的一种服务线程，这种线程不是属于必须的。当所有非后台线程结束时，程序也就停止了，<strong>同时会终止所有的后台线程。</strong></li>
<li>加入一个线程：一个线程可以在其他线程上调用 <code>join()</code> 方法，其效果是等待一段时间直到第二个线程结束才正常执行。如果某个线程在另一个线程 t 上调用 t.join() 方法，此线程将被挂起，直到目标线程 t 结束才回复(可以用 t.isAlive() 返回为真假判断)。<ol>
<li>对 join 的调用也可以被中断，做法是在线程上调用 <code>interrupted</code> 方法，这时需要用到 try…catch 子句</li>
</ol>
</li>
<li>线程异常捕获： Thread.UncaughtExceptionHandler</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>Wait、Sleep和Yield方法的区别：（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/25e959037eed%EF%BC%89">https://www.jianshu.com/p/25e959037eed）</a><ol>
<li>wait()和sleep()<ol>
<li>wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。</li>
<li>当一个线程调用wait()方法的时候，会释放它锁持有的对象的<strong>管程</strong>和锁，但是调用sleep()方法的时候，不会释放他所持有的**管程(Monitor)**。</li>
<li>wait方法应在同步代码块中调用，但是sleep方法不需要。</li>
<li>使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首<strong>先获得锁（译者注：阻塞态），然后再进入就绪态</strong>。</li>
<li>wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程。</li>
</ol>
</li>
<li>sleep()和yield()：<ol>
<li>yield() 仅释放线程所占有的CPU资源，从而让其他线程有机会运行</li>
<li>sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的</li>
<li>如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。</li>
<li>执行了yield方法的线程什么时候会继续运行由线程调度器来决定</li>
</ol>
</li>
</ol>
</li>
<li>有一个易错的地方，当调用t.sleep()的时候，会暂停线程t。这是不对的，因为Thread.sleep是一个静态方法，它会<strong>使当前线程而不是线程t</strong>进入休眠状态。</li>
<li>休眠的线程在唤醒之后不保证能获取到CPU，它会先进入就绪态，与其他线程竞争CPU。</li>
<li>sleep()放弃CPU执行权，休眠结束后进入就绪状态，等待再次获得CPU执行权；而wait()方法释放对象锁，要先获得锁，才能进入就绪态等待获得CPU执行权</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-JAVA%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-JAVA%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">JAVA容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T00:00:00+00:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>组成结构：数组和链表</p>
<p>存储算法：根据key值的hashcode经过取余算法定位其所在数组的位置，再根据key的equals方法匹配相同key值获取对应相应的对象。</p>
<p>案例：</p>
<p><strong>（1）hashmap存储</strong></p>
<p>存值规则：把Key的hashCode 与HashMap的容量 取余得出该Key存储在数组所在位置的下标<strong>（源码定位Key存储在数组的哪个位置是以hashCode &amp; (HashMap容量-1)算法得出）</strong>这里为方便理解使用此方式；</p>
<p>//为了演示方便定义一个容量大小为3的hashMap（其默认为16）</p>
<p>HashMap map=newHashMap(3);</p>
<p>map.put(“a”,1); 得到key 为“a” 的hashcode 值为97然后根据 该值和hashMap 容量取余97%3得到存储位到数组下标为1;</p>
<p>map.put(“b”,2); 得到key 为“b” 的hashcode 值为98,98%3到存储位到数组下标为2;</p>
<p>map.put(“c”,3); 得到key 为“c” 的hashcode 值为99，99%3到存储位到数组下标为0;</p>
<p>map.put(“d”,4); 得到key 为“d” 的hashcode 值为100，100%3到存储位到数组下标为1;</p>
<p>map.put(“e”,5); 得到key 为“e” 的hashcode 值为101，101%3到存储位到数组下标为2;</p>
<p>map.put(“f”,6); 得到key 为“f” 的hashcode 值为102，102%3到存储位到数组下标为0;</p>
<p><img src="https://pic4.zhimg.com/80/v2-fceb57a8de2759203613d5bd343dc37d_1440w.jpg" alt="img"></p>
<p><strong>（2）hashmap的查找key</strong></p>
<p>得到key在数组中的位置：根据上图，当我们获取key 为“a”的对象时，那么我们首先获得 key的hashcode97%3得到存储位到数组下标为1;</p>
<p>匹配得到对应key值对象：得到数组下表为1的数据“a”和“c”对象， 然后再根据 key.equals()来匹配获取对应key的数据对象；</p>
<p>hashcode 对于HashMapde:如果没有hashcode 就意味着HashMap存储的时候是没有规律可寻的，那么每当我们map.get()方法的时候，就要把map里面的对象一一拿出来进行equals匹配，这样效率是不是会超级慢；</p>
<h2 id="5、hashcode方法文档说明"><a href="#5、hashcode方法文档说明" class="headerlink" title="5、hashcode方法文档说明"></a><strong>5、hashcode方法文档说明</strong></h2><p>在equals方法没被修改的前提下，多次调用同一对象的hashcode方法返回的值必须是相同的整数；</p>
<p>如果两个对象互相equals，那么这两个对象的hashcode值必须相等；</p>
<p>为不同对象生成不同的hashcode可以提升哈希表的性能；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-equals&hashcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-equals&hashcode/" class="post-title-link" itemprop="url">equals&hashcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T00:00:00+00:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="默认的equals与hashcode"><a href="#默认的equals与hashcode" class="headerlink" title="默认的equals与hashcode"></a>默认的equals与hashcode</h1><ol>
<li>equals：判断两个对象的引用指向的是不是同一个对象</li>
<li>hashcode：根据对象地址生成一个整数数值；</li>
</ol>
<h2 id="重写场景"><a href="#重写场景" class="headerlink" title="重写场景"></a>重写场景</h2><p>需求：若对象间特定的几个属性值相等，则判定对象相等</p>
<p>问题：默认的equals和hashcode判定的是对象的引用，两个new出来的对象引用一定不同</p>
<p>解决方案：重写equals方法和hashcode方法</p>
<p>只重写equals方法的话会出现对象equals相等但是hashcode不等的情况（hashcode默认判断引用地址），放到hashSet中也有存在两个对象。</p>
<p>HashMap 则是先根据Key值的hashcode分配和获取对象保存数组下标的，然后再根据equals区分唯一值。也存在一样的问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么重写equals时必须重写hashCode方法？</p>
<p>前提：</p>
<p><strong>如果两个对象相等，则hashcode一定也是相同的；</strong><br><strong>两个对象相等,对两个对象分别调用equals方法都返回true；</strong></p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的；（如HashMap）</p>
<p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；<br>hashCode() 的<strong>默认行为是对堆上的对象产生独特值</strong>。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）；</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903854639693837#heading-3">https://juejin.im/post/6844903854639693837#heading-3</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuye Huang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T00:00:00+00:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 05:40:05" itemprop="dateModified" datetime="2021-05-15T05:40:05+00:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">知识库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">基础知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在不使用反射时，构造对象使用 new 方式实现，这种方式在<strong>编译期</strong>就可以把对象的类型确定下来。</p>
<p>使用反射后，在程序<strong>运行过程</strong>中<strong>动态</strong>获取类信息和调用类方法。</p>
<p>反射的<strong>思想</strong>：<strong>在程序运行过程中确定和解析数据类的类型。</strong></p>
<p>反射的<strong>作用</strong>：对于在<code>编译期</code>无法确定使用哪个数据类的场景，通过<code>反射</code>可以在程序运行时<strong>构造出不同的数据类实例</strong>。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6864324335654404104">https://juejin.im/post/6864324335654404104</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuye Huang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huangyuye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huangyuye" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:747776824@qq.com" title="E-Mail → mailto:747776824@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/huangyuye/qzf3af" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;huangyuye&#x2F;qzf3af" rel="noopener" target="_blank">语雀</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuye Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
