# Redis读写策略

Redis读写策略因为什么被提出：

缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。那么如何保证缓存和数据库数据的一致性呢？



## 3种常用的缓存读写策略

- Cache Aside Pattern（旁路缓存模式）
  - 为了尽可能地解决缓存与数据库的数据不一致问题
    - 读写流程
      - 读的时候，先读缓存，缓存命中的话，直接返回数据；缓存没有命中的话，就去读数据库，从数据库中取出数据，放入缓存后，同时返回响应；（**由客户端操作缓存和数据库**）
      - 写更新的时候，先更新数据库，然后再删除缓存。
- Read/Write Through Pattern（读写穿透）
  - 服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。
    - 读的时候，从缓存中读取数据，读到直接返回cache hit；如果读取不到的话，抽象缓存层会从数据库中加载，写入缓存后，返回cache miss；
    - 写更新的时候，也是由**缓存抽象层**完成数据源和缓存数据的更新（先缓存->后数据库）
- Write Behind Pattern（异步缓存写入）
  - Write-behind跟Read-Through/Write-Through有很多相似的地方，都是由Cache Provider来负责缓存和数据库的读写。它们又有个很大的不同：Read/Write-Through是同步更新缓存和数据的，Write-Behind则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。
  - 这种方式下，缓存和数据库的一致性不强，**对一致性要求高的系统要谨慎使用。**（但是它适合频繁写的场景，MySQL的**Innodb Buffer Pool机制**就是用到这种模式。）



## **Cache Aside Pattern 的缺陷**

https://www.jb51.net/article/215974.htm

### 缺陷1：首次请求数据一定不在 cache 的问题

- 将热点数据可以提前放入cache

### 缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。

- 可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache（**并发问题可能导致update的数据是旧数据**），但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。
- 数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。



## 操作缓存的时候，到底是删除缓存呢，还是更新缓存？

更新缓存可能存在的问题：

线程A先发起一个写操作，第一步先更新数据库；线程B先发起一个写操作，第二步后更新数据库；但是由于网络等原因，线程B先更新了缓存；线程A更新缓存；

更新缓存额缺陷

- 如果你写入的缓存值，是经过复杂计算才得到的话，更新缓存频率高的话，就浪费性能了；
- 在写数据库场景多、读数据场景少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能



## 双写的情况下，先操作数据库还是先操作缓存呢？

线程A发起一个写操作，第一步del cache；此时线程B发起一个读操作，cache miss；线程B继续读DB，读出来一个老数据，此时线程B把老数据设置入cache；线程A写入DB更新数据；

这里就存在这样的一个问题了：**缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据。** 因此，Cache-Aside缓存模式，选择了先操作数据库而不是先操作缓存。



## 几种方案保证数据库与缓存的一致性？

1. 缓存延时双删

   1. 先删除缓存；再更新数据库；再休眠一会(比如1秒)，再次删除缓存；

   2. > 休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒。 为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据；
      >
      > 只有休眠那一会（比如就那1秒），可能有脏数据，一般业务也会接受的。但是如果**第二次删除缓存失败**呢？缓存和数据库的数据还是可能不一致，对吧？给Key设置一个自然的expire过期时间，让它自动过期怎样？那业务要接受**过期时间**内，数据的不一致咯？还是有其他更佳方案吗？

2. 删除缓存重试机制

   1. 写请求更新数据库；缓存因为某些原因，删除失败；把删除失败的key放到消息队列；
   2. 消费消息队列的消息，获取要删除的key；重试删除缓存操作；

3. 读取binlog异步删除缓存



## TODO

Redis 布隆过滤器使用场景，实际怎么用？过滤器和缓存数据怎么保持一致

怎么实现缓存预热？

雪花数起始值使用随机数，解决分表问时全到0序号表的问题；考虑闰秒重复时间点



## 参考

- [3种常用的缓存读写策略](https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/database/redis/3-commonly-used-cache-read-and-write-strategies.md)
- [聊一聊Redis与MySQL双写一致性如何保证](https://www.jb51.net/article/215974.htm)
- [常见缓存架构 -- 穿透型缓存与旁路型缓存](https://techlog.cn/article/list/10183227)