## 基础

- 基础接口
  - RandomAccess接口
    - 数组天然支持快速随机访问，RandomAccess接口只是用于标识容器可快速访问以切换不同的遍历方法
  - NavigableMap 接口：
    - 提供对集合内元素的搜索的能力
- 对象比较
  - `java.lang.Comparable` ：compareTo(Object obj) 声明自身与其他对象的比较逻辑
  -  `java.util.Comparator`：compare(Object o1, Object o2) 比较器，用于定制两个对象比较的逻辑
- 容器之间对比方面（如比较ArrayList和LinkedList）
  - 底层数据结构（数组vs链表）
  - 操作的时间复杂度（增删查）
  - 内存空间占用/容量
  - 是否支持随机访问（数组vs非数组）
  - 线程安全（底层同步锁）
  - 效率
- LinkedList 底层结构
  - jdk1.7优化：
    - jdk1.6需要初始化header Entry对象，浪费空间
- **`hashCode()`与 `equals()` 的相关规定：**
  1. 如果两个对象相等，则 `hashcode` 一定也是相同的
  2. 两个对象相等,对两个 `equals()` 方法返回 true
  3. 两个对象有相同的 `hashcode` 值，它们也不一定是相等的
  4. 综上，`equals()` 方法被覆盖过，则 `hashCode()` 方法也必须被覆盖
  5. `hashCode() `的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

- HashMap的底层实现

  - jdk1.8之前
    - 底层数据结构：数组+链表
    - (n-1) & hash判断当前元素存放位置（n为数组长度）
    - 判断相同位置元素的hash值和key值是否相同，相同则覆盖；不相同则通过拉链法解决冲突
      - 所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
  - jdk1.8之后
    - 当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。
    - 红黑树是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。（**哪些情况？？**）

- HashMap的容量是 2 的幂次方

  - 扩容机制：

  - [HashMap的容量为什么是2的幂次方？](https://blog.csdn.net/LLF_1241352445/article/details/81321991)

    - 对象计算的hash值，范围值很大，不能直接用作数组下标，所以需要将hash值对数组长度n做取模操作后得到余数作为数组下标，而取模运算为：`(n - 1) & hash`（**那为什么取模不是用的%符号呢**）

    1. 选用该算法是因为使用位运算是特别高效的运算
       1. 取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。

    2. 基于条件1，当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，这样可以使得不同的hash值，和(n-1)进行位运算后，能够得出不同的值（1&1=1，**1&0=0，0&0=0**）。可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！
       1. 如果hash table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)

  - [多线程操作死循环问题](https://coolshell.cn/articles/9606.html) 

    - 1.8之前，并发下的 Rehash 会造成元素之间会形成一个循环链表

      - 1.8之前，hash桶的链表节点使用的是**`头插法`**插入到链表中

        ```java
        void addEntry(int hash, K key, V value, int bucketIndex)
        {
            Entry<K,V> e = table[bucketIndex];
            table[bucketIndex] = new Entry<K,V>(hash, key, value, e);
            //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize
            if (size++ >= threshold)
                resize(2 * table.length);
        } 
        ```

      - 新旧数组链表元素迁移：

        - 假设旧数组中某元素指向的链表节点为：node1-node2-node3，则迁移到新数组中链表节点的变化情况为：（假设数组容量为4）
          - 第一次loop迁移：node1
          - 第二次loop迁移：node2-node1
          - 第三次loop迁移：node3-node2-node1
    
          ![微信图片_20210425174828](C:\Users\yuye.huang\Desktop\微信图片_20210425174828.jpg)
      
      - Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。

## TODO

1. 红黑树和二叉查找树的对比：

