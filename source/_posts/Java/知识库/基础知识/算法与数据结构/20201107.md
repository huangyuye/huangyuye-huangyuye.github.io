---
categories:
  - Java
  - 知识库
  - Java
  - 算法与数据结构
---
# 算法与数据结构



## 算法与数据结构常见问题场景

1. 字符串匹配
   1. 暴力匹配（回溯匹配，回溯次数多，速度慢）
   2. KMP算法（ -> 建立部分匹配表）
2. 汉诺塔问题（大方块不能在小方块下面）
3. 八皇后问题：92种算法
4. 马踏棋盘算法（骑士周游算法）



##  数据结构和算法的关系

数据结构是**研究组织数据方式**的学科

数据结构是算法的基础

**数据结构包括：线性结构/非线性结构**



### 线性结构

1. 数据元素之间存在一对一线性关系
2. 两种不同的存储结构：**顺序存储结构&链式存储和结构** (数组&链表)——元素节点中存放数据元素及相邻元素的地址信息不连续
3. 常见的线性结构有：数组、队列、链表和栈



### 非线性结构

1. 数组元素之间不是一对一的线性关系
2. 场景的非线性结构：多维数组、广义表、树结构、图结构





## 数据结构

### 稀疏数组（sparse array）

**场景：**

编写五子棋程序，且有存盘和续上盘的功能；

**问题：**

使用二维数组记录棋盘，存在很多值为0的元素



**稀疏数组介绍：**

当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来表示

**使用稀疏数组的处理方法：**

1、第一行记录一共有几行几列，有多少个不同得值

2、把具有不同值得行列及值记录在一个小规模得数组中，从而缩小程序的规模



### 队列

队列是一个有序列表，可以用数组或链表来实现

遵循先进先出的原则

**使用数组模拟队列：**

保存两个变量-front & rear （头尾的下标）；maxSize为数组容量，若rear=maxSize-1则队列满（front和rear从-1/0开始）（front：指向队列头的前一个位置；rear指向队列尾最后一个位置）; front=rear则队列为空



**问题：**

单向队列：数组使用一次就不能用，没有达到复用效果



**解决方案：**改为环形队列

**环形队列调整思路：**

1. front指向队列的第一个元素；front初始值为0

2. rear指向队列的最后一个元素的后一个位置；rear初始值为0
3. 判断队列满的条件为：(rear+1)%maxSize=front
4. 队列中有效的数据个数：(rear + maxSize - front) % maxSize  （为什么要+maxSize？因为是环形队列，rear的下标有可能小于front的下标，这里是为了避免为负数）



### 链表

链表是有序的列表，内存不一定连续；每个节点包含data域，next域

可区分为有头节点或无头节点的链表



**链表排序**

新增节点时进行排序：遍历链表，找到新添加节点的位置（**遍历，比较节点的值，直到遍历节点的值大于待插入节点的值**），将新节点的next指向插入位置的节点的next，将插入位置的节点的next指向新节点。



**遍历链表节点逻辑**

使用辅助变量，从head节点开始，通过next指向遍历



**排序和限制重复的思考**

1. 若要支持排序，则定义比较大小的规则，如实现comparable接口重写compare方法
2. 若要支持更新或者唯一限制，则要定义节点判断唯一的规则，如重写equals方法(以及hashcode())



**链表反转**

1. 创建一个新的头节点 newHead
2. 遍历原链表,
   1. temp辅助变量记录newHead.next
   2. 每次遍历都将 newHead指向遍历的节点node，遍历的节点node.next指向原先newHead的next，即temp（可使用辅助变量）

其他方案：可以使用临时数组  



**链表逆序打印**

实现思路1：利用栈**先进后出**特性



**栈**

栈的底层实现是数组，父类是Vector矢量类



**应用场景**

**单向环形链表**——约瑟夫环问题（丢手帕）

单向环形链表：最后一个节点的next指向头节点

丢手帕报数过程：head和tail指针同时移动，报数出队时，head节点修改，且tail节点的next指针指向新的head节点。

```java
// ... 其他参数校验
// 遍历
while (true) {
    if (tail == head) {
    	break;
	}
	for (int i=0; i<m-1; i++) {
		tail = tail.next;
		first = first.next;
	}
	sout(first);
	first=first.next;
	tail.next=first;
}
```



### 栈

栈是一个先进后出的有序列表(FILO first in last out)

栈是限制线性表中元素的插入和删除只能在线性表的同一端进行操作的一种特殊线性表。允许插入和删除的一端为变化端，即栈顶。另一端为栈底。



**应用场景**

- 子程序的调用
- 处理递归调用
- 表达式的转换[中缀表达式转后缀表达式]与求值
- 二叉树的遍历
- 图形的深度优先搜索法



**需求场景**

前端输入一个表达式，编写一个函数进行计算：String str = 7*2

栈的应用场景、实现原理、**实现计算器**



**实现计算器**

两个栈，一个存放数，一个存放操作符，遍历字符时若当前字符是操作符，则判断优先级是否小于或等于操作符栈的上一个操作符，是的话则从数栈pop出两个数，从操作符栈pop出一个符号进行计算，然后将当前的符号入符号栈；否则直接入符号栈（中缀表达式）



### 前缀&中缀&后缀表达式

前缀表达式：运算符位于操作符之前



### 双向链表

双向链表同时记录了头尾节点，且每个节点增加prev上一节点引用指针



## 算法



### 算法-递归

应用场景：阶乘、迷宫问题（回溯）、八皇后问题



### 算法-排序

将一组数组，依据指定顺序进行排列的过程

**排序的分类**

- 内部排序（使用内部存储进行排序）

- 外部排序（数据量大时使用外部存储进行排序）

**内部排序分为**

- 插入排序
  - **直接插入排序**
  - 希尔排序
- 选择排序
  - **简单排序**
  - 堆排序
- 交换排序
  - **冒泡排序**
  - 快速排序
- 归并排序
- 基数排序（桶排序的升级）

**度量程序、算法执行时间的两种方法**

- 事后统计法（需要实际运行；依赖于软硬件等环境因素）
- 事前估算法：通过分析某算法的**时间复杂度**来判断



#### 时间复杂度

**时间频度** T(n)：一个算法

