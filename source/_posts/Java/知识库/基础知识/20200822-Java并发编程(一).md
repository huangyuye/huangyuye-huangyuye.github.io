---
categories:
  - Java
  - 知识库
  - Java
---
## 概念

### 线程&进程

**进程：**是程序的一次执行过程，是系统运行程序的基本单位

**线程：**比进程更小的执行单位，一个进程的执行过程中会产生多个线程。



**不同点：**

1. 进程之间是完全独立的；多个线程共享进程的**堆**和**方法区**资源(线程间可能会相互影响)，但是每个线程有独立的程序计数器、虚拟机栈、本地方法栈。
2. 线程间切换工作上下文时资源消耗比进程小（被称为轻量级线程）
   1. 线程执行开销小，但不利于资源的管理和保护



**问题**：

程序计数器、虚拟机栈、本地方法栈为什么是私有的？

首先先来了解**程序计数器**的作用—记住程序线程的运行位置：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环
2. 多线程情况下，程序计数器用于记录当前线程执行位置，从而使得当线程被切换回来时能够知道该线程上次运行到哪里了。

总结：所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。



**虚拟机栈(Java方法)：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。



**堆**和**方法区**是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



### 为什么要使用多线程

1. 线程间的切换和调度的成本远小于进程
2. 充分利用多核CPU同时运行多个线程，提高系统并发能力和性能



单核CPU时代：提高CPU和IO设备的综合利用率

多核CPU时代：提高CPU利用率



#### 多线程可能带来的问题

1. 内存泄漏
2. 死锁
3. 线程不安全等



### 线程的生命周期和状态

1. NEW
2. RUNNABLE
3. BLOCKED
4. WAITING、TIME_WATING
5. TERMINATED



#### 状态切换

线程创建之后它将处于 **NEW（新建）** 状态，

调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。

可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

`操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态。所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。`

当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，

而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。

当超时时间到达后 Java 线程将会返回到 **RUNNABLE** 状态。

当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。

线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。



### 关于线程上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而**一个 CPU 核心在任意时刻只能被一个线程使用**，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。



### 关于start()和run()

**调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**



### sleep() 方法和 wait() 方法

两者最主要的区别在于：**sleep 方法没有释放锁，而 wait 方法释放了锁** 。



### 线程死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。



死锁产生的四个必要条件：

1. 互斥条件
2. 请求与保持条件
3. 不剥夺条件
4. 循环等待条件

通俗来讲，多个线程都在争夺相同的N个资源（**均只有一份，互斥**），等待缺少的资源时不丢掉本身已获取到的资源(**请求与保持**)，且不能抢夺别的线程占用的资源(**不剥夺**)，但是问题是想要正常运行，这些线程都需要别的线程已获取到的资源（**循环等待**）。

如每个线程都在同时执行“拼凑拼图”的任务，但拼图却只有一份(**互斥**)。或者说多个分别捡到不同星数的龙珠的人都想要召唤神龙。