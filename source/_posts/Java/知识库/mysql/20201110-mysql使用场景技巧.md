1. MySQL组内排序问题：分组查询每组的前n条记录（需要按某个字段分组，且每组只能取一条记录；按某个字段倒序。）
   1. 解决方案
      1. 子查询：先全表排序作为子查询，然后分组
         1. select * from (select * from table2 order by age desc) as a group by a.table1_id
         2. select a.* from table2 as a where age = (select max(age) from table2 where a.table1_id=table1_id)
         3. select a.* from table2 as a where not exists (select * from table2 where table1_id=a.table1_id and age>a.age)
         4. select a.* from table2 as a where exists (select count(*) from table2 where table1_id=a.table1_id and age>a.age having count(*)=0)
      2.  group_concat(id order bydatedesc) + SUBSTRING_INDEX
         1. SELECT * FROM `test` WHERE id IN(SELECT SUBSTRING_INDEX(GROUP_CONCAT(id ORDER BY `date` DESC)
      3. 关于exists的解释：只要exists引导的子句有结果集返回，则表示连接条件为真
         1. https://zhuanlan.zhihu.com/p/20005249

2. 删除重复数据
   
   1. delete from sg_guide_shop where id in (select id from sg_guide_shop group by guide_id,shop_id having count(id) > 1) and id not in (select min(id) from sg_guide_shop group by guide_id,shop_id  having count(id)>1);
   
3. 将数据表字段修改为utf8mb4 及将数据表编码改为utf8mb4

   ```sql
   ALTER TABLE sg_login_log MODIFY COLUMN operate_name VARCHAR(70) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT "操作人";
   
   ALTER TABLE sg_login_log CONVERT TO CHARACTER SET utf8mb4;
   ```

4. mysql 统计各日期的业务数据，没有数据的日期补零

   ```sql
   # 1. 生成辅助表，生成N条记录，每条记录用于辅助生成1天的数据
   drop table if  exists sg_base_datetime_help;
   CREATE TABLE `sg_base_datetime_help` (
       `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
       `temp` tinyint(4) default null COMMENT '临时字段，生成数据后删除',
       PRIMARY KEY (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='日期辅助表，用于生成n条数据';
   # 先生成一条数据
   insert into sg_base_datetime_help(temp) select now() from dual;
   # 下面两条语句执行N次, 生成4k-1w条数据(4096即可)
   insert into sg_base_datetime_help(temp) select now() from sg_base_datetime_help;
   select count(1) from sg_base_datetime_help;
   # 删除临时字段
   alter table sg_base_datetime_help drop column temp;
   
   2. 使用辅助表作为左关联主表，主表sql
   SELECT
   	@cdate := DATE_FORMAT(date_add( @cdate, INTERVAL - 1 DAY ), '%Y-%m-%d') as date
   FROM
   	(SELECT @cdate := date_add(#{endTime}, interval + 1 day) FROM sg_base_datetime_help) tmp1 WHERE @cdate >#{startTime};
   ```

   

