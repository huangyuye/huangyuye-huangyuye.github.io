<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>歪歪的小站</title>
  
  <subtitle>Coder.YY</subtitle>
  <link href="https://huangyuye.github.io/atom.xml" rel="self"/>
  
  <link href="https://huangyuye.github.io/"/>
  <updated>2021-05-24T12:55:11.600Z</updated>
  <id>https://huangyuye.github.io/</id>
  
  <author>
    <name>yy.huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E5%9F%BA%E7%A1%80/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/java-collection-hierarchy.png" alt="img"></p><p><a href="https://www.javatpoint.com/collections-in-java">https://www.javatpoint.com/collections-in-java</a></p><ul><li><strong>Queue</strong> [kju]<ul><li>增删查<ul><li>添加（add/offer）：容量超过限制，返回false还是抛异常——抛异常处理更加耗时，offer直接返回false的方式更好</li><li>删除（remove/poll）：空队列，remove抛异常，poll返回null</li><li>查看（element/peek）：空队列，element抛异常，peek返回null</li></ul></li><li><strong>Deque</strong>（double-ended queue，双端队列）</li><li>实现<ul><li><code>PriorityQueue</code>  implements Queue</li><li><code>ArrayDequq</code> implements Deque</li><li><code>LinkedList</code> implements List, Deque</li></ul></li></ul></li><li><strong>Set</strong><ul><li><code>HashSet</code>：implements Set，且底层使用HashMap使用<ul><li><code>LinkedHashSet</code> extends HashSet implements Set ，底层是LinkedHashMap，能够按照添加的顺序遍历；</li></ul></li><li><code>TreeSet</code> implements NavigableSet（SortedSet）<ul><li>底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</li></ul></li></ul></li><li><strong>List</strong><ul><li>ArrayList</li><li><code>LinkedList</code> implements List, Deque，支持双端操作的线性表<ul><li>双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li><li>Vector 和 Stack 已过时</li></ul></li></ul></li><li><strong>Map</strong><ul><li>HashMap：JDK1.8之后使用了数组+链表+红黑树<ul><li>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li></ul></li><li>LinkedHashMap：在HashMap底层结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li><li>Hashtable： 数组+链表组成（拉链法解决哈希冲突）已过期</li><li><strong><code>TreeMap</code></strong> implements NavigableMap&lt;K,V&gt;（SortedMap） ：红黑树（自平衡的排序二叉树）</li></ul></li></ul><p><strong>为什么要使用集合？替代数组，提高了数组存储的灵活性</strong>：不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p><p><strong>如何选用集合？</strong></p><ul><li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="集合之List"><a href="#集合之List" class="headerlink" title="集合之List"></a>集合之List</h3><h3 id="集合之Set"><a href="#集合之Set" class="headerlink" title="集合之Set"></a>集合之Set</h3><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h3 id="Collections工具使用"><a href="#Collections工具使用" class="headerlink" title="Collections工具使用"></a>Collections工具使用</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure><h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></span><br></pre></td></tr></table></figure><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4><p>不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="容器之间对比方面（如比较ArrayList和LinkedList）"><a href="#容器之间对比方面（如比较ArrayList和LinkedList）" class="headerlink" title="容器之间对比方面（如比较ArrayList和LinkedList）"></a>容器之间对比方面（如比较ArrayList和LinkedList）</h3><ul><li>底层数据结构（数组vs链表）</li><li>操作的时间复杂度（增删查）</li><li>内存空间占用/容量</li><li>是否支持随机访问（数组vs非数组）</li><li>线程安全（底层同步锁）</li><li>效率</li></ul><p>内存空间占用：如ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><h3 id="ArrayList的容量"><a href="#ArrayList的容量" class="headerlink" title="ArrayList的容量"></a><strong>ArrayList的容量</strong></h3><h4 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">    * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">    * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">    * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p><h4 id="扩容倍数"><a href="#扩容倍数" class="headerlink" title="扩容倍数"></a>扩容倍数</h4><p>扩容时会指定目标容量，优先将新容量更新为旧容量的1.5倍；若容量还是不够，则取扩容目标容量minCapacity</p><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>ArrayList没有负载因子</p><h3 id="idea-查看UML类图"><a href="#idea-查看UML类图" class="headerlink" title="idea 查看UML类图"></a>idea 查看UML类图</h3><p>右键类 -&gt; Diagrams -&gt; show diagram 查看UML类图</p><h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><ul><li><code>java.lang.Comparable</code> ：compareTo(Object obj) 声明<strong>自身与其他</strong>对象的比较逻辑</li><li> <code>java.util.Comparator</code>：compare(Object o1, Object o2) 比较器，用于定制相同类型的<strong>任意两个</strong>对象比较的逻辑</li></ul><h3 id="LinkedList-底层结构"><a href="#LinkedList-底层结构" class="headerlink" title="LinkedList 底层结构"></a>LinkedList 底层结构</h3><ul><li>jdk1.7优化：<ul><li>jdk1.6需要初始化header Entry对象，浪费空间</li></ul></li></ul><h3 id="hashCode-与-equals-的相关规定："><a href="#hashCode-与-equals-的相关规定：" class="headerlink" title="hashCode()与 equals() 的相关规定："></a><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></h3><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode() </code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><ul><li><p>jdk1.8之前</p><ul><li>底层数据结构：数组+链表</li><li><strong>putVal：</strong><code>头插法</code>插入链表表头</li></ul></li><li><p>jdk1.8之后</p><ul><li>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li><li>红黑树是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</li><li><strong>putVal：</strong><code>尾插法</code>插入链表表头</li></ul></li><li><p>putVal</p><ul><li>(n-1) &amp; hash判断当前元素存放位置（n为数组长度）</li><li>判断相同位置元素的hash值和key值是否相同，相同则覆盖；不相同则通过拉链法解决冲突<ul><li>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li></ul></li></ul></li><li><p><strong>HashMap的容量是 2 的幂次方</strong></p><ul><li><p>扩容机制：resize</p><ul><li>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</li></ul></li><li><p><a href="https://blog.csdn.net/LLF_1241352445/article/details/81321991">HashMap的容量为什么是2的幂次方？</a></p><ul><li>对象计算的hash值，范围值很大，不能直接用作数组下标，所以需要将hash值对数组长度n做取模操作后得到余数作为数组下标，而取模运算为：<code>(n - 1) &amp; hash</code>（<strong>那为什么取模不是用的%符号呢</strong>）</li></ul><ol><li><p>选用该算法是因为使用位运算是特别高效的运算</p><ol><li>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</li></ol></li><li><p>基于条件1，当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，这样可以使得不同的hash值，和(n-1)进行位运算后，能够得出不同的值（1&amp;1=1，<strong>1&amp;0=0，0&amp;0=0</strong>）。可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！</p><ol><li>如果hash table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)</li></ol></li></ol></li><li><p><a href="https://coolshell.cn/articles/9606.html">多线程操作死循环问题</a> </p><ul><li><p>1.8之前，并发下的 Rehash 会造成元素之间会形成一个循环链表</p><ul><li><p>1.8之前，hash桶的链表节点使用的是**<code>头插法</code>**插入到链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>新旧数组链表元素迁移：</p><ul><li><p>假设旧数组中某元素指向的链表节点为：node1-node2-node3，则迁移到新数组中链表节点的变化情况为：（假设数组容量为4）</p><ul><li>第一次loop迁移：node1</li><li>第二次loop迁移：node2-node1</li><li>第三次loop迁移：node3-node2-node1</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210425174828.jpg"></p></li></ul></li><li><p>Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。</p></li></ul></li></ul></li><li><p>HashMap的N种遍历方式：</p></li><li><p>负载因子loadFactor</p><ul><li>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，会导致查找元素效率低</li><li>太小导致数组的利用率低，存放的数据会很分散</li></ul></li><li><p>查询效率</p><ul><li>数组的查询效率为O(1)，链表的查询效率是O(n)，红黑树的查询效率是O(log n)，n为桶中的元素个数。</li><li>所以当位于链表中的结点过多，显然通过key值依次查找效率就太低了。因此JDK1.8在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为8）时，将链表转化为红黑树</strong>，以提高查询效率。</li></ul></li></ul></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul><li>JDK1.8之前<ul><li><strong><code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong><ul><li>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。</li></ul></li></ul></li><li>JDK1.8<ul><li>取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全</li><li><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</li></ul></li></ul><h3 id="数据元素插入"><a href="#数据元素插入" class="headerlink" title="数据元素插入"></a>数据元素插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">elementData[index] = element;</span><br></pre></td></tr></table></figure><h3 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h3><ul><li>RandomAccess接口<ul><li>数组天然支持快速随机访问，RandomAccess接口只是用于标识容器可快速访问以切换不同的遍历方法</li></ul></li><li>NavigableMap / NavigableSet 接口<ul><li>提供对集合内元素的搜索的能力</li></ul></li><li>Iterable接口</li><li>SortMap：对集合中的元素根据键排序的能力</li></ul><h3 id="无序性"><a href="#无序性" class="headerlink" title="无序性"></a>无序性</h3><p>什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>红黑树和二叉查找树的对比</li><li>HashMap resize 扩容方法实现</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md">docs/java/collection/Java集合框架常见面试题.md · SnailClimb/JavaGuide - Gitee.com</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h3 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="笔记" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="容器" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是序列化与反序列化？"><a href="#1、什么是序列化与反序列化？" class="headerlink" title="1、什么是序列化与反序列化？"></a><strong>1、什么是序列化与反序列化？</strong></h2><ul><li><p>序列化：指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输），这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程</p></li><li><p>反序列化：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p></li></ul><h2 id="2、为什么要做序列化？"><a href="#2、为什么要做序列化？" class="headerlink" title="2、为什么要做序列化？"></a><strong>2、为什么要做序列化？</strong></h2><ul><li><p>在分布式系统中，此时需要把对象在网络上传输，就得把对象数据转换为二进制形式，需要共享的数据的 JavaBean 对象，都得做序列化。</p></li><li><p>服务器钝化：如果服务器发现某些对象好久没活动了，那么服务器就会把这些内存中的对象持久化在本地磁盘文件中（Java对象转换为二进制文件）；如果服务器发现某些对象需要活动时，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成 Java 对象。这样能节省服务器内存。</p></li></ul><h2 id="3、Java-怎么进行序列化？"><a href="#3、Java-怎么进行序列化？" class="headerlink" title="3、Java 怎么进行序列化？"></a><strong>3、Java 怎么进行序列化？</strong></h2><ul><li><p>需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口（这是一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：String，Integer</p></li><li><p>底层会判断，如果当前对象是 Serializable 的实例，才允许做序列化，Java对象 <code>instanceof Serializable</code> 来判断。</p></li><li><p>在 Java 中使用对象流来完成序列化和反序列化</p></li></ul><p>　<strong>ObjectOutputStream</strong>：通过 writeObject()方法做序列化操作</p><p>　<strong>ObjectInputStream</strong>：通过 readObject() 方法做反序列化操作</p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/PhYVoF5wx8dElg4.png" alt="img"></p><h3 id="第一步：创建一个-JavaBean-对象"><a href="#第一步：创建一个-JavaBean-对象" class="headerlink" title="第一步：创建一个 JavaBean 对象"></a><strong>第一步：创建一个 JavaBean 对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：使用-ObjectOutputStream-对象实现序列化"><a href="#第二步：使用-ObjectOutputStream-对象实现序列化" class="headerlink" title="第二步：使用 ObjectOutputStream 对象实现序列化"></a><strong>第二步：使用 ObjectOutputStream 对象实现序列化</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在根目录下新建一个 io 的文件夹</span></span><br><span class="line">   OutputStream op = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;io&quot;</span>+File.separator+<span class="string">&quot;a.txt&quot;</span>); </span><br><span class="line">   ObjectOutputStream ops = <span class="keyword">new</span> ObjectOutputStream(op); </span><br><span class="line">   ops.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;vae&quot;</span>,<span class="number">1</span>));   </span><br><span class="line">ops.close();</span><br><span class="line"><span class="comment">// 我们打开 a.txt 文件，发现里面的内容乱码，注意这不需要我们来看懂，这是二进制文件，计算机能读懂就行了。</span></span><br></pre></td></tr></table></figure><p><strong>错误一：</strong>如果新建的 Person 对象没有实现 Serializable 接口，那么上面的操作会报错：</p><p><img src="D:\AppData\YoudaoNote\qqB53912A331D409871E525BE52BFB5C3B\c301f97fba5249a5b3f2e347f918bcb7\0-2013853053.png" alt="img"></p><h3 id="第三步：使用ObjectInputStream-对象实现反序列化"><a href="#第三步：使用ObjectInputStream-对象实现反序列化" class="headerlink" title="第三步：使用ObjectInputStream 对象实现反序列化"></a><strong>第三步：使用ObjectInputStream 对象实现反序列化</strong></h3><p><strong>反序列化的对象必须要提供该对象的字节码文件.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;io&quot;</span> + File.separator + <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">   ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">   <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">   Person p = (Person)os.readObject();</span><br><span class="line">   System.out.println(p);  <span class="comment">//Person [name=vae, age=1] os.close();</span></span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="如果某些数据不需要做序列化，比如密码，比如上面的年龄？"><a href="#如果某些数据不需要做序列化，比如密码，比如上面的年龄？" class="headerlink" title="如果某些数据不需要做序列化，比如密码，比如上面的年龄？"></a>如果某些数据不需要做序列化，比如密码，比如上面的年龄？</h3><p><strong>解决办法：</strong>在字段面前加上 transient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;<span class="comment">//需要序列化 </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//不需要序列化</span></span><br></pre></td></tr></table></figure><p>那么我们在反序列化的时候，打印出来的就是Person [name=vae, age=0]，整型数据默认值为 0 </p><h3 id="对象版本变化"><a href="#对象版本变化" class="headerlink" title="对象版本变化"></a>对象版本变化</h3><p><strong>在完成序列化操作后，由于项目的升级或修改，可能我们会对序列化对象进行修改，比如增加某个字段，那么我们在进行反序列化就会报错：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/28-918255453.png" alt="img"></p><p><img src="D:\AppData\YoudaoNote\qqB53912A331D409871E525BE52BFB5C3B\8d3a27ce65024caeaf3cb59bda842a17\5-1053058670.png" alt="img"></p><p><strong>解决办法：</strong>在 JavaBean 对象中增加一个 serialVersionUID 字段，用来固定这个版本，无论我们怎么修改，版本都是一致的，就能进行反序列化了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8656128222714547171L</span>;</span><br></pre></td></tr></table></figure><p>后面反序列化出来的对象属性以最新版本的为准。</p><p>而txt文件中的内容不会变，仍然仅记录的最初始的对象，而反序列化，会根据版本号，找到当前最新的对象（版本号已经固定不变，会根据版本号去找；）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是序列化与反序列化？&quot;&gt;&lt;a href=&quot;#1、什么是序列化与反序列化？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是序列化与反序列化？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、什么是序列化与反序列化？&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="笔记" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="容器" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>集合工具</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Collections&quot;&gt;&lt;a href=&quot;#Collections&quot; class=&quot;headerlink&quot; title=&quot;Collections&quot;&gt;&lt;/a&gt;Collections&lt;/h2&gt;&lt;h2 id=&quot;Arrays&quot;&gt;&lt;a href=&quot;#Arrays&quot; cla</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="笔记" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="容器" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 复习笔记</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Java%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-复习笔记"><a href="#Java-复习笔记" class="headerlink" title="Java 复习笔记"></a>Java 复习笔记</h1><h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><ul><li><strong>数组：</strong>支持<strong>随机访问</strong>，并且容量有限</li><li>数组使用<strong>连续的内存空间</strong>，对CPU的缓存机制友好：可以预读数组中的数据，所以访问效率更高<ul><li>CPU读取内存的时候，会把一片连续的内存读取出来，然后放到缓存中。因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面，CPU 读取缓存里面的每个元素的时间平均只要3个CPU时钟周期。而CPU读取散布在堆内存空间中的链表节点数据需要100个CPU时钟周期（理论上）</li></ul></li><li><strong>链表</strong>：是一种线性表，但是并不会按线性的顺序存储数据，使用不连续的内存空间来存储数据<ul><li>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li></ul></li><li><strong>栈：</strong>只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop），且按照后进先出的顺序操作数据<ul><li>两个栈可以实现浏览器的前进和后退的功能</li><li>检查符号是否成对</li><li>计算器</li><li>反转字符</li><li>函数调用</li></ul></li><li><strong>队列：</strong>先进先出</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-复习笔记&quot;&gt;&lt;a href=&quot;#Java-复习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java 复习笔记&quot;&gt;&lt;/a&gt;Java 复习笔记&lt;/h1&gt;&lt;h2 id=&quot;线性数据结构&quot;&gt;&lt;a href=&quot;#线性数据结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="笔记" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构" scheme="https://huangyuye.github.io/categories/Java/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Arthas 线上环境排查工具</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/Arthas%20%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/Arthas%20%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Arthas-线上环境排查工具"><a href="#Arthas-线上环境排查工具" class="headerlink" title="Arthas 线上环境排查工具"></a>Arthas 线上环境排查工具</h2><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>工具安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替代方案：wget https://alibaba.github.io/arthas/arthas-boot.jar</span></span><br><span class="line">apt-get update &amp;&amp; apt-get install curl &amp;&amp; curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure><ol start="2"><li>启动工具</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar  arthas-boot.jar</span><br></pre></td></tr></table></figure><ol start="3"><li><p>相关命令</p><ul><li>方法参数|响应监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span>:ognl观察表达式() -f: 方法结束监听 || -x: 指定遍历深度</span> </span><br><span class="line">watch [path] [method] &#x27;&#123;params, returnObj&#125;&#x27;  -f -x 7 </span><br></pre></td></tr></table></figure><ul><li>调用springBean方法：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行tt命令来记录RequestMappingHandlerAdapter#invokeHandlerMethod的请求，找到对应index</span></span></span><br><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 指定对应的index并调用springBean方法（tt -i 用于查看调用信息）</span></span></span><br><span class="line">tt -i 1020 -w &#x27;target.getApplicationContext().getBean(&quot;cacheManager&quot;).getCache(&quot;cache&quot;).put(&quot;WEWORK_ECRP_GROUP_ID_ww97d386b1d60bea91&quot;, 80000016L)&#x27;</span><br></pre></td></tr></table></figure></li><li><p>一键执行</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 工具下载&amp;运行</span></span></span><br><span class="line">apt-get update &amp;&amp; apt-get install curl &amp;&amp; curl -O https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; java -jar  arthas-boot.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 方法监听</span></span></span><br><span class="line">watch [path] [method] &#x27;&#123;params, returnObj&#125;&#x27;  -f -x 7 </span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Arthas-线上环境排查工具&quot;&gt;&lt;a href=&quot;#Arthas-线上环境排查工具&quot; class=&quot;headerlink&quot; title=&quot;Arthas 线上环境排查工具&quot;&gt;&lt;/a&gt;Arthas 线上环境排查工具&lt;/h2&gt;&lt;h3 id=&quot;使用实例&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="运维" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="线上问题排查" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>应用发布流程_TODO</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E8%81%9A%E7%9F%B3%E5%A1%94/%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B_TODO/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E8%81%9A%E7%9F%B3%E5%A1%94/%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B_TODO/</id>
    <published>2021-05-24T12:55:11.600Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="聚石塔—容器部署平台"><a href="#聚石塔—容器部署平台" class="headerlink" title="聚石塔—容器部署平台"></a>聚石塔—容器部署平台</h1><p> 聚石塔提供了从资源采购、应用部署到跟阿里巴巴业务链接一整套解决方案。</p><h2 id="名词术语"><a href="#名词术语" class="headerlink" title="名词术语"></a>名词术语</h2><ul><li>VPC(Virtual Private Cloud)：私有云<ul><li><strong>对于基础架构服务（IaaS），云就是指资源池。</strong>你或许听过公有云（Public Cloud），私有云（Private Cloud），混合云（Hybrid Cloud）。不过，VPC不属于这三种云中任一种。</li><li>这是一种<strong>运行在公有云上，将一部分公有云资源为某个用户隔离出来，给这个用户私有使用的资源的集合。</strong></li><li>向用户提供的隔离资源的集合</li></ul></li><li>ECS（<em>Elastic Cloud Server</em>）：弹性云服务器</li></ul><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>创建集群<ul><li>创建VPC、购买ECS、创建集群、添加ECS到集群</li></ul></li><li>创建应用</li><li>配置环境</li><li>应用发布</li><li>流量接入<ul><li>购买SLB、新建SLB流量接入、Ingress接入</li></ul></li></ol><h2 id="应用service访问"><a href="#应用service访问" class="headerlink" title="应用service访问"></a>应用service访问</h2><p><strong>多种方式</strong></p><ol><li>若实例部署配置Deployment如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 部署名</span></span><br><span class="line">  <span class="comment">#name: ecrp-sg-web</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/project:</span> <span class="string">ecrp</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">sg-h5</span></span><br></pre></td></tr></table></figure><p>集群内访问方式：${ app.kubernetes.io/name}.${app.kubernetes.io/projec}</p><ol start="2"><li>配置集群服务，获得ClusterIP，使用ClusterIP</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>聚石塔团队官网：<a href="https://www.yuque.com/fczggw/wu7u0k/gfhekf">https://www.yuque.com/fczggw/wu7u0k/gfhekf</a></li><li>什么是VPC：<a href="https://zhuanlan.zhihu.com/p/33658624">https://zhuanlan.zhihu.com/p/33658624</a></li><li>k8s官网：<a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#%E6%9C%AF%E8%AF%AD">https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#%E6%9C%AF%E8%AF%AD</a></li><li>《NodePort vs LoadBalancer vs Ingress》：<ul><li><a href="https://blog.csdn.net/yang75108/article/details/101101384">https://blog.csdn.net/yang75108/article/details/101101384</a></li><li><a href="https://blog.csdn.net/yang75108/article/details/101268208">https://blog.csdn.net/yang75108/article/details/101268208</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;聚石塔—容器部署平台&quot;&gt;&lt;a href=&quot;#聚石塔—容器部署平台&quot; class=&quot;headerlink&quot; title=&quot;聚石塔—容器部署平台&quot;&gt;&lt;/a&gt;聚石塔—容器部署平台&lt;/h1&gt;&lt;p&gt; 聚石塔提供了从资源采购、应用部署到跟阿里巴巴业务链接一整套解决方案。&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="运维" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="聚石塔" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/%E8%81%9A%E7%9F%B3%E5%A1%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Nacos配置中心</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Nacos-的关键特性"><a href="#Nacos-的关键特性" class="headerlink" title="Nacos 的关键特性"></a>Nacos 的关键特性</h2><h3 id="服务发现和服务健康监测"><a href="#服务发现和服务健康监测" class="headerlink" title="服务发现和服务健康监测"></a>服务发现和服务健康监测</h3><p>支持基于 DNS 和基于 RPC 的服务发现</p><h3 id="动态配置服务"><a href="#动态配置服务" class="headerlink" title="动态配置服务"></a>动态配置服务</h3><h3 id="动态-DNS-服务"><a href="#动态-DNS-服务" class="headerlink" title="动态 DNS 服务"></a>动态 DNS 服务</h3><h3 id="服务及其元数据管理"><a href="#服务及其元数据管理" class="headerlink" title="服务及其元数据管理"></a>服务及其元数据管理</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="Nacos配置文件"><a href="#Nacos配置文件" class="headerlink" title="Nacos配置文件"></a>Nacos配置文件</h2><h3 id="配置文件加载配置"><a href="#配置文件加载配置" class="headerlink" title="配置文件加载配置"></a>配置文件加载配置</h3><p>以下是我司某应用的启动类配置，配置了N个配置文件的加载</p><p>注意 <code>shared-configs[i]</code> ： i 从0开始连续配置，前后配置相同的属性key会进行覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties props = System.getProperties();</span><br><span class="line"># 基础启动类：ecrp项目通用配置</span><br><span class="line">props.setProperty(<span class="string">&quot;spring.cloud.nacos.config.shared-configs[0].data-id&quot;</span>, NacosConstant.getNacosConfigShareName(<span class="string">&quot;ecrp-sca-common&quot;</span>, profile, <span class="string">&quot;yml&quot;</span>));</span><br><span class="line"># 扩展启动类：导购项目通用配置</span><br><span class="line">props.setProperty(<span class="string">&quot;spring.cloud.nacos.config.shared-configs[1].data-id&quot;</span>, <span class="string">&quot;ecrp-sca-sg-application-&quot;</span> + profile + <span class="string">&quot;.yml&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;spring.cloud.nacos.config.shared-configs[2].data-id&quot;</span>, <span class="string">&quot;ecrp-sca-sg-common-&quot;</span> + profile + <span class="string">&quot;.yml&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="关于spring配置文件加载"><a href="#关于spring配置文件加载" class="headerlink" title="关于spring配置文件加载"></a>关于spring配置文件加载</h3><p><a href="https://zhuanlan.zhihu.com/p/48030077">Spring Boot 外部化配置实战解析</a></p><p>MutablePropertySources 用于将多个配置集合统一加载，包括：</p><ul><li>系统属性、系统环境变量、命令行变量、应用自定义变量等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">propertySources.addFirst(<span class="keyword">new</span> SimpleCommandLinePropertySource(args));</span><br><span class="line">propertySources.addLast(<span class="keyword">new</span> MapPropertySource(<span class="string">&quot;systemProperties&quot;</span>, environment.getSystemProperties()));</span><br><span class="line">propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource(<span class="string">&quot;systemEnvironment&quot;</span>, environment.getSystemEnvironment()));</span><br><span class="line">Properties props = System.getProperties();</span><br><span class="line">props.setProperty(<span class="string">&quot;spring.application.name&quot;</span>, appName);</span><br><span class="line"><span class="comment">// todo ...</span></span><br></pre></td></tr></table></figure><h3 id="关于-bootstrap-yml"><a href="#关于-bootstrap-yml" class="headerlink" title="关于 bootstrap.yml"></a>关于 bootstrap.yml</h3><p><a href="https://www.jianshu.com/p/c955c44ae534">application.yml与bootstrap.yml的区别</a></p><p><code>bootstrap.yml</code> 用来程序引导时执行，应用于更加早期配置信息读取。可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。一旦bootStrap.yml 被加载，则内容不会被覆盖。</p><p>Bootstrap 属性有高优先级，默认情况下，它们不会被本地配置覆盖。</p><h3 id="Nacos如何验证配置文件正常读取"><a href="#Nacos如何验证配置文件正常读取" class="headerlink" title="Nacos如何验证配置文件正常读取"></a>Nacos如何验证配置文件正常读取</h3><ul><li>NascentApplication#createSpringApplicationBuilder<ul><li>ServiceLoader.load(LauncherService.class).forEach(launcherList::add); // 我司封装的配置文件扩展类</li><li>spring.profiles.active = ${profile} // 确认环境配置正确</li><li>spring.cloud.nacos.discovery.server-addr = ${nacosAddress} // 确认使用正确的nacos地址</li></ul></li></ul><h3 id="Nacos-配置本地快照"><a href="#Nacos-配置本地快照" class="headerlink" title="Nacos 配置本地快照"></a>Nacos 配置本地快照</h3><p><code>windows系统：C:\用户\&#123;用户名&#125;\nacos\config</code></p><h3 id="Nacos-配置文件分层"><a href="#Nacos-配置文件分层" class="headerlink" title="Nacos 配置文件分层"></a>Nacos 配置文件分层</h3><p><strong>NameSpace &gt; Group &gt; DataId</strong></p><ul><li>Namespace：代表不同的环境，如：开发、测试， 生产等；<ul><li>spring.cloud.nacos.config.namespace=b3404bc0-d7dc-4855-b519-570ed34b62d7<ul><li>指定命名空间，默认使用public命名空间</li></ul></li></ul></li><li>Group：代表某个项目，如：XX物流项目，XX教育项目；<ul><li>spring.cloud.nacos.config. group: DEFAULT_GROUP <ul><li>分 组，默认为 DEFAULT_GROUP </li></ul></li></ul></li><li>DataId：每个项目下往往有若干个应用，每个配置集(DataId)是一个应用的主配置文件</li></ul><h3 id="Nacos配置自动更新"><a href="#Nacos配置自动更新" class="headerlink" title="Nacos配置自动更新"></a>Nacos配置自动更新</h3><p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新。</p><h4 id="todo-。。。（该注解与扩展配置refresh属性配置区别？）"><a href="#todo-。。。（该注解与扩展配置refresh属性配置区别？）" class="headerlink" title="todo 。。。（该注解与扩展配置refresh属性配置区别？）"></a>todo 。。。（该注解与扩展配置refresh属性配置区别？）</h4><p>《@RefreshScope那些事》：<a href="https://www.jianshu.com/p/188013dd3d02">https://www.jianshu.com/p/188013dd3d02</a></p><h3 id="Nacos公共配置-扩展配置"><a href="#Nacos公共配置-扩展配置" class="headerlink" title="Nacos公共配置/扩展配置"></a>Nacos公共配置/扩展配置</h3><p>多应用共享配置，即多个DataId之间的配置共享</p><h4 id="扩展配置"><a href="#扩展配置" class="headerlink" title="扩展配置"></a>扩展配置</h4><ul><li>通过配置 <code>spring.cloud.nacos.config.ext-config[n].data-id</code> 来支持多个配置集。</li><li>通过配置 <code>spring.cloud.nacos.config.ext-config[n].group</code> 来定制配置组。如果未指定，则使用默认组。</li><li>通过配置 <code>spring.cloud.nacos.config.ext-config[n].refresh</code> 来控制该配置集是否支持配置的动态刷新。默认情况下不支持。</li></ul><h4 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h4><p>通过共享配置集的方式也可以实现公共配置的功能，唯一的区别就是共享配置集无法设置组信息，只获取 DEFAULT_GROUP</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享配置集</span></span><br><span class="line"><span class="string">spring.cloud.nacos.config</span></span><br><span class="line">  <span class="attr">shared-dataids:</span> <span class="string">ext-config-common01.yaml,ext-config-common02.yaml,ext-config-common03.yaml</span> <span class="comment"># 多个配置集逗号隔开</span></span><br><span class="line">  <span class="attr">refreshable-dataids:</span> <span class="string">ext-config-common01.yaml</span> <span class="comment"># 指定哪个配置集支持动态刷新</span></span><br></pre></td></tr></table></figure><h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p>Spring Cloud Alibaba Nacos Config 提供了三种从 Nacos 拉取配置的功能：</p><ul><li>A：通过内部相关规则（应用名、配置内容的数据格式等）自动生成相关的 Data Id 配置；<ul><li><code>$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</code></li><li><code>prefix</code> 默认为<code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li></ul></li><li>B：通过配置 <code>spring.cloud.nacos.config.ext-config[n].data-id</code> 来支持多个配置集。同时配置多个配置集时，优先级关系根据 <code>n</code> 的值决定，值越大，优先级越高；</li><li>C：通过配置 <code>spring.cloud.nacos.config.shared-dataids</code> 配置多个共享配置集；</li></ul><p>　</p><p>​    <strong>当三种方式同时使用时，优先级关系为：A &gt; B &gt; C。</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Spring-SPI-机制"><a href="#Spring-SPI-机制" class="headerlink" title="Spring SPI 机制"></a>Spring SPI 机制</h3><p><strong>场景：</strong></p><p>服务提供方定义统一标准的接口服务，但不进行实现。在某个业务流程中应用该接口服务，可以理解为在确定的业务流程中加入了hook由服务消费端定制化接口服务的实现。具体步骤如下</p><ul><li><p>定义接口，并在某流程中应用</p></li><li><p>配置SPI文件</p><ul><li><p>SPI文件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resources</span><br><span class="line">| -- META-INF</span><br><span class="line">| -- -- services </span><br><span class="line">| -- -- -- $&#123;interface.name&#125; # 接口的全路径名称</span><br></pre></td></tr></table></figure></li><li><p>SPI文件内容</p><ul><li><code>$&#123;interface.name&#125;</code> 文件内容为接口实现类的全路径</li></ul></li></ul></li><li><p>代码中使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader.load(LauncherService.class).forEach(launcherList::add);</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/46b42f7f593c">《高级开发必须理解的Java中SPI机制》</a></p><h3 id="Nacos-实现应用版本控制"><a href="#Nacos-实现应用版本控制" class="headerlink" title="Nacos 实现应用版本控制"></a>Nacos 实现应用版本控制</h3><p><a href="https://blog.csdn.net/suxingrui/article/details/103791284">《Nacos：实现版本控制调度，灰度版本隔离》</a></p><h4 id="todo-。。。"><a href="#todo-。。。" class="headerlink" title="todo 。。。"></a>todo 。。。</h4><h3 id="ECRP-开放平台-Feign-配置"><a href="#ECRP-开放平台-Feign-配置" class="headerlink" title="ECRP 开放平台 Feign 配置"></a>ECRP 开放平台 Feign 配置</h3><p>相关配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OpenApiFeignClientAutoConfiguration</span><br><span class="line">OpenApiSpringEncoder</span><br></pre></td></tr></table></figure><h3 id="智慧导购-微服务记录"><a href="#智慧导购-微服务记录" class="headerlink" title="智慧导购-微服务记录"></a>智慧导购-微服务记录</h3><h4 id="nacos读取问题"><a href="#nacos读取问题" class="headerlink" title="nacos读取问题"></a>nacos读取问题</h4><ul><li><code>OpenApiSpringEncoder</code>：Assert.notNull(this.appKey, “ecrp.open.api.feign.appKey must be not null”);<ul><li><code>ecrp.open.api.feign.appKey</code>（配置时使用”-“分割单词或驼峰标识均可）</li><li>启动时需要compile项目才能保证正常扫描父模块 <code>ecrp-sca-sg-starter</code> 的 <code>LauncherServiceImpl</code></li></ul></li></ul><h4 id="feign-问题"><a href="#feign-问题" class="headerlink" title="feign 问题"></a>feign 问题</h4><ul><li>com.netflix.client.ClientException: Load balancer does not have available server for client: ecrp-sca-open-customer </li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html#_%E4%BB%8B%E7%BB%8D">《Spring Cloud Alibaba 参考文档》</a></p><p><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">《nacos官网》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;Nacos-的关键特性&quot;&gt;&lt;a href=&quot;#Nacos-的关键特性&quot; class=&quot;headerlink&quot; title=&quot;Nacos 的关键特性</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="SpringCloudAlibaba" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/"/>
    
    
  </entry>
  
  <entry>
    <title>openfeign</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/openfeign/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/openfeign/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><h3 id="FeignClient"><a href="#FeignClient" class="headerlink" title="@FeignClient"></a>@FeignClient</h3><p>标注用于声明Feign客户端可访问的Web服务。</p><h3 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h3><p>标注用于修饰Spring Boot应用的入口类，以通知Spring Boot启动应用时，扫描应用中声明的Feign客户端可访问的Web服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;核心注解&quot;&gt;&lt;a href=&quot;#核心注解&quot; class=&quot;headerlink&quot; title=&quot;核心注解&quot;&gt;&lt;/a&gt;核心注解&lt;/h2&gt;&lt;h3 id=&quot;FeignClient&quot;&gt;&lt;a href=&quot;#FeignClient&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="SpringCloudAlibaba" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql使用场景技巧</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mysql/mysql%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%8A%80%E5%B7%A7/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mysql/mysql%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%8A%80%E5%B7%A7/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h4 id="组内排序"><a href="#组内排序" class="headerlink" title="组内排序"></a>组内排序</h4><p>分组查询每组的前n条记录，要求：需要按某个字段分组，且每组只能取一条记录；按某个字段倒序</p><ol><li><p><strong>子查询：</strong>先全表排序作为子查询，然后分组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> a.table1_id</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">as</span> a <span class="keyword">where</span> age <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> table2 <span class="keyword">where</span> a.table1_id<span class="operator">=</span>table1_id)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">as</span> a <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">where</span> table1_id<span class="operator">=</span>a.table1_id <span class="keyword">and</span> age<span class="operator">&gt;</span>a.age)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">as</span> a <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> table2 <span class="keyword">where</span> table1_id<span class="operator">=</span>a.table1_id <span class="keyword">and</span> age<span class="operator">&gt;</span>a.age <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">=</span><span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>group_concat(id order bydatedesc) + SUBSTRING_INDEX</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> SUBSTRING_INDEX(GROUP_CONCAT(id <span class="keyword">ORDER</span> <span class="keyword">BY</span> `<span class="type">date</span>` <span class="keyword">DESC</span>)</span><br></pre></td></tr></table></figure></li></ol><ul><li>关于exists的解释：只要exists引导的子句有结果集返回，则表示连接条件为真<ul><li>参考链接：<a href="https://zhuanlan.zhihu.com/p/20005249">https://zhuanlan.zhihu.com/p/20005249</a></li></ul></li></ul><h4 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sg_guide_shop <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> sg_guide_shop <span class="keyword">group</span> <span class="keyword">by</span> guide_id,shop_id <span class="keyword">having</span> <span class="built_in">count</span>(id) <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">and</span> id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> sg_guide_shop <span class="keyword">group</span> <span class="keyword">by</span> guide_id,shop_id  <span class="keyword">having</span> <span class="built_in">count</span>(id)<span class="operator">&gt;</span><span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="utf8mb4编码"><a href="#utf8mb4编码" class="headerlink" title="utf8mb4编码"></a>utf8mb4编码</h4><p>将数据表字段修改为utf8mb4 及将数据表编码改为utf8mb4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sg_login_log MODIFY <span class="keyword">COLUMN</span> operate_name <span class="type">VARCHAR</span>(<span class="number">70</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT &quot;操作人&quot;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sg_login_log <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure><h4 id="统计各日期的业务数据，没有数据的日期补零"><a href="#统计各日期的业务数据，没有数据的日期补零" class="headerlink" title="统计各日期的业务数据，没有数据的日期补零"></a>统计各日期的业务数据，没有数据的日期补零</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 生成辅助表，生成N条记录，每条记录用于辅助生成<span class="number">1</span>天的数据</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if  <span class="keyword">exists</span> sg_base_datetime_help;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sg_base_datetime_help` (</span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    `temp` tinyint(<span class="number">4</span>) <span class="keyword">default</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;临时字段，生成数据后删除&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;日期辅助表，用于生成n条数据&#x27;</span>;</span><br><span class="line"># 先生成一条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sg_base_datetime_help(temp) <span class="keyword">select</span> now() <span class="keyword">from</span> dual;</span><br><span class="line"># 下面两条语句执行N次, 生成<span class="number">4</span>k<span class="number">-1</span>w条数据(<span class="number">4096</span>即可)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sg_base_datetime_help(temp) <span class="keyword">select</span> now() <span class="keyword">from</span> sg_base_datetime_help;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> sg_base_datetime_help;</span><br><span class="line"># 删除临时字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> sg_base_datetime_help <span class="keyword">drop</span> <span class="keyword">column</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 使用辅助表作为左关联主表，主表<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="variable">@cdate</span> :<span class="operator">=</span> DATE_FORMAT(date_add( <span class="variable">@cdate</span>, <span class="type">INTERVAL</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">DAY</span> ), <span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">as</span> <span class="type">date</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(SELECT @cdate := date_add(#&#123;endTime&#125;, interval + 1 day) FROM sg_base_datetime_help) tmp1 WHERE @cdate &gt;#&#123;startTime&#125;;</span><br></pre></td></tr></table></figure><h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><h4 id="查询数据库数据表情况"><a href="#查询数据库数据表情况" class="headerlink" title="查询数据库数据表情况"></a>查询数据库数据表情况</h4><p>如数据行数、自增id号；注意<code>information_schema</code>的<code>auto_increment</code>不一定为实际值!</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_CATALOG,</span><br><span class="line">       TABLE_SCHEMA,</span><br><span class="line">       TABLE_NAME,</span><br><span class="line">       TABLE_TYPE,</span><br><span class="line">       ENGINE,</span><br><span class="line">       VERSION,</span><br><span class="line">       ROW_FORMAT,</span><br><span class="line">       TABLE_ROWS,</span><br><span class="line">       AVG_ROW_LENGTH,</span><br><span class="line">       DATA_LENGTH,</span><br><span class="line">       MAX_DATA_LENGTH,</span><br><span class="line">       INDEX_LENGTH,</span><br><span class="line">       DATA_FREE,</span><br><span class="line">       AUTO_INCREMENT,</span><br><span class="line">       CREATE_TIME,</span><br><span class="line">       UPDATE_TIME,</span><br><span class="line">       CHECK_TIME,</span><br><span class="line">       CHARACTER_SET_NAME,</span><br><span class="line">       TABLE_COLLATION,</span><br><span class="line">       CHECKSUM,</span><br><span class="line">       CREATE_OPTIONS,</span><br><span class="line">       TABLE_COMMENT</span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line">         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> information_schema.COLLATION_CHARACTER_SET_APPLICABILITY <span class="keyword">ON</span> TABLE_COLLATION <span class="operator">=</span> COLLATION_NAME</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;ecrp_sg_test&#x27;</span> <span class="keyword">AND</span> TABLE_TYPE <span class="operator">=</span> <span class="string">&#x27;BASE TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="查询存在某字段的数据表"><a href="#查询存在某字段的数据表" class="headerlink" title="查询存在某字段的数据表"></a>查询存在某字段的数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,column_name <span class="keyword">from</span> information_schema.columns </span><br><span class="line">where table_schema = #&#123;tableSchema&#125; </span><br><span class="line"><span class="keyword">and</span> column_name <span class="keyword">in</span> (<span class="string">&#x27;group_id&#x27;</span>,&quot;groupid&quot;,<span class="string">&#x27;brand_id&#x27;</span>, &quot;groupid&quot;, &quot;source_id&quot;);</span><br></pre></td></tr></table></figure><h4 id="查询数据库查询进程"><a href="#查询数据库查询进程" class="headerlink" title="查询数据库查询进程"></a>查询数据库查询进程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name,column_name <span class="keyword">from</span> information_schema.PROCESSLIST; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;业务&quot;&gt;&lt;a href=&quot;#业务&quot; class=&quot;headerlink&quot; title=&quot;业务&quot;&gt;&lt;/a&gt;业务&lt;/h2&gt;&lt;h4 id=&quot;组内排序&quot;&gt;&lt;a href=&quot;#组内排序&quot; class=&quot;headerlink&quot; title=&quot;组内排序&quot;&gt;&lt;/a&gt;组内排序&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA使用</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/IDEA%E4%BD%BF%E7%94%A8/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/IDEA%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h1><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>1、GenerateAllSetter ：通过alt+enter对变量类生成对类的所有setter方法的调用</p><p>2、Maven Helper：帮助你更方便的分析依赖关系</p><p>3、Translation：中英文翻译工具</p><p>4、aiXcode &amp; codota &amp; Kite ：强大的代码完成器和代码搜索引擎，且帮助您在GitHub上搜索API用例</p><p>5、checkStyle &amp; spotBugs(FindBugs的升级版) &amp; sonor：作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。</p><p>6、SequenceDiagram：可以根据代码调用链路自动生成时序图</p><p>7、GsonFormat：把json格式的内容转成Object的需求</p><p>8、AceJump：能够代替鼠标的软件</p><ul><li><a href="https://cloud.tencent.com/developer/article/1343318">https://cloud.tencent.com/developer/article/1343318</a></li></ul><p>9、Java Stream Debugger：流式编程调试插件 </p><p>11、lombok</p><p>12、<strong>Alibaba Java Coding Guidelines</strong> </p><p>14、junitGenerator V2.0（<strong>定义生成测试case的风格</strong>）</p><p>15、background image plus</p><p>16、CamelCase：命名风格切换，如驼峰命名切换成下划线分割</p><p>17、CodeGlance：在编辑区的右侧显示的代码地图</p><p>18、Material Theme UI：主题插件</p><p>19、Nyan progress bar：进度条美化</p><p>20、Power mode II</p><p>21、Rainbow Brackets：彩虹颜色的括号</p><h3 id="插件网"><a href="#插件网" class="headerlink" title="插件网"></a>插件网</h3><p><a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a></p><p><strong>配置idea模板</strong></p><p>todo：powerDesigner的常用配置及使用技巧 + idea注释模板配置.pdf</p><p><strong>参考链接</strong></p><p><a href="https://blog.csdn.net/weixin_41846320/article/details/82697818">https://blog.csdn.net/weixin_41846320/article/details/82697818</a></p><p><a href="https://zhuanlan.zhihu.com/p/99354824">https://zhuanlan.zhihu.com/p/99354824</a></p><p><a href="https://www.jianshu.com/p/c1f87b0dd597">https://www.jianshu.com/p/c1f87b0dd597</a></p><p><a href="https://blog.csdn.net/weixin_41846320/article/details/82697818">https://blog.csdn.net/weixin_41846320/article/details/82697818</a></p><p><a href="https://zhuanlan.zhihu.com/p/99354824">https://zhuanlan.zhihu.com/p/99354824</a></p><p><a href="https://www.jianshu.com/p/c1f87b0dd597">https://www.jianshu.com/p/c1f87b0dd597</a></p><p><a href="https://cloud.tencent.com/developer/article/1343318">https://cloud.tencent.com/developer/article/1343318</a></p><p><a href="https://www.zhihu.com/question/20783392">https://www.zhihu.com/question/20783392</a></p><h2 id="Settings配置"><a href="#Settings配置" class="headerlink" title="Settings配置"></a>Settings配置</h2><p>修改主题</p><ul><li>editor &gt; color scheme </li></ul><p>字体大小</p><ul><li>editor &gt; font</li></ul><p>代码补全匹配规则</p><ul><li>editor &gt; General &gt; Code Completion </li></ul><p>包自动导入功能</p><ul><li>editor &gt; auto import &gt; <ul><li>Add unambiguous imports on the fly：快速添加明确的导入;</li><li>Optimize imports on the fly：快速优化导入，优化的意思即自动帮助删除无用的导入。</li></ul></li></ul><p>tab页面多行显示的设置</p><ul><li>editor &gt; General &gt; Editor Tabs </li></ul><p>代码注释风格</p><ul><li>editor &gt; Code Style &gt; Java &gt; Code Generation &gt; Comment Code</li></ul><h2 id="VM配置"><a href="#VM配置" class="headerlink" title="VM配置"></a>VM配置</h2><ul><li>Help / Edit Custom VM Options..</li></ul><p>默认配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Xms128m</span><br><span class="line">-Xmx2016m</span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;240m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB&#x3D;50</span><br><span class="line">-ea</span><br><span class="line">-XX:CICompilerCount&#x3D;2</span><br><span class="line">-Dsun.io.useCanonPrefixCache&#x3D;false</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf&#x3D;true</span><br><span class="line">-Dkotlinx.coroutines.debug&#x3D;off</span><br><span class="line">-Djdk.module.illegalAccess.silent&#x3D;true</span><br></pre></td></tr></table></figure><p>调整配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xms4096m</span><br><span class="line">-Xmx4096m</span><br><span class="line">-XX:NewRatio&#x3D;3</span><br><span class="line">-Xss16m</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:ConcGCThreads&#x3D;4</span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;2048m</span><br><span class="line">-XX:+AlwaysPreTouch</span><br><span class="line">-XX:+TieredCompilation</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB&#x3D;50</span><br><span class="line">-Dsun.io.useCanonCaches&#x3D;false</span><br><span class="line">-Djava.net.preferIPv4Stack&#x3D;true</span><br><span class="line">-Djsse.enableSNIExtension&#x3D;false</span><br><span class="line">-ea</span><br><span class="line">-XX:CICompilerCount&#x3D;2</span><br><span class="line">-Dsun.io.useCanonPrefixCache&#x3D;false</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf&#x3D;true</span><br><span class="line">-Dkotlinx.coroutines.debug&#x3D;off</span><br><span class="line">-Djdk.module.illegalAccess.silent&#x3D;true</span><br></pre></td></tr></table></figure><h2 id="GIT命令行配置"><a href="#GIT命令行配置" class="headerlink" title="GIT命令行配置"></a>GIT命令行配置</h2><p>settings &gt; terminal -&gt; 配置shell path为 ${GIT_HOME}/bin/bash.exe</p><h2 id="HTTP工具"><a href="#HTTP工具" class="headerlink" title="HTTP工具"></a>HTTP工具</h2><p>所有HTTP请求需要在后缀为.http的文件中进行，新建一个test.http文件。基本格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求类型(如：GET， POST，PUT) +  请求地址（http:&#x2F;&#x2F;www.baidu.com）</span><br><span class="line">请求头</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">请求体</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/a/1190000021714448">IntelliJ IDEA的这个接口调试工具真是太好用了！</a></p><p><a href="https://www.jianshu.com/p/2404654d655a">IDEA-HTTP工具</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看方法实现：ctrl + alt + B</p><p>查看方法声明：ctrl + U （Super Method）</p><p>查看类声明：ctrl + shrift + B</p><h2 id="注释模板"><a href="#注释模板" class="headerlink" title="注释模板"></a>注释模板</h2><h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><p><code>settings -&gt; Editor -&gt; Live templates</code></p><p>建立模板组 -&gt; 新建模板 -&gt; 设置模板名称为 *</p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154737.png" alt="img"></p><ul><li>模板内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * TODO</span><br><span class="line"> *</span><br><span class="line"> $params$</span><br><span class="line"> * <span class="meta">@return</span> &#123;<span class="meta">@link</span> $<span class="keyword">return</span>$&#125;</span><br><span class="line"> * <span class="meta">@author</span> huangyuye</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>Edit variable -&gt; param 配置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;if(\&quot;$&#123;_1&#125;\&quot;.length() &#x3D;&#x3D; 2) &#123;return &#39;&#39;;&#125; else &#123;def result&#x3D;&#39;&#39;; def params&#x3D;\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#39;[\\\\[|\\\\]|\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList();for(i &#x3D; 0; i &lt; params.size(); i++) &#123;if(i&#x3D;&#x3D;0)&#123;result+&#x3D;&#39;* @param &#39; + params[i] + &#39; TODO &#39;&#125;else&#123;result+&#x3D;&#39;\\n&#39; + &#39; * @param &#39; + params[i] + &#39; TODO &#39;&#125;&#125;; return result;&#125;&quot;, methodParameters())</span><br></pre></td></tr></table></figure><ul><li>使用： 方法签名上输入 <code>/**</code>+ 补全键</li></ul><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154944.png" alt="img"></p><h3 id="类注释配置"><a href="#类注释配置" class="headerlink" title="类注释配置"></a>类注释配置</h3><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515155045.png" alt="img"></p><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/7dd84a9f6597">idea配置方法注释模板（带参数获取）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDEA使用&quot;&gt;&lt;a href=&quot;#IDEA使用&quot; class=&quot;headerlink&quot; title=&quot;IDEA使用&quot;&gt;&lt;/a&gt;IDEA使用&lt;/h1&gt;&lt;h2 id=&quot;常用插件&quot;&gt;&lt;a href=&quot;#常用插件&quot; class=&quot;headerlink&quot; title=&quot;常</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Powerdesigner使用</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Powerdesigner%E4%BD%BF%E7%94%A8/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Powerdesigner%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Powerdesigner-使用"><a href="#Powerdesigner-使用" class="headerlink" title="Powerdesigner 使用"></a>Powerdesigner 使用</h2><h3 id="数据表创建"><a href="#数据表创建" class="headerlink" title="数据表创建"></a>数据表创建</h3><h4 id="1-创建数据库表Table"><a href="#1-创建数据库表Table" class="headerlink" title="1. 创建数据库表Table"></a>1. 创建数据库表Table</h4><h4 id="2-Table配置页面相关如下"><a href="#2-Table配置页面相关如下" class="headerlink" title="2. Table配置页面相关如下"></a>2. Table配置页面相关如下</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154057.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154216.png" alt="img"></p><span id="more"></span><h3 id="常用配置技巧"><a href="#常用配置技巧" class="headerlink" title="常用配置技巧"></a>常用配置技巧</h3><h4 id="1-配置commoent、domain列的启用"><a href="#1-配置commoent、domain列的启用" class="headerlink" title="1.  配置commoent、domain列的启用"></a>1.  配置commoent、domain列的启用</h4><p>​            \1. Tools -&gt; Display Preferences -&gt; </p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154119.png" alt="img"></p><p>​           </p><h4 id="2-设置-table配置页面使用的列属性-快捷键Ctrl-U"><a href="#2-设置-table配置页面使用的列属性-快捷键Ctrl-U" class="headerlink" title="2. 设置 table配置页面使用的列属性(快捷键Ctrl + U)"></a>2. 设置 table配置页面使用的列属性(快捷键Ctrl + U)</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154123.png" alt="img"></p><h4 id="3-添加comment、domain列属性"><a href="#3-添加comment、domain列属性" class="headerlink" title="3. 添加comment、domain列属性"></a>3. 添加comment、domain列属性</h4><p>​      (在建立表时，如果很多字段的data type是一样的类型，一样的长度，那么可以建立domain，方便统一管理)</p><p>​            - 系统主键</p><p>​            - 时间格式</p><p>​            - 字符串格式</p><p>​            - 用户编号</p><p><img src="D:\AppData\YoudaoNote\qqB53912A331D409871E525BE52BFB5C3B\9c70b9754960485490c7e5ddc8068b61\clipboard.png" alt="img"></p><h4 id="新建表，addColumns导入其他表中的字段，可以修改，但是两张表的修改不同步-如会员卡号，订单编号，字段类型和长度一致"><a href="#新建表，addColumns导入其他表中的字段，可以修改，但是两张表的修改不同步-如会员卡号，订单编号，字段类型和长度一致" class="headerlink" title="新建表，addColumns导入其他表中的字段，可以修改，但是两张表的修改不同步(如会员卡号，订单编号，字段类型和长度一致)"></a>新建表，addColumns导入其他表中的字段，可以修改，但是两张表的修改不同步(如会员卡号，订单编号，字段类型和长度一致)</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154128.png" alt="img"></p><h4 id="复制列-gt-共用其他表中的字段，当前表引用后不允许修改，只有被引用的表才能修改，且修改同步到所有引用到的表-如会员卡号，订单编号，字段类型和长度一致"><a href="#复制列-gt-共用其他表中的字段，当前表引用后不允许修改，只有被引用的表才能修改，且修改同步到所有引用到的表-如会员卡号，订单编号，字段类型和长度一致" class="headerlink" title="复制列 -&gt; 共用其他表中的字段，当前表引用后不允许修改，只有被引用的表才能修改，且修改同步到所有引用到的表(如会员卡号，订单编号，字段类型和长度一致)"></a>复制列 -&gt; 共用其他表中的字段，当前表引用后不允许修改，只有被引用的表才能修改，且修改同步到所有引用到的表(如会员卡号，订单编号，字段类型和长度一致)</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154204.png" alt="img"></p><h4 id="配置字段属性：选中指定行，点击上侧工具栏按钮-快捷键-直接双击"><a href="#配置字段属性：选中指定行，点击上侧工具栏按钮-快捷键-直接双击" class="headerlink" title="配置字段属性：选中指定行，点击上侧工具栏按钮 / 快捷键 / 直接双击"></a>配置字段属性：选中指定行，点击上侧工具栏按钮 / 快捷键 / 直接双击</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154132.png" alt="img"></p><h4 id="配置字段类型无符号"><a href="#配置字段类型无符号" class="headerlink" title="配置字段类型无符号"></a>配置字段类型无符号</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154134.png" alt="img"></p><h4 id="查看当前表的建表语句或者整个空间的建表语句"><a href="#查看当前表的建表语句或者整个空间的建表语句" class="headerlink" title="查看当前表的建表语句或者整个空间的建表语句"></a>查看当前表的建表语句或者整个空间的建表语句</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154139.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154156.png" alt="img"></p><h4 id="直接导出或预览查看"><a href="#直接导出或预览查看" class="headerlink" title="直接导出或预览查看"></a>直接导出或预览查看</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154149.png" alt="img"></p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154145.png" alt="img"></p><h4 id="配置字段中name和code不同步"><a href="#配置字段中name和code不同步" class="headerlink" title="配置字段中name和code不同步"></a>配置字段中name和code不同步</h4><p>Tools→General Options→Dialog→Name to Code mirroring（取消勾选）→最后确定即可</p><h4 id="配置版本控制，多人协作：repository"><a href="#配置版本控制，多人协作：repository" class="headerlink" title="配置版本控制，多人协作：repository"></a>配置版本控制，多人协作：repository</h4><p><strong>a. 创建/定义repository （repository -&gt; definition）</strong></p><p><strong>b. 初始化repository 默认登陆账号为大写ADMIN 密码空 repository -&gt; connection</strong></p><p><strong>c. 设置用户和群组及操作权限repository-&gt;Users</strong></p><p><strong>参考链接</strong>：<a href="http://www.doc88.com/p-806805418378.html">http://www.doc88.com/p-806805418378.html</a></p><p><a href="http://www.bubuko.com/infodetail-1083930.html">http://www.bubuko.com/infodetail-1083930.html</a></p><p><strong>d. 修改数据库charset为utf-8：</strong><a href="https://blog.csdn.net/zzcchunter/article/details/83650748">https://blog.csdn.net/zzcchunter/article/details/83650748</a></p><p><a href="http://www.makaidong.com/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%90%9C/10098.shtml">http://www.makaidong.com/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%90%9C/10098.shtml</a></p><p>e. checkin pdm / merge pdm</p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/clipboard.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Powerdesigner-使用&quot;&gt;&lt;a href=&quot;#Powerdesigner-使用&quot; class=&quot;headerlink&quot; title=&quot;Powerdesigner 使用&quot;&gt;&lt;/a&gt;Powerdesigner 使用&lt;/h2&gt;&lt;h3 id=&quot;数据表创建&quot;&gt;&lt;a href=&quot;#数据表创建&quot; class=&quot;headerlink&quot; title=&quot;数据表创建&quot;&gt;&lt;/a&gt;数据表创建&lt;/h3&gt;&lt;h4 id=&quot;1-创建数据库表Table&quot;&gt;&lt;a href=&quot;#1-创建数据库表Table&quot; class=&quot;headerlink&quot; title=&quot;1. 创建数据库表Table&quot;&gt;&lt;/a&gt;1. 创建数据库表Table&lt;/h4&gt;&lt;h4 id=&quot;2-Table配置页面相关如下&quot;&gt;&lt;a href=&quot;#2-Table配置页面相关如下&quot; class=&quot;headerlink&quot; title=&quot;2. Table配置页面相关如下&quot;&gt;&lt;/a&gt;2. Table配置页面相关如下&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154057.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515154216.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Vscode_TODO</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Vscode_TODO/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Vscode_TODO/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><p>vscode &amp; webstorm均可，这里使用了vscode</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>多人合作 or 个人项目，代码规范都是很重要的。遵循代码规范能够很大程度避免基本语法错误，也保证了代码的可读性。所以以下会说明代码规范神器—eslint插件。首先我们先来说说什么是eslint</p><ul><li><p>eslint</p><ul><li>ECMASCRIPT/JAVASCRIPT 代码中识别和报告”模式匹配”的工具，目标是保证代码的一致性和避免错误。</li><li>ECMASCRIPT：在万维网上往往被称为JavaScript或JScript，可以将它理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展</li></ul></li><li><p>eslint插件安装：</p><ul><li><p>settings</p><ul><li>文件 &gt; 首选项 &gt; 设置</li><li>配置如下</li></ul></li><li><p>.eslintrc.js：</p><ul><li>根据该文件配置的eslint规则来检查和做一些简单的fix。（可以把适合自己团队的代码规范统一制定好并上传到至npm）</li></ul></li></ul></li><li><p>eslint-plugin-vue 新版本默认支持vue eslint语法检查</p></li><li><p>配置文件说明：</p><ul><li>jsconfig.json<ul><li>目录中存在jsconfig.json文件表示该目录是JavaScript项目的根目录;jsconfig.json文件指定根文件和JavaScript语言服务提供的功能选项;文件本身可以选择列出属于项目的文件，要从项目中排除的文件，以及编译器选项<ul><li>“exclude”属性：告诉js语言服务哪些文件是什么文件，而不是源代码的一部分。（您将要排除由构建过程生成的文件（例如，dist目录））</li><li>使用“包含”属性：可以使用include属性（glob模式）显式设置项目中的文件。如果不存在include属性，则默认为包含目录和子目录中的所有文件。</li><li>compilerOptions：配置JavaScript语言支持（baseUrl&amp;paths(可以使用webpack别名)）</li></ul></li><li>如果没有使用该文件，所有js文件之间没有共同的项目上下文</li><li>如果使用了该文件，表示该目录是JavaScript项目的根目录</li><li>参考链接：<a href="https://www.jianshu.com/p/b0ec870ddfdf">https://www.jianshu.com/p/b0ec870ddfdf</a></li></ul></li><li>.eslintrc.js<ul><li>eslint代码检查配置<ul><li>npm install eslint –save</li><li>eslint –init # 初始化配置文件</li></ul></li><li>vscode安装 eslint插件，并配置用户变量以配置eslint校验的开关等配置，符合检查的文件类型，会根据.eslintrc.js配置的规则进行检查</li></ul></li><li>.editconfig（用来帮助开发者定义和维护代码风格（行尾结束符、缩进风格等））<ul><li>该文件用来定义一些格式化规则（此规则并不会被vscode直接解析）</li><li>vscode安装插件，插件去读取第一步创建的editorconfig文件中定义的规则，并覆盖user/workspace settings中的对应配置</li><li>npm安装editorconfig依赖包主要是因为EditorConfig依赖于editorconfig包，不安装的可能会导致EditorConfig无法正常解析我们在第一步定义的editorconfig文件</li><li>打开需要格式化的文件并手动格式化代码（shift+alt+f）：让经过EditorConfig扩展覆盖后的user/workspace settings生效</li></ul></li><li>babel.config.js<ul><li>安装相关的包：npm i @babel/core @babel/preset-env babel-loader -D</li><li>配置 webpack，编译哪些文件时需要使用babel加载器</li><li>配置加载器加载规则，即该文件的作用</li><li>如果想以编程的方式创建配置，需要编译 node_modules 中的内容那就使用 babel.config.js,如果只是一个简单的包的静态配置就使用，.babelrc</li></ul></li><li>jest.config.js<ul><li>jest是进行Javascript单元测试的工具</li><li>npm安装 jest</li><li>两种配置方式：<ul><li>在package.json添加配置项”jest” : { 配置项 }</li><li>jest init命令在根目录创建 jest.config.js文件，并添加配置项module.exports = { 配置项 }</li></ul></li></ul></li><li>postcss.config.js<ul><li>给postcss用的，优化css</li></ul></li><li>package.json<ul><li>定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。（<strong>类似于maven的pom文件</strong>）</li><li>scripts字段：指定了运行脚本命令的npm命令行缩写</li><li>dependencies字段，devDependencies字段：定了项目运行/开发所依赖的模块</li><li>package.json文件可以手工编写，也可以使用npm init命令自动生成。</li><li>如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。如$ npm install express –save / –save-dev</li><li>参考链接：<a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html">http://javascript.ruanyifeng.com/nodejs/packagejson.html</a></li></ul></li><li>vue.config.js<ul><li>vue项目配置文件</li><li>是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段。</li></ul></li></ul></li><li><p>安装插件，配置用户变量来提供代码格式化功能：<a href="https://segmentfault.com/q/1010000014829026?utm_source=tag-newest">https://segmentfault.com/q/1010000014829026?utm_source=tag-newest</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- Vetur : 语法高亮等功能</span><br><span class="line">- ESlint : 代码风格检测</span><br><span class="line">- Prettier formatter for Visual Studio Code: 为了配合 ESlint</span><br><span class="line">vue 的模板格式化：</span><br><span class="line">&quot;vetur.format.defaultFormatter.html&quot;:&quot;js-beautify-html&quot;</span><br><span class="line">vue 模板的 eslint 校验</span><br><span class="line">    &quot;eslint.validate&quot;: [</span><br><span class="line">        &quot;javascript&quot;,</span><br><span class="line">        &quot;javascriptreact&quot;,</span><br><span class="line">        &quot;html&quot;,</span><br><span class="line">        &quot;vue&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;language&quot;: &quot;html&quot;,</span><br><span class="line">            &quot;autoFix&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">Prettier 设置去除不必要空格：&quot;prettier.semi&quot;: false</span><br><span class="line">Prettier 设置格式化后&quot;变&#39;：&quot;prettier.singleQuote&quot;: true</span><br><span class="line">在 vscode 中排除 node_modules 等文件夹：</span><br><span class="line">&quot;files.exclude&quot;: &#123;</span><br><span class="line">    &quot;**&#x2F;.git&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.svn&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.hg&quot;: true,</span><br><span class="line">    &quot;**&#x2F;CVS&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.DS_Store&quot;: true,</span><br><span class="line">    &quot;**&#x2F;node_modules&quot;: true,</span><br><span class="line">    &quot;**&#x2F;package-lock.json&quot;: true,</span><br><span class="line">&#125;,</span><br><span class="line">以新行结束</span><br><span class="line">&quot;html.format.endWithNewline&quot;: false</span><br><span class="line"></span><br><span class="line">完整的 vue 相关用户设置如下</span><br><span class="line">&quot;files.exclude&quot;: &#123;</span><br><span class="line">    &quot;**&#x2F;.git&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.svn&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.hg&quot;: true,</span><br><span class="line">    &quot;**&#x2F;CVS&quot;: true,</span><br><span class="line">    &quot;**&#x2F;.DS_Store&quot;: true,</span><br><span class="line">    &quot;**&#x2F;node_modules&quot;: true,</span><br><span class="line">    &quot;**&#x2F;package-lock.json&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,</span><br><span class="line">&quot;editor.formatOnSave&quot;: true,</span><br><span class="line">&quot;prettier.semi&quot;: false,</span><br><span class="line">&quot;prettier.singleQuote&quot;: true,</span><br><span class="line">&quot;html.format.endWithNewline&quot;: true,</span><br><span class="line">&quot;eslint.validate&quot;: [</span><br><span class="line">    &quot;javascript&quot;,</span><br><span class="line">    &quot;javascriptreact&quot;,</span><br><span class="line">    &quot;html&quot;,</span><br><span class="line">    &quot;vue&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;language&quot;: &quot;html&quot;,</span><br><span class="line">        &quot;autoFix&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>vscode代码格式化：</p><ul><li>参考链接：<ul><li><a href="https://www.cnblogs.com/benbentu/p/9661998.html">https://www.cnblogs.com/benbentu/p/9661998.html</a></li><li><a href="https://www.jianshu.com/p/f15b67c94c78">https://www.jianshu.com/p/f15b67c94c78</a></li></ul></li></ul></li><li><p>关于编辑工具中的eslint插件和webpack安装的插件区别：</p><ul><li>webpack是静态模块打包器，是在编译时期按照规则校验用的，报错了会停止编译；vscode是提示给使用者看的，方便提示报错与修复。</li><li>参考链接：<a href="https://segmentfault.com/q/1010000015852118">https://segmentfault.com/q/1010000015852118</a></li></ul></li><li><p>关于babel</p><ul><li>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</li><li>配置文件：babel.config.js / .babelrc.js<ul><li>配置参数-plugins</li><li>配置参数-presets(一组Babel插件)</li></ul></li></ul></li><li><p>vscode插件列表：</p><table><thead><tr><th>名称</th><th>简述</th></tr></thead><tbody><tr><td>Auto Close Tag</td><td>自动闭合HTML标签</td></tr><tr><td>Auto Rename Tag</td><td>修改HTML标签时，自动修改匹配的标签</td></tr><tr><td>Auto Import</td><td>import提示</td></tr><tr><td>Beautify css/sass/scss/less</td><td>css/sass/less格式化 （个人装了Beautify、 Beautify css/sass/scss/less、vue-Beautify）需要使用配置文件</td></tr><tr><td>Chinese (Simplified) Language Pack for Visual Studio Code</td><td>设置中文包/配置中文语言</td></tr><tr><td>color info</td><td>小窗口显示颜色值，rgb,hsl,cmyk,hex等等</td></tr><tr><td>eslint</td><td>es语法检测工具，需要配置配置文件</td></tr><tr><td>editor config for vscode</td><td>editorconfig插件以及点editorconfig配置文件（统一代码风格工具）</td></tr><tr><td>git blame</td><td>在状态栏显示当前行的Git信息</td></tr><tr><td>git history</td><td>查看git log</td></tr><tr><td>HTML/js Snippets</td><td>快速代码模板(类似idea代码模板)</td></tr><tr><td>intelliSense for CSS class names in HTML</td><td>把项目中 css 文件里的名称智能提示在 html 中</td></tr><tr><td>Indenticator</td><td>缩进高亮</td></tr><tr><td>npm / npm Intellisense(智能感知)</td><td>导入模块时，提示已安装模块名称</td></tr><tr><td>Path Intellisense</td><td>另一个路径完成提示</td></tr><tr><td>vetur</td><td>目前比较好的Vue语法高亮</td></tr><tr><td>vscode-fileheader</td><td>自动生成头部注释 ctrl+alt+i(<strong>需要配置内容</strong>)</td></tr><tr><td>saas</td><td>==</td></tr><tr><td>vscode-icons</td><td>vscode 文件图标：文件=&gt;首先项=&gt;文件图标主题=&gt;选中VSCode Icons</td></tr></tbody></table><ul><li>参考链接：<a href="https://github.com/varHarrie/varharrie.github.io/issues/10">https://github.com/varHarrie/varharrie.github.io/issues/10</a></li><li>已使用的标签：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. Auto Close Tag</span><br><span class="line">2. Auto Import</span><br><span class="line">3. Auto Rename Tag</span><br><span class="line">4. Chinese (Simplified) Language Pack for Visual Studio Code</span><br><span class="line">5. VSCode Color Info</span><br><span class="line">6. VS Code ESLint extension</span><br><span class="line">7. Git Blame、Git History</span><br><span class="line">8. Indenticator</span><br><span class="line">9. koroFileHeader</span><br><span class="line">10. Manta&#39;s Stylus Supremacy</span><br><span class="line">11. Path Intellisense</span><br><span class="line">12. Prettier Formatter for Visual Studio Code</span><br><span class="line">13. vetur</span><br><span class="line">14. vscode-icons</span><br></pre></td></tr></table></figure></li></ul><h3 id="vscode使用"><a href="#vscode使用" class="headerlink" title="vscode使用"></a>vscode使用</h3><h4 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;workbench.editor.focusRecentEditorAfterClose&quot;: false,</span><br><span class="line"></span><br><span class="line">    &quot;terminal.external.osxExec&quot;: &quot;iTerm.app&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;editor.tabSize&quot;: 2,</span><br><span class="line">    &quot;editor.fontLigatures&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    &quot;vetur.validation.template&quot;: true,</span><br><span class="line">    &#x2F;&#x2F; 使用插件格式化 html</span><br><span class="line">    &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,</span><br><span class="line">    &#x2F;&#x2F; 格式化插件的配置</span><br><span class="line">    &quot;vetur.format.defaultFormatterOptions&quot;: &#123;</span><br><span class="line">        &quot;js-beautify-html&quot;: &#123;</span><br><span class="line">            &#x2F;&#x2F; 属性强制折行对齐</span><br><span class="line">            &quot;wrap_attributes&quot;: &quot;force-aligned&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files.associations&quot;: &#123;</span><br><span class="line">        &quot;*.vue&quot;: &quot;vue&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;emmet.syntaxProfiles&quot;: &#123;</span><br><span class="line">        &quot;vue-html&quot;: &quot;html&quot;,</span><br><span class="line">        &quot;vue&quot;: &quot;html&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;emmet.includeLanguages&quot;: &#123;</span><br><span class="line">        &quot;vue-html&quot;: &quot;html&quot;,</span><br><span class="line">        &quot;wxml&quot;: &quot;html&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;git.autofetch&quot;: true,</span><br><span class="line">    &quot;git.confirmSync&quot;: false,</span><br><span class="line">    &#x2F;&#x2F; 添加 vue 支持</span><br><span class="line">    &quot;eslint.validate&quot;: [</span><br><span class="line">        &quot;javascript&quot;,</span><br><span class="line">        &quot;javascriptreact&quot;,</span><br><span class="line">        &quot;html&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;language&quot;: &quot;vue&quot;,</span><br><span class="line">            &quot;autoFix&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;javascript.validate.enable&quot;: true,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;explorer.confirmDragAndDrop&quot;: true,</span><br><span class="line"></span><br><span class="line">    &quot;fileheader.Author&quot;: &quot;HISUN&quot;,</span><br><span class="line">    &quot;fileheader.LastModifiedBy&quot;: &quot;HISUN&quot;,</span><br><span class="line">    &quot;breadcrumbs.enabled&quot;: true,</span><br><span class="line"></span><br><span class="line">    &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,</span><br><span class="line">    &quot;javascript.implicitProjectConfig.experimentalDecorators&quot;: true,</span><br><span class="line"></span><br><span class="line">    &quot;html.format.indentInnerHtml&quot;: true,</span><br><span class="line">    &quot;html.format.endWithNewline&quot;: true,</span><br><span class="line">    &quot;html-css-class-completion.enableEmmetSupport&quot;: true,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 0,</span><br><span class="line">    &quot;[javascript]&quot;: &#123;</span><br><span class="line">        &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;files.autoSave&quot;: &quot;off&quot;,</span><br><span class="line">    &quot;workbench.sideBar.location&quot;: &quot;right&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;开发工具&quot;&gt;&lt;a href=&quot;#开发工具&quot; class=&quot;headerlink&quot; title=&quot;开发工具&quot;&gt;&lt;/a&gt;开发工具&lt;/h4&gt;&lt;p&gt;vscode &amp;amp; webstorm均可，这里使用了vscode&lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Vscode配置&amp;操作_TODO</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Vscode%E9%85%8D%E7%BD%AE&amp;%E6%93%8D%E4%BD%9C_TODO/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Vscode%E9%85%8D%E7%BD%AE&amp;%E6%93%8D%E4%BD%9C_TODO/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考链接</strong></p><p><a href="https://www.jianshu.com/p/fd945e8e099d">https://www.jianshu.com/p/fd945e8e099d</a></p><p><strong>配置步骤</strong></p><p>文件 》 设置 》 首选项：区分用户区和工作区</p><p><strong>插件安装</strong></p><p><strong>基础插件</strong></p><p>1、汉化包</p><p>插件：Chinese(Simplified) Language Pack for Visual Stidio Code 中文汉化包</p><p>配置：按快捷键Ctrl+Shift+P调出命令面板，输入Configure Display Language，选择zh-ch，然后重启vs code</p><p>2、Auto Close Tag 自动闭合标签</p><p>3、Auto Rename Tag 尾部闭合标签同步修改</p><p>4、Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号</p><p>5、Highlight Matching Tag 高亮显示匹配标签</p><p>6、Vscode-icons VSCode 文件图标</p><p>7、TODO Highlight 高亮</p><p>使用：输入TODO &amp; FIXME 文本</p><p>8、Code Spell Checker 单词拼写检查</p><p>9、Improt Cost 成本提示</p><p>说明：这个插件可以在你导入工具包的时候提示这个包的体积，如果体积过大就需要考虑压缩包，为后期上线优化做准备。</p><p>10、GitLens 查看Git信息</p><p>说明：将光标移到代码行上，即可显示当前行最近的commit信息和作者</p><p>11、Bookmarks 书签</p><p>说明：对代码进行书签标记，通过快捷键实现快速跳转到书签位置。</p><p>使用：</p><p>12、koroFileHeader</p><p><strong>配置：</strong>参考 <a href="https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE">https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE</a></p><p>// 文件头部注释  “fileheader.customMade”: {    “Descripttion”: “”,    “Author”: “yuye.huang”,    “Date”: “Do not edit”,    “LastEditors”: “yuye.huang”,    “LastEditTime”: “Do not Edit”  },  // 函数注释  “fileheader.cursorMode”: {    // “name”:””,    // “test”:”test font”,    “msg”: “”,    “param”: “”,    “return”: “”  },</p><p><strong>使用：</strong></p><p>文件头部添加注释:</p><p>window：ctrl+alt+i,mac：ctrl+cmd+i</p><p>在光标处添加函数注释:</p><p>window：ctrl+alt+t,mac：ctrl+cmd+t</p><p><strong>扩展插件</strong></p><p>1、Vscode-element-helper</p><p>说明：使用element-ui库的可以安装这个插件，编写标签时自动提示element标签名称。</p><p>2、Version Lens 工具包版本信息</p><p>说明：在package.json中显示你下载安装的npm工具包的版本信息，同时会告诉你当前包的最新版本。</p><p>3、Vetur VUE语言包</p><p>说明：Vetur对VUE提供了很好的语言支持，没有安装该插件之前之前编写后缀名为.vue的文件时代码是白色的</p><p>使用：安装插件后编写vue文件输入s，按Tab键就可以自动补全模版。</p><p>4、<strong>Settings Sync VSCode设置同步到Gist</strong></p><p>说明：有时候我们到了新公司或者换了新电脑需要配置新的开发环境，这时候一个一个下载插件，再重新配置vs code就非常麻烦而且你还不一定记得那么全面，通过这个插件我们可以将当前vs code中的配置上传到Gist，之后再通过Gist下载，就可以将所有配置同步到新环境中了。</p><p>使用：</p><ol><li>在Github首页点击头像，选择Settings进入设置页面。</li><li>点击左侧侧边栏Developer settings，</li><li>进入开发者设置。选择Personal access tokens，点击右侧Generate new token。</li><li>填写token名称，在下方勾选gist。</li><li>点击下方的Generate token按钮生成一个新的token。将生成的新的token保存下来。</li><li>在vscode中安装Settings Sync插件，输入Ctrl+Shift+p输入Sync，选择更新/上传配置。</li><li>将github中生成的token输入，点击回车。</li><li>在控制台中自动生成一串id,之后便可以通过token和id进行配置同步。</li><li>输入Ctrl+Shift+p输入Sync，选择下载配置，输入token和id即可同步下载。</li><li>可以在配置文件中选择是否自动上传和下载</li></ol><p><strong>常用配置</strong></p><p>1、关闭标签介绍信息（延时）</p><p>配置：”editor.hover.delay”: 5000,</p><p>2、自动折行</p><p>说明：设置代码根据编辑器窗口大小自动折行</p><p>配置：”editor.wordWrap”: “on”,</p><p>3、字体设置</p><p>配置：</p><p> // 一款适合代码显示的字体包（需要将字体包下载到本地）</p><p> “editor.fontFamily”: “Source Code Pro, ‘Source Code Pro’”,</p><p> // 设置代码字体大小</p><p> “editor.fontSize”: 15,</p><p>4、自动保存</p><p>配置：”files.autoSave”: “off”,</p><p>选项：</p><p>off：关闭自动保存。</p><p>afterDelay：当文件修改后的时间超过”Files：Auto Save Delay”中配置的值时自动进行保存。</p><p>onFocusChange：编辑器失去焦点时自动保存更新后的文件。</p><p>onWindowChange：窗口失去焦点时自动保存更新后的文件。</p><p>5、关闭代码提示</p><p>配置：”editor.quickSuggestions”: { “other”: false, “comments”: false, “strings”: false }</p><p>6、// 控制可以打开多个标签页</p><p>  “workbench.editor.enablePreview”: false,</p><p><strong>快捷键</strong></p><p><strong>编辑器与窗口管理</strong></p><p>Ctrl+Shift+P: 打开命令面板。</p><p>Ctrl+Shift+N: 新建窗口。</p><p>Ctrl+Shift+W: 关闭窗口。</p><p>切分窗口：Ctrl+1/Ctrl+3/Ctrl+3</p><p>Ctrl+H：最小化窗口</p><p>Ctrl+B：显示/隐藏侧边栏</p><p>Ctrl+”+/-“：放大/缩小界面</p><p><strong>文件操作</strong></p><p>Ctrl+N：新建文件</p><p>Ctrl+W：关闭文件</p><p>Ctrl+Tab：文件切换</p><p><strong>格式调整</strong></p><p>Ctrl+C/Ctrl+V：复制或剪切当前行/当前选中内容</p><p>Alt+Up/Down：向上/下移动一行</p><p>Shift+Alt+Up//Down：向上/下复制一行</p><p>Ctrl+Delete：删除当前行</p><p>Shift+Alt+Left/Right：从光标开始向左/右选择内容</p><p><strong>代码编辑</strong></p><p>Ctrl+D：选中下一个相同内容</p><p>Ctrl+Shift+L：选中所有相同内容</p><p>Ctrl+F：查找内容</p><p>Ctrl+Shit+F：在整个文件夹中查找内容</p><p><strong>不同语言环境配置</strong></p><p><strong>vue</strong></p><p>参考链接：</p><p><a href="https://segmentfault.com/a/1190000014796012">https://segmentfault.com/a/1190000014796012</a></p><p><a href="https://www.cnblogs.com/benbentu/p/9661998.html">https://www.cnblogs.com/benbentu/p/9661998.html</a></p><p><a href="https://www.jianshu.com/p/f15b67c94c78">https://www.jianshu.com/p/f15b67c94c78</a></p><p><a href="https://blog.csdn.net/userkang/article/details/84302629">https://blog.csdn.net/userkang/article/details/84302629</a></p><p>配置文件：</p><p>- Vetur : 语法高亮等功能 - ESlint : 代码风格检测 - Prettier formatter <strong>for</strong> Visual Studio Code: 为了配合 ESlint vue 的模板格式化： “vetur.format.defaultFormatter.html”:”js-beautify-html” vue 模板的 eslint 校验    “eslint.validate”: [        “javascript”,        “javascriptreact”,        “html”,        “vue”,        {            “language”: “html”,            “autoFix”: <strong>true</strong>        }    ] Prettier 设置去除不必要空格：”prettier.semi”: <strong>false</strong> Prettier 设置格式化后”变’：”prettier.singleQuote”: true 在 vscode 中排除 node_modules 等文件夹： “files.<strong>exclude</strong>“: {    “<strong>/.git”: true,    “</strong>/.svn”: true,    “<strong>/.hg”: true,    “</strong>/CVS”: true,    “<strong>/.DS_Store”: true,    “</strong>/node_modules”: true,    “<strong>/package-<strong>lock</strong>.json”: true, }, 以新行结束 “html.<strong>format</strong>.endWithNewline”: false 完整的 vue 相关用户设置如下 “files.<strong>exclude</strong>“: {    “</strong>/.git”: true,    “<strong>/.svn”: true,    “</strong>/.hg”: true,    “<strong>/CVS”: true,    “</strong>/.DS_Store”: true,    “<strong>/node_modules”: true,    “</strong>/package-<strong>lock</strong>.json”: true }, “vetur.<strong>format</strong>.defaultFormatter.html”: “js-beautify-html”, “editor.formatOnSave”: true, “prettier.semi”: false, “prettier.singleQuote”: true, “html.<strong>format</strong>.endWithNewline”: true, “eslint.<strong>validate</strong>“: [    “javascript”,    “javascriptreact”,    “html”,    “vue”,    {        “<strong>language</strong>“: “html”,        “autoFix”: true    } ]</p><p><strong>小程序</strong></p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/4b849843c3b9">https://www.jianshu.com/p/4b849843c3b9</a></p><p>安装插件：</p><p>1、minapp</p><p>2、wechat-snippet</p><p>3、wxml</p><p>4、wechat-snippet</p><p><strong>Wepy</strong></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/cisum/p/9852571.html">https://www.cnblogs.com/cisum/p/9852571.html</a></p><p>安装插件Vetur后打开.wpy文件，在右下角点击“纯文本”选择”.wpy的配置文件关联”选择”Vue”后，语法变为高亮： <strong>files.associations</strong></p><p>// 配置语言的文件关联(如: “*.extension”: “html”)。这些关联的优先级高于已安装语言的默认关联。</p><p>“files.associations”: {</p><p>​    “*.vue”: “vue”,</p><p>​    “*.wpy”: “vue”,</p><p>​    “*.wxss”: “postcss”,</p><p>​    “*.tpl”: “vue”,</p><p>​    “*.md@xxx”: “markdown”,</p><p>​    “*.wepy”: “vue”,</p><p>​    “*.cjson”: “jsonc”,</p><p>​    “*.wxs”: “javascript”</p><p>  },</p><p>// 添加emmet语法支持 wxml 文件(当然也可以配置支持vue文件)</p><p>“emmet.includeLanguages”: {</p><p>​    “wxml”: “html”</p><p>  },</p><p>  // “emmet.syntaxProfiles”: {</p><p>  //   “vue-html”: “html”,</p><p>  //   “vue”: “html”</p><p>  // },</p><p>“minapp-vscode.disableAutoConfig”: true,</p><p><strong>格式化插件</strong></p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/e73f1b429788?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation"><strong>https://www.jianshu.com/p/e73f1b429788?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</strong></a></p><p><a href="https://blog.csdn.net/weixin_34413065/article/details/86133692">https://blog.csdn.net/weixin_34413065/article/details/86133692</a></p><p><strong>wpy的文件都是用vue的高亮规则：</strong></p><p>“files.associations”: {</p><p>​        “*.vue”: “vue”,</p><p>​        “*.wpy”: “vue”,</p><p>​        “*.wxml”: “html”,</p><p>​        “*.wxss”: “css”</p><p>​    },</p><p>​    “emmet.syntaxProfiles”: {</p><p>​        “vue-html”: “html”,</p><p>​        “vue”: “html”</p><p>​    },</p><p>**wpy-beautify &amp; vetur语法高亮 &amp;**<strong>vscode-wxml 语法支持及代码片段</strong></p><p><strong>vetur：</strong></p><p>说明：插件的使用需要修改下vs-code对于文件格式的判断才能使用不同的插件，点击文件右下角可以修改文件格式并应用于所有该格式的文件</p><p>wpy-beautify插件配置：</p><p>wpy-beautify插件使用：</p><p>{</p><p>​      “key”: “ctrl+shift+6”,          </p><p>​      “command”: “wpyBeautify.format”,</p><p>​      “when”: “editorTextFocus &amp;&amp; !editorReadonly” </p><p>​    }</p><p><strong>最新配置</strong></p><p><strong>用户空间</strong></p><p>{</p><p>  “editor.fontSize”: 12,</p><p>  // 一个制表符等于的空格数。该设置在 <code>editor.detectIndentation</code> 启用时根据文件内容进行重写。</p><p>  “editor.tabSize”: 2,</p><p>  // 自动保存</p><p>  “files.autoSave”: “off”,</p><p>  // 控制编辑器是否应呈现缩进参考线</p><p>  “editor.renderIndentGuides”: true,</p><p>  // 当打开文件时，将基于文件内容检测 “editor.tabSize” 和 “editor.insertSpaces”。</p><p>  “editor.detectIndentation”: false,</p><p>  “window.zoomLevel”: 1,</p><p>  “editor.wordWrap”: “on”,</p><p>  “workbench.iconTheme”: “vscode-icons”,</p><p>  “editor.wordSeparators”: “`~!@#$%^&amp;*()=+[{]}\|;:’&quot;,.&lt;&gt;/?。”,</p><p>  “editor.minimap.enabled”: true,</p><p>  // 配置 glob 模式以排除文件和文件夹。</p><p>  “files.exclude”: {</p><p>​    “**/.git”: true,</p><p>​    “**/.svn”: true,</p><p>​    “**/.hg”: true,</p><p>​    “**/CVS”: true,</p><p>​    “**/.DS_Store”: true,</p><p>​    “**/.DS_Store”: true,</p><p>​    // “**/node_modules”: true,</p><p>​    “**/bower_components”: true</p><p>​    // “**/dist”: true</p><p>  },</p><p>  // 配置语言的文件关联(如: “*.extension”: “html”)。这些关联的优先级高于已安装语言的默认关联。</p><p>  “files.associations”: {</p><p>​      “*.vue”: “vue”,</p><p>​      “*.wpy”: “vue”,</p><p>​      “*.wxss”: “postcss”,</p><p>​      “*.tpl”: “vue”,</p><p>​      “*.md@xxx”: “markdown”,</p><p>​      “*.wepy”: “vue”</p><p>  },</p><p>  // 关闭代码提示 // 控制键入时是否应自动显示建议</p><p>  “editor.quickSuggestions”: {</p><p>​    “other”: true,</p><p>​    “comments”: true,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fd945e8e099d&quot;&gt;https://www.jianshu.com/p/fd945e8e099d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows终端</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Windows%E7%BB%88%E7%AB%AF/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/Windows%E7%BB%88%E7%AB%AF/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/pi31415926535x/article/details/108331325">解决PowerShell 安装oh-my-posh很慢</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;</span><br><span class="line">notepad $PROFILE</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Import Modules</span><br><span class="line">Import-Module posh-git</span><br><span class="line">Import-Module oh-my-posh</span><br><span class="line"></span><br><span class="line"># Set Theme (Agnoster</span><br><span class="line">Set-Theme Paradox</span><br><span class="line"></span><br><span class="line"># Set MenuComplete</span><br><span class="line">Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/pi31415926535x/article/details/108331325&quot;&gt;解决PowerShell 安装oh-my-posh很慢&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight pl</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>新电脑重装_TODO</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E6%96%B0%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85_TODO/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E6%96%B0%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85_TODO/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统重装-amp-重置"><a href="#系统重装-amp-重置" class="headerlink" title="系统重装&amp;重置"></a>系统重装&amp;重置</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>目的相同：修复系统某些问题</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><table><thead><tr><th>//</th><th>重装</th><th>重置</th></tr></thead><tbody><tr><td>可保留性</td><td>完全的安装一个新的系统</td><td>在原有的系统上进行还原；重置系统可以有选择性的还原系统，用户可以选择是否保留个人文件以及资料</td></tr><tr><td>密匙变更</td><td>正版系统的话是有相应的激活密匙的，如果重装系统的话相应的密匙就会丢失，我们无法再重新安装成正版的系统；在重装系统之前建议将的密匙拷贝出来，然后进行系统的重装</td><td>-</td></tr><tr><td>更新的保留性</td><td>所有的更新将会丢失，版本也会下降</td><td>-</td></tr></tbody></table><h2 id="重置步骤"><a href="#重置步骤" class="headerlink" title="重置步骤"></a>重置步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 打开屏幕下方的“通知”按钮或者通过开始屏幕，进入电脑的设置页面。</span><br><span class="line">2. 在设置页面里，找到“更新与安全”按钮，点击后进入更新与安全页面。</span><br><span class="line">3. 点击“恢复”按钮，然后找到重置c此电脑，点击“开始”按钮。</span><br><span class="line">4.跳出两个选项，第一个是“保留我的文件”，第二个是“删除所有内容”。若想重置后的系统更加纯净，可以选择“删除所有内容”。</span><br><span class="line">5. 然后稍等一会儿，会跳出下面的页面，提示您的电脑有多个驱动器，然后问你是“要删除所有驱动器中的文件吗？”建议大家选择“仅限安装了windows的驱动器，这样只对系统盘处理，否则将对所有盘格式化处理，那样您会失去所有的文件。</span><br><span class="line">6. 接着跳出页面“还要清理这些驱动器吗？”建议大家选择第二项“删除文件并清理驱动器”，这样更安全，不过要花费更多的时间。</span><br></pre></td></tr></table></figure><p>参考连接： <a href="https://jingyan.baidu.com/article/22a299b539f9b19e18376a58.html">https://jingyan.baidu.com/article/22a299b539f9b19e18376a58.html</a></p><h2 id="重装步骤"><a href="#重装步骤" class="headerlink" title="重装步骤"></a>重装步骤</h2><p>在重装之前，查出预装的正版序列号，然后下载到相同版本的系统和软件，重装，输入序列号即可（大部分情况不用输入）。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>查看系统版本</li><li>查看Win10序列号</li><li>查看Office版本<ul><li>打开控制面板——程序和功能</li></ul></li><li>下载Win10制作启动U盘，重装系统</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/92ccdc138b46">https://www.jianshu.com/p/92ccdc138b46</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>windows查询序列号步骤：<ul><li>win + R -&gt; 输入 powershell</li><li>输入命令：(Get-WmiObject -query ‘select * from SoftwareLicensingService’).OA3xOriginalProductKey</li></ul></li><li>序列号：2NPVV-Q6VJF-TYPK3-6933X-HCFJX</li></ul><p><strong>win10装机教程</strong></p><p><a href="http://iknow.lenovo.com.cn/detail/dc_177365.html">http://iknow.lenovo.com.cn/detail/dc_177365.html</a></p><p><a href="https://www.zhihu.com/question/54059979/answer/1218337202">https://www.zhihu.com/question/54059979/answer/1218337202</a></p><p><strong>名词</strong></p><ol><li>ghost [ gəust ] 镜像</li></ol><p>何为ghost？：ghost，原意为幽灵。是一个封装镜像文件。简单来说就是把官方的正版纯净系统通过相关软件处理制作加入一些集成的最新驱动和一些最新的常用软件最后形成一个.GHO文件。然后你再把那个.GHO文件拿过来，克隆到你的电脑上。</p><p><strong>优点</strong>：安装速度快，而且驱动集成，一般情况下无需单独安装硬件驱动</p><p><strong>原版软件</strong></p><p><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p><p><strong>保留正版信息</strong></p><p><a href="https://zhuanlan.zhihu.com/p/24832281">https://zhuanlan.zhihu.com/p/24832281</a></p><p><strong>开始重装—制作系统启动盘</strong></p><p><strong>方式一</strong></p><p>1、U盘一只（单系统的话建议8G或以上大小）；</p><p>2、原版iso镜像文件一个（下载地址搜索：msdn,我告诉你)，找到你所需要的系统；</p><p>3、U盘启动项辅助软件（搜索UltraISO，中文名：软碟通)。</p><p><a href="http://power.zol.com.cn/542/5425545.html">http://power.zol.com.cn/542/5425545.html</a></p><p>把写入好系统的U盘插入主板原生2.0接口后，重启计算机，设置设置主板的开机启动项为USB。</p><p><strong>新系统-驱动安装</strong></p><p>一般安装完新的操作系统后，我们都要下载一些驱动来保证电脑的正常运行，建议从官网上下载官方驱动，而不是使用驱动精灵。</p><p>显卡、声卡、网卡（有线、无线）、蓝牙、显示器、USB3.0，打印机扫描仪，鼠标与触控板、上网卡</p><p><strong>驱动工作原理</strong></p><p>驱动程序，英文名为“Device Driver”，du全称为“设备驱动程序”， 是一种可以使计算机和设备通信的特殊程序，可以 说相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统重装-amp-重置&quot;&gt;&lt;a href=&quot;#系统重装-amp-重置&quot; class=&quot;headerlink&quot; title=&quot;系统重装&amp;amp;重置&quot;&gt;&lt;/a&gt;系统重装&amp;amp;重置&lt;/h2&gt;&lt;h3 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑环境准备</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E7%94%B5%E8%84%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="电脑环境准备"><a href="#电脑环境准备" class="headerlink" title="电脑环境准备"></a>电脑环境准备</h2><h3 id="OS-下载与激活"><a href="#OS-下载与激活" class="headerlink" title="OS 下载与激活"></a>OS 下载与激活</h3><ul><li><p>镜像下载</p><ul><li><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></li></ul></li><li><p>系统激活</p></li><li><p>windows 关闭自动更新</p></li></ul><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><ul><li><p>JDK配置(x64)</p><ul><li><p>官网下载地址：</p><ul><li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li></ul></li><li><p>配置环境变量</p><ul><li>配置java_home环境变量以及输出对应bin路径到class_path</li></ul></li></ul></li><li><p>maven配置</p><ul><li>下载maven：<ul><li><a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a></li></ul></li><li> 配置环境变量</li><li> 配置maven_home环境变量以及输出对应bin路径到class_path</li><li>配置settings.xml &amp; 配置本地仓库</li></ul></li><li><p>git配置</p><ul><li>密钥重新生成：<code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></li><li> 查看公钥：<code>cat ~\.ssh\id_rsa.pub</code></li><li> <a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">配置命令别名</a></li></ul></li><li><p>hyper-v 启用 &amp; docker for window 安装</p><ul><li><p>开启hyper-v模式，安装并启动docker后，即可在cmd命令行使用docker</p></li><li><p>配置docker国内镜像，或自己的加速地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;docker&#x2F;daemon.json </span><br><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line"># 镜像仓库地址：</span><br><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;undefined&#x2F;instances&#x2F;mirrors</span><br><span class="line">https:&#x2F;&#x2F;registry.docker-cn.com</span><br><span class="line">#Docker中国区 http:&#x2F;&#x2F;hub-mirror.c.163.com　　　　　　</span><br><span class="line">#网易 https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn  </span><br><span class="line">#USTC http:&#x2F;&#x2F;dockerhub.azk8s.cn&#x2F; </span><br><span class="line">#Azure </span><br></pre></td></tr></table></figure></li></ul></li><li><p>nodejs &amp; npm &amp; yarn &amp; webpack</p><ul><li><p>npm &amp; nvm</p></li><li><p><a href="https://blog.csdn.net/sxs7970/article/details/89357096">nvm setup 安装</a></p><ul><li><p><code>NVM_HOME</code> &amp; <code>NVM_SYMLINK</code> (nodejs路径) 变量配置，并配置到path</p></li><li><p>node国内镜像配置：</p><ul><li><p>nvm的安装路径下找到settings.txt(如果没有，可新建一个)</p></li><li><p>编辑settings.txt，添加下列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_mirror:npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F; npm_mirror:npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>安裝cnpm（国产npm） </p></li><li><p>安裝yarn（包管理工具） npm install -g yarn –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> </p><ul><li><p>配置下软件包源 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure></li><li><p>yarn 命令报错：<code>无法加载文件 D:\nodejs\node_global\webpack.ps1，因为在此系统上禁止运行脚本</code> 参考链接：<a href="https://blog.csdn.net/zlq_CSDN/article/details/102789989">https://blog.csdn.net/zlq_CSDN/article/details/102789989</a></p></li></ul></li></ul></li></ul></li><li><p>搜狗输入法准备</p></li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><p>idea配置 cmder/git 终端</p><ul><li><strong>seetings -&gt; Tools -&gt; Shell path</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以cmder为例</span><br><span class="line">cmd.exe&quot; &#x2F;k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot; </span><br></pre></td></tr></table></figure></li><li><p>vscode配置：</p><ul><li><p>配置cmder 终端：</p></li><li><p>安装插件</p></li><li><p>代码风格检查与格式化 </p></li></ul><p><a href="https://juejin.im/post/5cbfde7c5188250a7d6ddcd1">https://juejin.im/post/5cbfde7c5188250a7d6ddcd1</a></p><ul><li>wepy项目配置文件关联及不进行标签校验</li></ul></li><li><p>接口测试工具</p><ul><li>postman （在线postwomen亦可）</li><li>jmeter</li></ul></li><li><p>Moboxterm：全能终端神器（XShell &amp; XFtp 家庭版）</p></li><li><p>抓包工具 charles （或fiddler）</p></li></ul><h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><ul><li>普通办公软件<ul><li>有道云笔记</li><li>Tim、钉钉    </li><li>google浏览器 / Microsoft Edge</li></ul></li><li>cmder命令行工具（集成git）<ul><li><strong>添加cmder到右键菜单：</strong><ul><li>Cmder.exe /REGISTER ALL</li></ul></li><li>修改cmder的命令符为 $<ul><li>cd %CMDER_HOME%\vender vim click.lua # 找到  local lambda = “λ” 将lamda符号修改成 $</li></ul></li><li>设置启动目录：setting -&gt; Startup - &gt; Task，修改{cmd::Cmder}项<ul><li>cmd /k “%ConEmuDir%..\init.bat” -new_console:d:C:\</li></ul></li><li>安装wget for window，并配置环境变量，可使用wget命令</li><li>参考链接<ul><li><a href="https://www.jianshu.com/p/5b7c985240a7">https://www.jianshu.com/p/5b7c985240a7</a></li><li> <a href="https://www.jianshu.com/p/979db1a96f6d">https://www.jianshu.com/p/979db1a96f6d</a></li></ul></li></ul></li><li>7z：压缩工具</li><li>iobot uninstaller：软件清理工具</li><li>ditto：剪贴板</li><li>everything：文件名搜索工具（同 listary File Search &amp; App Launcher）</li><li>chocolately：包管理工具</li><li>spacesniffer：磁盘空间分析工具)</li><li>xbox</li><li>steam</li></ul><h3 id="环境软件快速运行方式"><a href="#环境软件快速运行方式" class="headerlink" title="环境软件快速运行方式"></a>环境软件快速运行方式</h3><p><strong>当前配置可选，可以使用类似listray的软件</strong></p><p>给已安装的软件配置快捷方式（软连接），并统一放置在同一文件夹，配置系统环境变量 Path，通过 win键 + R 输入 软件文件名即可快速打开软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 首先，在某个地方新建一个文件夹，比如我的D:\ApplicationFiles\Portable\WIN_R_shortCuts</span><br><span class="line">2. 然后，将这个路径加入到path中</span><br><span class="line">3. 最后，将你需要的快捷方式放置到这个文件夹中，然后修改为你方便记忆与输入的名字</span><br><span class="line">4.  Win + R 输入步骤3命名的名字，就可以运行了</span><br></pre></td></tr></table></figure><h3 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;电脑环境准备&quot;&gt;&lt;a href=&quot;#电脑环境准备&quot; class=&quot;headerlink&quot; title=&quot;电脑环境准备&quot;&gt;&lt;/a&gt;电脑环境准备&lt;/h2&gt;&lt;h3 id=&quot;OS-下载与激活&quot;&gt;&lt;a href=&quot;#OS-下载与激活&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>电脑资源清单</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E7%94%B5%E8%84%91%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/%E7%94%B5%E8%84%91%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘空间占用分析工具"><a href="#磁盘空间占用分析工具" class="headerlink" title="磁盘空间占用分析工具"></a>磁盘空间占用分析工具</h2><p>spacesniffer（空间嗅探器）</p><h3 id="大文件清单"><a href="#大文件清单" class="headerlink" title="大文件清单"></a>大文件清单</h3><ol><li>C:\pagefile.sys：11.1GB (虚拟内存文件，内存不够时会将数据放到该文件，可以考虑迁移到其他盘符)</li><li>C:\hiberfil.sys：6.3GB</li><li>~\AppData\Local</li></ol><h2 id="中转清单"><a href="#中转清单" class="headerlink" title="中转清单"></a>中转清单</h2><p><a href="https://www.bilibili.com/video/BV137411K7V1/?spm_id_from=333.788.recommend_more_video.-1">这十个软件,让你的电脑舒适度提升1400%</a></p><ol><li><p>cleanmypc 清理垃圾</p></li><li><p>geek 卸载软件</p></li><li><p>utools 小型应用市场</p></li><li><p>spacesniffer 磁盘空间占用分析工具</p></li><li><p>geek uninstaller 软件卸载</p></li><li><p>Edge 浏览器</p></li><li><p>播放器：PotPlayer</p></li><li><p>notepads</p></li><li><p>杀毒：火绒</p></li><li><p>桌面整理.exe</p></li><li><p>软件下载器：腾讯软件管家、uTools（百宝箱）</p></li><li><p>万彩办公大师</p></li><li><p>截图工具</p><ol><li>snipaste </li><li>shareX</li><li>tim 屏幕录制，截图等</li></ol></li><li><p>图片查看工具：honey view</p></li><li><p>下载器：IDM、NDM</p></li><li><p>搜狗输入法</p></li><li><p>剪贴板：ditto</p></li><li><p>RST（硬盘优化）</p></li></ol><h2 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h2><p><a href="https://www.bilibili.com/video/BV1TN411d7FL/?spm_id_from=333.788.recommend_more_video.3">99%的人不知道这些网站，能帮你找到所有想要资源！！！</a></p><p>一、资源导航网站<br>1、书享家（电子书资源网站导航）：<a href="http://shuxiangjia.cn/">http://shuxiangjia.cn/</a><br>2、学吧导航（自学资源网站导航）：<a href="https://www.xue8nav.com/">https://www.xue8nav.com/</a><br>3、科塔学术（学术资源网站导航）：<a href="https://site.sciping.com/">https://site.sciping.com/</a><br>4、HiPPTer（PPT资源网站导航）：<a href="http://www.hippter.com/">http://www.hippter.com/</a><br>5、Seeseed（设计素材资源导航）：<a href="https://www.seeseed.com/">https://www.seeseed.com/</a></p><p>二、工具导航网站<br>1、阿猫阿狗导航（互联网工具导航）：<a href="https://dh.woshipm.com/">https://dh.woshipm.com/</a><br>2、创造狮（互联网工具导航）：<a href="http://chuangzaoshi.com/index">http://chuangzaoshi.com/index</a><br>3、addog（广告营销工具导航）：<a href="https://www.addog.vip/">https://www.addog.vip/</a><br>4、199it（数据导航）：<a href="http://hao.199it.com/">http://hao.199it.com/</a><br>5、雪球导航（财经工具导航）：<a href="https://xueqiu.com/dh">https://xueqiu.com/dh</a><br>6、打假导航（国家部门导航）：<a href="http://www.dajiadaohang.com/">http://www.dajiadaohang.com/</a><br>7、搜狗网址导航（地方部门导航）：<a href="http://123.sogou.com/diqu/">http://123.sogou.com/diqu/</a></p><p>三、聚合搜索平台<br>1、一个开始：<a href="https://aur.one/">https://aur.one</a><br>2、虫部落：<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p><h2 id="电脑壁纸"><a href="#电脑壁纸" class="headerlink" title="电脑壁纸"></a>电脑壁纸</h2><ol><li><p>wallpaper engine （对标 火萤、upupoo）</p><ul><li>steam（游戏工厂）下载</li></ul></li><li><p>雨滴桌面</p></li></ol><ul><li>链接<ul><li><a href="https://zhuanlan.zhihu.com/p/48499093">https://zhuanlan.zhihu.com/p/48499093</a></li><li><a href="https://bbs.rainmeter.cn/">https://bbs.rainmeter.cn/</a></li></ul></li><li>定制桌面，也可以整理桌面（可安装dock插件）：</li><li>RocketDock : 简化任务栏</li></ul><ol start="3"><li>桌面专业整理工具：fences</li></ol><ul><li>（对标腾讯桌面整理、蜂窝桌面整理）</li><li>steam 收费下载</li></ul><ol start="4"><li>透明任务栏:打开windows商店搜索translucentTB（可对标RocketDock）</li></ol><ul><li>TranslucentTB汉化版软件 链接：<a href="https://pan.baidu.com/s/1B7_yNt1NuGteK93BXay8jg">https://pan.baidu.com/s/1B7_yNt1NuGteK93BXay8jg</a> 提取码：2fe1</li></ul><ol start="5"><li>致美化<ul><li>素材网站</li></ul></li><li>屏保<ol><li>Fliqlo：<a href="https://www.screensaversplanet.com/screensavers/fliqlo-flip-clock-314/">https://www.screensaversplanet.com/screensavers/fliqlo-flip-clock-314/</a></li></ol></li></ol><p>RocketDock下载链接：<a href="https://share.weiyun.com/5m8MbTX">https://share.weiyun.com/5m8MbTX</a> 密码：53ppwy<br>TranslucentTB下载链接：<a href="https://share.weiyun.com/5kire7w">https://share.weiyun.com/5kire7w</a> 密码：f8qasr<br>StartIsBack下载链接：<a href="https://share.weiyun.com/5FHacKV">https://share.weiyun.com/5FHacKV</a> 密码：sqmuid<br>我的世界鼠标指针下载链接：<a href="https://share.weiyun.com/5am70hU">https://share.weiyun.com/5am70hU</a> 密码：9kf88e</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://www.deepin.org/zh/">deepin OS</a></p><h2 id="电脑跑分"><a href="#电脑跑分" class="headerlink" title="电脑跑分"></a>电脑跑分</h2><p>MSI afterburner（官网下载）：<a href="http://download-cn.msi.com/uti_exe/vga/MSIAfterburnerSetup.zip">http://download-cn.msi.com/uti_exe/vga/MSIAfterburnerSetup.zip</a></p><p>Aida64（官网试用版，有功能限制）：<a href="http://download.aida64.com/aida64extreme620.exe">http://download.aida64.com/aida64extreme620.exe</a></p><p>Aida64（网络绿色版）：<a href="http://cr2.197946.com/aida64extreme_build_5157_xbnj9z3mdy.zip">http://cr2.197946.com/aida64extreme_build_5157_xbnj9z3mdy.zip</a></p><p>AS SSD （官网英文版）：<a href="https://www.alex-is.de/PHP/fusion/downloads.php?cat_id=4&amp;file_id=9">https://www.alex-is.de/PHP/fusion/downloads.php?cat_id=4&amp;file_id=9</a><br>AS SSD （网络汉化版）：<a href="http://forspeed.onlinedown.net/down/newdown/3/12/AS%20SSD%20Benchmark%202.0.7316.34247.zip">http://forspeed.onlinedown.net/down/newdown/3/12/AS%20SSD%20Benchmark%202.0.7316.34247.zip</a></p><p>Crystal DiskMark（官网下载）：<a href="https://zh.osdn.net/frs/redir.php?m=xtom_us&amp;f=crystaldiskmark/71859/CrystalDiskMark7_0_0hShizuku.zip">https://zh.osdn.net/frs/redir.php?m=xtom_us&amp;f=crystaldiskmark%2F71859%2FCrystalDiskMark7_0_0hShizuku.zip</a></p><p>HD tune Pro（官网15天试用版）：<a href="http://www.hdtune.com/files/hdtunepro_575_trial.exe">http://www.hdtune.com/files/hdtunepro_575_trial.exe</a></p><p>3D Mark（官网）：<a href="https://www.3dmark.com/">https://www.3dmark.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515165046.png" alt="4CCE17F8-B3F5-470e-909E-1D31CCD81241"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;磁盘空间占用分析工具&quot;&gt;&lt;a href=&quot;#磁盘空间占用分析工具&quot; class=&quot;headerlink&quot; title=&quot;磁盘空间占用分析工具&quot;&gt;&lt;/a&gt;磁盘空间占用分析工具&lt;/h2&gt;&lt;p&gt;spacesniffer（空间嗅探器）&lt;/p&gt;
&lt;h3 id=&quot;大文件清单&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="windows工具" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/windows%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>项目图片引用</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%89%8D%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目图片引用"><a href="#项目图片引用" class="headerlink" title="项目图片引用"></a>项目图片引用</h2><ol><li>阿里巴巴矢量图（iconfont字体图标）<ol><li>上传图标到矢量库</li><li>项目中引用：@font-face {}</li><li>根据矢量库图标对应编号使用字体图标</li></ol></li><li>svg图片<ol><li>Scalable Vector Graphics，意思为可缩放的矢量图形</li><li>使用 XML 格式定义图形：用文本工具打开svg图片时内容为xml格式</li><li>在放大或改变尺寸的情况下其图形质量不会有所损失</li><li><strong>svg图片格式可上传到阿里巴巴矢量库</strong>：<ol><li>下载原文件 图标制作模板.AI -&gt;  设置图标大小 -&gt; 存储为svg格式（建议使用存储为svg，不要使用导出为svg）-&gt; 上传图标到阿里矢量库 -&gt; 命名图标及定义图标标签，完成上传</li><li><a href="https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d1c73b2de&amp;helptype=draw&amp;step=">https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d1c73b2de&amp;helptype=draw&amp;step=</a></li></ol></li></ol></li></ol><h2 id="什么是域名收敛"><a href="#什么是域名收敛" class="headerlink" title="什么是域名收敛"></a>什么是域名收敛</h2><p>PC 时代为了突破浏览器的域名并发限制。有了域名发散。浏览器有并发限制，是为了防止DDOS攻击。</p><p>域名收敛：将静态资源放在一个域名下。减少DNS解析的开销。</p><p>域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。</p><p>域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目图片引用&quot;&gt;&lt;a href=&quot;#项目图片引用&quot; class=&quot;headerlink&quot; title=&quot;项目图片引用&quot;&gt;&lt;/a&gt;项目图片引用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阿里巴巴矢量图（iconfont字体图标）&lt;ol&gt;
&lt;li&gt;上传图标到矢量库&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="前端" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>互联网协议</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="互联网背景"><a href="#互联网背景" class="headerlink" title="互联网背景"></a>互联网背景</h2><p>我们每天都在使用互联网上网冲浪，而网站的资源是部署在另台机器上的，那么处于两地的主机是如何通信的呢？</p><p>互联网的核心是一系列协议，总称为“互联网协议”。他们对电脑如何连接和组网，做出了详尽的规定。主机之间通信的时候，正是因为都遵从了这一系列协议，消息才正常从一方送达至另一方，且正确的理解对方发送消息的含义。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="互联网分层模型"><a href="#互联网分层模型" class="headerlink" title="互联网分层模型"></a>互联网分层模型</h2><p>互联网的实现分为很多层级，用户接触到的，只是最上面一层，如在主机上使用的桌面应用，浏览器网站，每次简单的界面操作，实际涉及到消息从最上一层一直逐层传递到最底层。</p><p>分层模型有多种，较容易理解的是五层模型，由上至下分为以下层级：</p><ol><li>应用层（用户接触的）</li><li>传输层</li><li>网络层</li><li>链接层</li><li>实体层</li></ol><p>每一层都是为完成某种功能，而为实现这些功能，就需要共同遵从各层的规则，大家都遵从的规则，就叫做协议。</p><h2 id="实体层"><a href="#实体层" class="headerlink" title="实体层"></a>实体层</h2><p>电脑要组网，首先要将电脑连接起来（光缆、电缆、无线电波等方式）。这个层级的内容称为“实体层“，它是把电脑连接起来的物理手段。这一层级主要规定了网络的一些电气特征（描述电流、电压等），作用是负责传送0/1的电信号。</p><h2 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h2><h3 id="链接层的定义"><a href="#链接层的定义" class="headerlink" title="链接层的定义"></a>链接层的定义</h3><p>单纯的0/1电信号没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p>链接层的功能就是为了确定电信号0和1的分组方式。</p><h3 id="链接层之以太网协议"><a href="#链接层之以太网协议" class="headerlink" title="链接层之以太网协议"></a>链接层之以太网协议</h3><p>以太网协议是其中一种，也是最主流的电信号分组方式。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3 id="链接层之MAC地址"><a href="#链接层之MAC地址" class="headerlink" title="链接层之MAC地址"></a>链接层之MAC地址</h3><p>发送者、接收者的标识：<strong>MAC地址</strong></p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>MAC地址：machine access control </p><p>长度是12个十六进制数，即48个二进制位(2^4)</p><h3 id="链接层之广播"><a href="#链接层之广播" class="headerlink" title="链接层之广播"></a>链接层之广播</h3><p>假设以太网数据包已经知道了接收方的mac地址。获取方式见详见ARP协议</p><p>以太网使用一种广播的方式，向本网络内所有 计算机发送数据包，让每台计算机判断是否为接收方，若为接收方则处理数据包，否则丢弃。</p><p>判断是否为接收方的方式是对比数据包的标头中包含的目标mac地址是否与自身的mac地址相同</p><h3 id="链接层之ARP协议"><a href="#链接层之ARP协议" class="headerlink" title="链接层之ARP协议"></a>链接层之ARP协议</h3><p>（<code>Address Resolution Protocol</code>）ARP寻址是用在数据链路层上的。我们上网的电脑都有网卡。那么在数据链路层的进行传递的时候，是没有IP的概念，都是通过找到对端设备的硬件地址，也就是网卡地址来做传输。这个硬件地址标准称为MAC地址。寻找对方MAC地址的过程就是ARP寻址。</p><p>示例：局域网内，从192.168.0.5来ping下192.168.0.8。得到交互流程如下。</p><p>1 首先是一个ARP广播报文，由192.168.0.5发出，可以看到带的广播报文是who has 192.168.0.8 tell 192.168.0.5 （目标<code>MAC地址</code>是<code>FF-FF-FF-FF-FF-FF</code>）</p><p>2 随后192.168.0.8回复 192.168.0.8 is at 00:0C:29:DE:DF:87</p><p>3 找到MAC地址后，随后就是ping报文</p><p>计算机中会维护一个ARP缓存表（包含一个<code>寿命值</code>TTL，也称作生存时间），这个表记录着IP地址与MAC地址的映射关系，我们可以通过在电脑的控制台通过arp -a指令查看一下我们自己计算机的ARP缓存表。他们是主机<code>最近</code>运行时获得关于其他主机的<code>IP地址</code>到<code>MAC地址</code>的映射，当需要发送数据的时候，主机就会根据数据报中的<code>目标IP地址</code>信息，然后在ARP缓存表中进行查找对应的<code>MAC地址</code>，最后通过<strong>网卡</strong>将数据发送出去。</p><p>如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p><strong>ARP协议的主要工作就是建立、查询、更新、删除ARP表项。</strong></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层之由来"><a href="#网络层之由来" class="headerlink" title="网络层之由来"></a>网络层之由来</h3><p>以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。</p><p>如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。所以就引出了“网络层”之“网络地址”的出现。</p><p>网络地址是管理员分配的，mac地址是绑定在网卡上的。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。即需先处理网络地址，然后再处理MAC地址。</p><h3 id="网络层之IP地址"><a href="#网络层之IP地址" class="headerlink" title="网络层之IP地址"></a>网络层之IP地址</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>网络地址/IP地址：IP协议第四版IPv4规定地址由32个二进制位组成，习惯上分为四段十进制数。</p><p>IP地址包含网络部分和主机部分。处于同一个自网络的主机，IP地址的网络部分必定相同。那如何判断网络部分呢？使用子网掩码，网络部分为1，主机部分为0。</p><p>判断任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层之由来"><a href="#传输层之由来" class="headerlink" title="传输层之由来"></a>传输层之由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但是每台主机上又运行着多个应用程序，那如何知道数据包是发送到哪个应用程序上的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。</p><p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</strong></p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。</p><h3 id="传输层之TCP-amp-UDP协议"><a href="#传输层之TCP-amp-UDP协议" class="headerlink" title="传输层之TCP&amp;UDP协议"></a>传输层之TCP&amp;UDP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p><h2 id="数据包最终组成"><a href="#数据包最终组成" class="headerlink" title="数据包最终组成"></a>数据包最终组成</h2><p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515165018.png" alt="数据包"></p><h2 id="新计算机上网设置"><a href="#新计算机上网设置" class="headerlink" title="新计算机上网设置"></a>新计算机上网设置</h2><ul><li><p>本机的IP地址</p></li><li><p>子网掩码</p></li><li><p>网关的IP地址</p></li><li><p>DNS的IP地址</p></li></ul><h3 id="动态IP地址"><a href="#动态IP地址" class="headerlink" title="动态IP地址"></a>动态IP地址</h3><p>“动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<a href="http://zh.wikipedia.org/zh/DHCP">DHCP协议</a>。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>但是局域网内的计算机发送数据包，必须知道目标主机的MAC地址和IP地址，新加入的计算机不知道DHCP服务器的这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定，规定如下：</p><p>首先，DHCP协议是一种<strong>应用层</strong>协议，建议在UDP之上。DHCP‘应用数据包组成为</p><p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播MAC地址：FF-FF-FF-FF-FF-FF。</p><p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>数据包构造完成发出，流程如下：</p><p>因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的<strong>MAC地址</strong>是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>阮一峰—互联网协议入门：</p><p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;互联网背景&quot;&gt;&lt;a href=&quot;#互联网背景&quot; class=&quot;headerlink&quot; title=&quot;互联网背景&quot;&gt;&lt;/a&gt;互联网背景&lt;/h2&gt;&lt;p&gt;我们每天都在使用互联网上网冲浪，而网站的资源是部署在另台机器上的，那么处于两地的主机是如何通信的呢？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="理解计算机" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>开发流程实践</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515165230.jpg" alt="软件开发流程"></p><h3 id="编写简略的需求分析方案"><a href="#编写简略的需求分析方案" class="headerlink" title="编写简略的需求分析方案"></a>编写简略的需求分析方案</h3><p>使用xmind/processon编写简略的需求分析方案</p><ol><li>前后端交互设计 &amp; 流程说明</li><li>领域模型拆解</li><li>接口设计：新增/修改接口</li><li>数据结构设计（数据格式预定义及输出）</li></ol><h3 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h3><p>使用processon绘制流程图</p><h3 id="接口定义-amp-开发-amp-单测"><a href="#接口定义-amp-开发-amp-单测" class="headerlink" title="接口定义&amp;开发&amp;单测"></a>接口定义&amp;开发&amp;单测</h3><ul><li>根据模板生成模板代码<ul><li>根据DLL语句生成模板代码</li><li>GsonFormat根据json数据生成实体对象（新建类 -&gt; Alt + Insert）</li></ul></li><li>编写 单测 + 接口代码</li><li>单测 / <code>.http</code>接口测试 </li><li>编写 Json 数据<ul><li>notepad++</li><li>在线：<a href="https://jsoneditoronline.org/">https://jsoneditoronline.org/</a></li><li>数据库存储需求**：在线将json数据压缩成一行</li></ul></li></ul><h3 id="接口文档输出"><a href="#接口文档输出" class="headerlink" title="接口文档输出"></a>接口文档输出</h3><p>接口文档输出或数据格式预定义及输出</p><h3 id="接口前后端联调"><a href="#接口前后端联调" class="headerlink" title="接口前后端联调"></a>接口前后端联调</h3><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data/img/20210515165230.jpg&quot; alt=&quot;软件开发流程&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写简略的需求分析方案&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="软件开发流程" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>docker-数据卷</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/docker-%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/docker-%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-容器内的数据管理"><a href="#docker-容器内的数据管理" class="headerlink" title="docker 容器内的数据管理"></a>docker 容器内的数据管理</h2><p>在使用容器的过程中，会有几个常见的场景，如查看容器内应用产生的数据，或者想要快速修改容器中应用的某个配置文件，除了进入容器进行操作这种方式，还有什么高效的方法吗？若容器被删除，容器内的数据也被删除怎么办？</p><p>这就又涉及一个问题，容器是如果对容器内数据进行管理的？</p><p>目前Docker提供了三种不同的方式将数据从宿主机挂载到容器中：</p><ul><li><strong>volumes：</strong>Docker管理宿主机文件系统的一部分，默认位于 /var/lib/docker/volumes 目录中；（<strong>最常用的方式</strong>）</li><li><strong>bind mounts：</strong>可以存储在宿主机系统的任意位置；（<strong>比较常用的方式</strong>）但是，bind mount在不同的宿主机系统时不可移植的，这也是为什么bind mount不能出现在Dockerfile中的原因。</li><li><strong>tmpfs：</strong>挂载存储在宿主机系统的内存中，而不会写入宿主机的文件系统；（<strong>一般都不会用的方式</strong>）</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/fCpd1cf8iacYo0R2ok1kmV4OFXzx0iajS0c2OjpyFKW3s3ib1zMiceU8RT3xdWf3rwaY0x6iaf9rJcUPF4qNa699Pvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供容器使用的特殊目录，它绕过文件系统（?），而通过挂载宿主机文件系统目录的方式，可以提供很多有用的特性：</p><ol><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的更改会立即生效。</li><li>对数据卷的更新不会影响镜像。</li><li>数据卷会一直存在，直到没有容器使用。</li></ol><p>数据卷的使用，类似于 linux 下对目录或文件进行 mount 操作。</p><ul><li><p>一般情况下，每个容器都会有自己的数据卷，而从同一镜像创建出来的容器的数据卷的标识都不一样。</p><ul><li>通过<code>docker inspect</code>可查看容器的数据卷—volume：mounts列表中<code>type=&quot;volume&quot;</code>的元素即docker数据卷，默认Name为该数据卷的名称，<code>Destination</code> 为挂载到容器的文件夹路径，可以通过<code>docker volume ls</code> 查看到对应的数据卷</li><li>使用 <code>docker volume prune</code> 删除未被容器使用的数据卷</li></ul></li><li><p>容器的数据卷在容器移除后还存在于宿主机文件系统中，可以在下一次创建容器时挂载并复用。</p></li><li><p>测试<strong>数据卷数据共享</strong>：</p><ul><li>运行 activemq 容器（<strong>activemq1</strong>），<code>docker inspect activemq</code> 查看容器的数据卷，将挂载到 <code>/opt/activemq/conf</code> 容器文件夹的数据卷的 Name复制下来，假设为 <code>$&#123;activemq-conf-volume-name&#125;</code></li><li><code>docker volume ls</code>可以列出所有的docker 数据卷，其中可以看到名为 <code>$&#123;activemq-conf-volume-name&#125;</code>的数据卷</li><li>进入容器（<strong>activemq1</strong>），修改 <code>/opt/activemq/conf</code> 文件夹下的<code>activemq.xml</code> 文件，随便加下任何注释内容，如<code>&lt;!-- test docker-volume --&gt; </code></li><li>退出容器，运行新的activemq容器（<strong>activemq2</strong>），并将docker数据卷挂载到新的容器中 <ul><li>-v <code>$&#123;activemq-conf-volume-name&#125;</code>:/opt/activemq/conf</li></ul></li><li>进入容器（<strong>activemq2</strong>），查看 <code>/opt/activemq/conf</code> 文件夹下的<code>activemq.xml</code> 文件，可以看到在容器 <strong>activemq1</strong>写入的注释 <code>&lt;!-- test docker-volume --&gt; </code></li></ul></li><li><p>与volumes不同，bind mounts的方式会隐藏掉被挂载目录里面的内容（如果非空的话）</p></li><li><p>同volumes一样，当我们清理掉容器之后，挂载目录里面的文件仍然还在，不会随着容器的结束而消失，从而实现数据持久化</p></li></ul><h3 id="在容器内创建一个数据卷"><a href="#在容器内创建一个数据卷" class="headerlink" title="在容器内创建一个数据卷"></a>在容器内创建一个数据卷</h3><p>在用 docker run 命令的时候，使用 -v 标记可以在容器内创建一个数据卷。多次使用 -v 标记可以创建多个数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker inspect 查看容器信息，以下是磁盘挂载，包含两种类型：<span class="string">&quot;bind&quot;</span> or <span class="string">&quot;volume&quot;</span></span></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;, # 容器内数据卷 可以使用 docker run -v $&#123;容器内文件夹绝对路径&#125; 生成容器数据卷，以下数据卷是activemq容器默认的数据卷，用于存放容器内应用产生的日志数据</span><br><span class="line">        &quot;Name&quot;: &quot;191d97917ffb20b8e64d969762f5d47a3198ccd74d8d45aa4b9ac4364c6bc8e4&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/191d97917ffb20b8e64d969762f5d47a3198ccd74d8d45aa4b9ac4364c6bc8e4/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/var/log/activemq&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 -v 标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker inspect 查看容器信息，以下是磁盘挂载，包含两种类型：<span class="string">&quot;bind&quot;</span> or <span class="string">&quot;volume&quot;</span></span></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;, # 映射宿主机磁盘目录 docker run -v $&#123;宿主机文件夹绝对路径&#125;:$&#123;容器内文件夹绝对路径&#125;:ro 挂载一个宿主机目录作为数据卷（如果目录不存在，Docker 会自动创建（需要考确认docker用户权限））</span><br><span class="line">        # 加了 :ro 之后，容器内挂载的数据卷内的数据就变成只读的了。</span><br><span class="line">        &quot;Source&quot;: &quot;/run/desktop/mnt/host/d/WorkSpace/docker/webdata&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/webdata&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="docker-run-P-p"><a href="#docker-run-P-p" class="headerlink" title="docker run -P/-p"></a>docker run -P/-p</h3><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。<br>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><p>-p（小写）则可以指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/sparkdev/p/6216154.html">Docker 基础 : 数据管理</a></li><li><a href="https://www.cnblogs.com/sparkdev/p/8504050.html">Docker 数据卷之进阶篇</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTMxMzg1MA==&mid=2654075892&idx=7&sn=616d544f2b09f2a68620ba047ec4476a">你必须知道的Docker数据卷</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-容器内的数据管理&quot;&gt;&lt;a href=&quot;#docker-容器内的数据管理&quot; class=&quot;headerlink&quot; title=&quot;docker 容器内的数据管理&quot;&gt;&lt;/a&gt;docker 容器内的数据管理&lt;/h2&gt;&lt;p&gt;在使用容器的过程中，会有几个常见的场</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="运维" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="docker" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>docker环境搭建_TODO</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA_TODO/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA_TODO/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>docker 镜像仓库配置</p></li><li><p>docker 镜像搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search activemq</span> </span><br></pre></td></tr></table></figure></li><li><p>docker 镜像拉取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull webcenter/activemq</span></span><br></pre></td></tr></table></figure></li><li><p>docker 容器运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 指定容器名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 端口映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后指定镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name activemq -p 61617:61616 -p 8162:8161 webcenter/activemq</span></span><br></pre></td></tr></table></figure></li><li><p>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i：表示以“交互模式”运行容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：表示容器启动后会进入其命令行</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> [/bin/bash] 表示执行容器内的该命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it activemq /bin/bash</span> </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker 镜像仓库配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;docker 镜像搜索&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="运维" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="docker" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Jms 与 activemq</title>
    <link href="https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mq/Jms%20%E4%B8%8E%20activemq/"/>
    <id>https://huangyuye.github.io/2021/05/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mq/Jms%20%E4%B8%8E%20activemq/</id>
    <published>2021-05-24T12:55:11.596Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="JMS提出背景"><a href="#JMS提出背景" class="headerlink" title="JMS提出背景"></a>JMS提出背景</h3><p>不同<strong>系统之间</strong>进行<strong>信息交换</strong>是开发中常见的场景，那如何进行信息交换呢？</p><p>SUN公司提出了一种面向消息的中间件服务–即<strong>JMS规范</strong>（标准）</p><p><code>常用的几种信息交互技术**(httpClient、hessian、dubbo、jms、webservice 五种).**</code></p><p><code>消息中间件 MOM：message-oriented middleware</code></p><h3 id="JMS概述"><a href="#JMS概述" class="headerlink" title="JMS概述"></a>JMS概述</h3><p><strong>JMS</strong> 即 <strong>Java 消息服务</strong>（Java Message Service得简称），是Java EE 的标准/规范之一。</p><p>JMS只是Java EE中定义的是两个应用程序之间进行异步通信的API，它为标准消息协议和消息服务提供了一组通用接口。它自身并不是一个消息服务系统，而是消息传送服务的一个<strong>抽象</strong></p><ul><li>该规范（标准）指出：消息的发送应该是<strong>异步</strong>的、非阻塞的。</li><li>作用：消除系统瓶颈，去耦合，提高系统的整体可伸缩性和灵活性<ul><li>异步：主次业务拆分，不需要同步阻塞<ul><li>强弱依赖梳理能将非关键调用链路的操作异步化并提升整体系统的吞吐能力</li></ul></li><li>解耦：上游不需要根据下游变动而调整<ul><li>新模块进来可以做到代码改动量最小</li></ul></li><li>削峰：同一时刻的流量得到缓冲<ul><li>设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaEE 有13种核心技术规范，JMS是其中之一</span><br></pre></td></tr></table></figure><h3 id="JMS副作用"><a href="#JMS副作用" class="headerlink" title="JMS副作用"></a>JMS副作用</h3><ul><li>中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 降低了系统的【可用性】 ？</li><li>要保证HA(高可用)？是不是要搞集群？那么我 整个系统的【复杂度】是不是上升了 ？</li><li>万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。或者我消费端处理失败了，请求重发，这样也会产生重复的消息。【重复消息】</li><li>如何解决消息的 顺序消费 问题 呢？【消费顺序】</li><li>如何解决 分布式事务 问题呢</li><li>如何解决 消息堆积 的问题呢？</li></ul><h3 id="ActiveMQ概述"><a href="#ActiveMQ概述" class="headerlink" title="ActiveMQ概述"></a>ActiveMQ概述</h3><p>ActiveMQ是JMS标准/规范的具体实现，采用Java语言开发。（Apache开源消息服务器）</p><p>ActiveMQ与JMS的关系：</p><ul><li>JMS定义了一组有关<strong>消息传送</strong>的规范和标准，Apache ActiveMQ是JMS规范的具体实现</li><li>JMS只是定义了一组接口，如同JDBC抽象了关系数据库访问、JPA抽象了对象与关系数据库映射、JNDI抽象了命名目录服务访问</li></ul><h3 id="JMS-消息队列的工作模式"><a href="#JMS-消息队列的工作模式" class="headerlink" title="JMS 消息队列的工作模式"></a>JMS 消息队列的工作模式</h3><ul><li>点对点（point to point）</li><li>发布/订阅（publish/subscribe，topic）</li></ul><h4 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h4><p>p2p工作模式下的特点：</p><ul><li><p>每个消息只能有一个消费者</p></li><li><p>消息的生产者和消费者之间没有时间上的相关性</p></li><li><p>消息被消费后队列中不会再存储</p></li></ul><h4 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h4><p>pub/sub工作模式下的特点：</p><ul><li>每个消息可以有多个消费者</li><li>生产者和消费者有时间上的相关性<ul><li>要先订阅，后发布</li><li>JMS规范允许客户创建持久订阅，该方式允许消费者消费它在未处于<strong>激活状态</strong>时发送的消息</li></ul></li></ul><h3 id="JMS-组成元素"><a href="#JMS-组成元素" class="headerlink" title="JMS 组成元素"></a>JMS 组成元素</h3><ul><li>provider / broker<ul><li>实现JMS接口和规范的消息中间件，即MQ服务器</li></ul></li><li>producer</li><li>consumer</li><li>message<ul><li>消息头</li><li>消息属性</li><li>消息体</li></ul></li></ul><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>运行环境支持：Java环境变量配置</li><li>配置文件指定：<code>./activemq start xbean:file:/$&#123;absolutePath&#125;/$&#123;activemq-conf&#125;.xml</code></li><li>默认端口：管理端口-8161，消息服务broker连接端口-61616</li><li>用户管理，用户组管理</li><li>消息持久化</li><li>传输协议</li></ul><h4 id="简单搭建"><a href="#简单搭建" class="headerlink" title="简单搭建"></a>简单搭建</h4><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><h3 id="API对象说明（编程模板）"><a href="#API对象说明（编程模板）" class="headerlink" title="API对象说明（编程模板）"></a>API对象说明（编程模板）</h3><p>以下的 JMS 对象以apache activemq实现进行举例说明</p><h4 id="ConnectionFactory"><a href="#ConnectionFactory" class="headerlink" title="ConnectionFactory"></a>ConnectionFactory</h4><p>通过创建ConnectionFactory建立到ActveMQ(消息服务器)的连接</p><p>构造方法：<code>ActiveMQConnectionFactory(String userName, String password, String brokerURL)</code></p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>ConnectionFactory负责返回可以与底层消息传递系统进行通信的Connection实现。</p><p>当一个Connection被创建时，它的传输默认是关闭的，必须使用start方法开启。</p><p>一个Connection可以建立一个或多个的Session。</p><p>当一个程序执行完成后，必须关闭之前创建的Connection，否则ActiveMQ不能释放资源，关闭一个Connection同样也关闭了Session，MessageProducer和MessageConsumer。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>从Connection中创建一个或者多个Session。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transacted 为使用事务标识， acknowledgeMode 为签收模式(常用为自动签收和手动签收)</span></span><br><span class="line"><span class="function">Session <span class="title">createSession</span><span class="params">(<span class="keyword">boolean</span> transacted, <span class="keyword">int</span> acknowledgeMode)</span></span></span><br></pre></td></tr></table></figure><p>Session是一个发送或接收消息的线程，可以使用Session创建MessageProducer，MessageConsumer和Message。</p><p>Session可以被事务化，也可以不被事务化。</p><h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h4><p>Destination是一个客户端用来指定生产消息目标和消费消息来源的对象。</p><p>在PTP模式中，Destination被称作Queue即队列；在Pub/Sub模式，Destination被称作Topic即主题。</p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>Message 由以下几部分组成：消息头，属性和消息体</p><h4 id="MessageProducer"><a href="#MessageProducer" class="headerlink" title="MessageProducer"></a>MessageProducer</h4><p>是一个由Session创建的对象，用来向Destination发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deliveryMode：是否持久化,取值范围-接口javax.jms.DeliveryMode&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">// priority：消息的优先级（0-9 默认是 4）</span></span><br><span class="line"><span class="comment">// timeToLive：消息的存活时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Destination destination, Message message, <span class="keyword">int</span> deliveryMode, <span class="keyword">int</span> priority, <span class="keyword">long</span> timeToLive)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="MessageConsumer"><a href="#MessageConsumer" class="headerlink" title="MessageConsumer"></a>MessageConsumer</h4><p>是一个由Session创建的对象，用来从Destination接收消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// destination：第一个方法适合消费主题消息和队列消息</span></span><br><span class="line"><span class="comment">// messageSelector 为消息选择器</span></span><br><span class="line"><span class="comment">// noLocal 标志默认为 false，当设置为 true 时限制消费者只能接收和自己相同的连接(Connection)所发布的消息，此标志只适用于主题，不适用于队列；</span></span><br><span class="line"><span class="function">MessageConsumer <span class="title">createConsumer</span><span class="params">(Destination destination, String messageSelector, <span class="keyword">boolean</span> noLocal)</span></span>;</span><br><span class="line"><span class="comment">// name 标识订阅主题所对应的订阅名称，持久订阅时需要设置此参数。</span></span><br><span class="line"><span class="function">TopicSubscriber <span class="title">createDurableSubscriber</span><span class="params">(Topic topic, String name, String messageSelector, <span class="keyword">boolean</span> noLocal)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>消息的同步/异步接收</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 客户端同步接收：receive()&#x2F;receive(long timeout)receiveNoWait()</span><br><span class="line">&#x2F;&#x2F; 客户端异步接收：注册一个实现 MessageListener 接口的对象到 MessageConsumer</span><br></pre></td></tr></table></figure><h3 id="开发示例"><a href="#开发示例" class="headerlink" title="开发示例"></a>开发示例</h3><h4 id="生产者-消息生产"><a href="#生产者-消息生产" class="headerlink" title="生产者-消息生产"></a>生产者-消息生产</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 JNDI 构建连接工厂 || 用JNDI 得到目标队列或主题对象，即Destination 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConnectionFactory <span class="title">buildFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActiveMQConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory();</span><br><span class="line">    connectionFactory.setBrokerURL(<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>); <span class="comment">// MQ broker服务器地址</span></span><br><span class="line">    connectionFactory.setUserName(<span class="string">&quot;admin&quot;</span>); <span class="comment">// MQ账号</span></span><br><span class="line">    connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>); <span class="comment">// MQ密码</span></span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.通过 JNDI 构建连接工厂 || 用JNDI 得到目标队列或主题对象，即Destination 对象</span></span><br><span class="line">    ConnectionFactory factory = buildFactory();</span><br><span class="line">    <span class="comment">// 2.创建连接</span></span><br><span class="line">    Connection connection = factory.createConnection();</span><br><span class="line">    <span class="comment">// 3.打开连接</span></span><br><span class="line">    connection.start();</span><br><span class="line">    <span class="comment">// 4.创建session param1=事务是否开启 param2=消息确认机制  如果开启事务，第二个参数无用，且需要一个提交事务的操作 </span></span><br><span class="line">    Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    <span class="comment">// 通过 JNDI 创建 destination</span></span><br><span class="line">    <span class="comment">// 5.创建消息队列</span></span><br><span class="line">    Destination topic = session.createTopic(<span class="string">&quot;topic.shop&quot;</span>);</span><br><span class="line">    <span class="comment">// 6.创建生产者</span></span><br><span class="line">    MessageProducer producer1 = session.createProducer(topic);</span><br><span class="line">    <span class="comment">// 7.创建消息</span></span><br><span class="line">    TextMessage topicMsg = session.createTextMessage(<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">    topicMsg.setStringProperty(<span class="string">&quot;companyId&quot;</span>, <span class="string">&quot;10000146&quot;</span>);</span><br><span class="line">    <span class="comment">// 8.发送消息到消息队列</span></span><br><span class="line">    producer1.send(topicMsg);</span><br><span class="line">    <span class="comment">// 9.关闭连接</span></span><br><span class="line">    session.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-消费消息"><a href="#消费者-消费消息" class="headerlink" title="消费者-消费消息"></a>消费者-消费消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.通过 JNDI 构建连接工厂 || 用JNDI 得到目标队列或主题对象，即Destination 对象</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory();</span><br><span class="line">    <span class="comment">// 2.创建连接</span></span><br><span class="line">    Connection connection = factory.createConnection();</span><br><span class="line">    <span class="comment">// 3. 设置客户端ID</span></span><br><span class="line">    connection.setClientID(<span class="string">&quot;ecrp-sg&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.打开连接</span></span><br><span class="line">    connection.start();</span><br><span class="line">    <span class="comment">// 4.创建会话</span></span><br><span class="line">    Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    <span class="comment">// 通过 JNDI 创建 destination</span></span><br><span class="line">    <span class="comment">// 5.创建目标地址(通道)</span></span><br><span class="line">    Topic topic = session.createTopic(<span class="string">&quot;topic.shop&quot;</span>);</span><br><span class="line">    <span class="comment">// 6.创建消费者</span></span><br><span class="line">    MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">    <span class="comment">// 7.阻塞接收消息 或 建立消息监听</span></span><br><span class="line">    <span class="comment">// Message message = consumer.receive();</span></span><br><span class="line">    consumer.setMessageListener(message -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            TextMessage textMessage = (TextMessage) message;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收的消息：&quot;</span> + textMessage.getText());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类型错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息选择器"><a href="#消息选择器" class="headerlink" title="消息选择器"></a>消息选择器</h4><ol><li><p>生产者生产消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... 创建连接、session、目的地、创建生产者</span><br><span class="line"><span class="comment">// 设置消息属性</span></span><br><span class="line">message.setStringProperty(<span class="string">&quot;companyId&quot;</span>, <span class="string">&quot;10000146&quot;</span>);</span><br><span class="line">... 消息发往目的地、关闭流</span><br></pre></td></tr></table></figure></li><li><p>消费者消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... 创建连接、session、目的地</span><br><span class="line"><span class="comment">// 创建消费者时设置消息过滤器</span></span><br><span class="line">session.createConsumer(topic,<span class="string">&quot;companyId in (&#x27;10000146&#x27;)&quot;</span>);</span><br><span class="line">... 消息发往目的地、关闭流</span><br></pre></td></tr></table></figure></li></ol><p><strong>关于消息选择器的介绍</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下内容摘自：《MQ 系列之 ActiveMQ 基本使用》https://cloud.tencent.com/developer/article/1707858</span><br><span class="line">   JMS 提供了一种机制，使用它，消息服务可根据消息选择器中的标准来执行消息过滤。生产者可在消息中放入应用程序特有的属性，而消费者可使用基于这些属性的选择标准来表明对消息是否感兴趣。这就简化了客户端的工作，并避免了向不需要这些消息的消费者传送消息的开销。然而，它也使得处理选择标准的消息服务增加了一些额外开销。</span><br><span class="line">   消息选择器是用于 MessageConsumer 的过滤器，可以用来过滤传入消息的属性和消息头部分(但不过滤消息体)，并确定是否将实际消费该消息。按照 JMS 文档的说法，消息选择器是一些字符串，它们基于某种语法，而这种语法是 SQL-92 的子集。可以将消息选择器作为 MessageConsumer 创建的一部分。例如：public final String SELECTOR = &quot;JMSType = &#x27;TOPIC<span class="emphasis">_PUBLISHER&#x27;&quot;;该选择器检查了传入消息的 JMSType 属性，并确定了这个属性的值是否等于 TOPIC_</span>PUBLISHER。如果相等，则消息被消费；如果不相等，那么消息会被忽略。</span><br></pre></td></tr></table></figure><h4 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a>消息优先级</h4><h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><p>创建session时，开启事务，则”签收模式“参数无效；消息的消费需要一个提交事务的操作</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><h4 id="安全控制插件"><a href="#安全控制插件" class="headerlink" title="安全控制插件"></a>安全控制插件</h4><p>用户验证、授权(角色)（仅读权限）</p><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><h4 id="消息持久化与持久化方式"><a href="#消息持久化与持久化方式" class="headerlink" title="消息持久化与持久化方式"></a>消息持久化与持久化方式</h4><h4 id="异步发送消息并接收回调"><a href="#异步发送消息并接收回调" class="headerlink" title="异步发送消息并接收回调"></a>异步发送消息并接收回调</h4><p>useAsynSend</p><h4 id="消息回复"><a href="#消息回复" class="headerlink" title="消息回复"></a>消息回复</h4><h4 id="连接-缓存与池"><a href="#连接-缓存与池" class="headerlink" title="连接-缓存与池"></a>连接-缓存与池</h4><h4 id="外部事务管理器"><a href="#外部事务管理器" class="headerlink" title="外部事务管理器"></a>外部事务管理器</h4><h4 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h4><h2 id="关于连接工厂"><a href="#关于连接工厂" class="headerlink" title="关于连接工厂"></a>关于连接工厂</h2><h3 id="缓存与池"><a href="#缓存与池" class="headerlink" title="缓存与池"></a>缓存与池</h3><ul><li><p>org.apache.activemq.ActiveMQConnectionFactory</p><ul><li>通过连接工厂池，可以将Connection，Session等都放在池里面，用的时候直接返回池里面的内容，无需临时建立连接，节约开销</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;targetConnectionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;brokerURL&quot;</span> value=<span class="string">&quot;tcp://localhost:61616&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 通过往PooledConnectionFactory注入一个ActiveMQConnectionFactory可以用来将Connection，Session和MessageProducer池化这样可以大大减少我们的资源消耗， --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;pooledConnectionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.apache.activemq.pool.PooledConnectionFactory&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;connectionFactory&quot;</span> ref=<span class="string">&quot;targetConnectionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;maxConnections&quot;</span> value=<span class="string">&quot;10&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id=<span class="string">&quot;connectionFactory&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;targetConnectionFactory&quot;</span> ref=<span class="string">&quot;pooledConnectionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>org.springframework.xxx.CachingConnectionFactory (继承了SingleConnectionFactory)</p><ul><li>SingleConnectionFactory保证每次返回的都是同一个连接</li><li>CachingConnectionFactory继承了SingleConnectionFactory在保证同一连接的同时，增加了缓存的功能，可以缓存Session以及生产者，消费者。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;targetConnectionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;brokerURL&quot;</span> value=<span class="string">&quot;tcp://localhost:61616&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;connectionFactory&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;targetConnectionFactory&quot;</span> ref=<span class="string">&quot;targetConnectionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置 Spring JmsTemplate</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;jmsTemplate&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jms.core.JmsTemplate&quot;</span>&gt;</span><br><span class="line">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;connectionFactory&quot;</span> ref=<span class="string">&quot;connectionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>todo …</strong></p><h2 id="Spring-框架集成JMS"><a href="#Spring-框架集成JMS" class="headerlink" title="Spring 框架集成JMS"></a>Spring 框架集成JMS</h2><p>在Spring框架中使用JMS传递消息有两种方式：</p><p><strong>JMS template</strong> 和 <strong>message listener container</strong>，前者用于同步收发消息，后者用于异步收发消息。</p><h3 id="开发示例-1"><a href="#开发示例-1" class="headerlink" title="开发示例"></a>开发示例</h3><h4 id="JMS-template"><a href="#JMS-template" class="headerlink" title="JMS template"></a>JMS template</h4><ol><li><p>注册连接工厂实例 ActiveMQConnectionFactory(brokerUrl, username, password)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--消息服务连接信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;brokerURL&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>tcp://127.0.0.1:61616<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注册目的地实例 （ActiveMQQueue / ActiveMQTopic）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- queue目的地配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;destination&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.command.ActiveMQQueue&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;spring-queue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注册 JmsTemplate(Spring) 实例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring 使用jmsTemplate来实现消息的发送和接受 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jmsTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.core.JmsTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jmsFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的地的设置，使用spring来使用activemq时，使用queue还是topic很方便，在这里引用不同地址就ok了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultDestination&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;destination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--转换器，我们自己可以继承重写这个类的方法 ，这里使用spring提供的默认方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverter&quot;</span>&gt;</span></span><br><span class="line">        &lt;bean</span><br><span class="line">              class=&quot;org.springframework.jms.support.converter.SimpleMessageConverter&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>消息生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取JmsTemplate对象</span></span><br><span class="line">JmsTemplate jt = (JmsTemplate) ctx.getBean(<span class="string">&quot;jmsTemplate&quot;</span>);</span><br><span class="line"><span class="comment">// 调用方法，发送消息</span></span><br><span class="line">jt.send(<span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">    <span class="comment">// 消息的产生，返回消息发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session s)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        TextMessage msg = s</span><br><span class="line">            .createTextMessage(<span class="string">&quot;Spring send msg ----&gt; Hello activeMQ5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>消息消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JmsTemplate jt = (JmsTemplate) ctx.getBean(<span class="string">&quot;jmsTemplate&quot;</span>);</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line">String msg = (String) jt.receiveAndConvert();</span><br></pre></td></tr></table></figure></li></ol><h4 id="message-listener-container"><a href="#message-listener-container" class="headerlink" title="message listener container"></a>message listener container</h4><p>由于需要模拟消息生产，所以同样需要执行上一小节《<strong>JMS template</strong>》内的所有配置步骤（除消息消费者）</p><p>额外需要配置的内容为</p><ol><li><p>自定消息监听器 ? implements MessageListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message arg0)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String message = ((TextMessage) arg0).getText();</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册消息监听器实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;myMessageListener&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;xxx.MyMessageListener&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>注册消息监听器容器实例</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;jmsContainer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;connectionFactory&quot;</span> ref=<span class="string">&quot;jmsFactory&quot;</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;destination&quot;</span> ref=<span class="string">&quot;destination&quot;</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;messageListener&quot;</span> ref=<span class="string">&quot;myMessageListener&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="两种-message-listener-container"><a href="#两种-message-listener-container" class="headerlink" title="两种 message listener container"></a>两种 message listener container</h4><ul><li><p>DefaultMessageListenerContainer</p><ul><li>允许期间动态调整监听线程的数量</li><li>允许和XA Transactions的集成</li></ul></li><li><p>SimpleMessageListenerContainer</p></li></ul><p>相同点：都允许指定数量的并发监听线程</p><p>建议：对于使用本地事务管理器和不需要基于可变负载的线程、会话、连接调整的简单消息传递应用，使用SimpleMessageListenerContainer。</p><h3 id="异步消息监听器的三种方式配置"><a href="#异步消息监听器的三种方式配置" class="headerlink" title="异步消息监听器的三种方式配置"></a>异步消息监听器的三种方式配置</h3><ul><li><p>实现javax.jms.MessageListener接口（<strong>JMS规范中定义的一个接口</strong>）</p></li><li><p>实现Spring的SessionAwareMessageListener（Spring<strong>提供</strong>）</p><ul><li>不是标准的JMS MessageListener</li><li>SessionAwareMessageListener的设计就是为了方便我们在接收到消息后发送一个回复的消息</li><li>提供了一个处理接收到的消息的onMessage方法，可以同时接收两个参数，一个是表示当前接收到的消息Message，另一个就是可以用来发送消息的Session对象</li></ul></li><li><p>捆绑一个标准POJO到Spring的MessageListenerAdapter类上</p><ul><li>实现了MessageListener接口和SessionAwareMessageListener接口</li><li>默认消息处理方法为 <code>handleMessage</code>，可以通过属性 <code>defaultListenerMethod</code> 修改</li><li>主要作用是：1.将接收到的消息进行类型转换，然后通过反射的形式把它交给一个普通的Java类进行处理。2.自定义反射类。3.自动回复发送者消息</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- 新建自定义监听器java类：有两个方法handleMessage和receiveMessage，其代码如下（参数可以是五种消息类型，根据作用1可知这是自动根据反射转换的 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以下是使用MessageListenerAdapter监听器相关==============================================================================--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息监听适配器 第一种方法通过构造方法参数设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;messageListenerAdapter&quot; class=&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;constructor-arg&gt;</span></span><br><span class="line"><span class="comment">            &lt;bean class=&quot;com.easylab.jms.consumer.myListenner&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息监听适配器 第二种方法通过delegate属性设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageListenerAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;delegate&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.easylab.jms.consumer.myListenner&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认接受到消息后调用哪个方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultListenerMethod&quot;</span> <span class="attr">value</span>=<span class="string">&quot;receiveMessage&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置监听器回复消息的队列（用的以前的点对点队列），也可以通过发送者发送方中的方法setJMSReplyTo设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultResponseDestination&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;queueDestination&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息监听适配器对应的监听容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageListenerAdapterContainer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;destination&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;adapterQueue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageListener&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageListenerAdapter&quot;</span>/&gt;</span><span class="comment">&lt;!-- 使用MessageListenerAdapter来作为消息监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于测试消息监听适配器的队列目的地 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;adapterQueue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.activemq.command.ActiveMQQueue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>adapterQueue<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考自：<a href="https://blog.csdn.net/moonsheep_liu/article/details/6684948">https://blog.csdn.net/moonsheep_liu/article/details/6684948</a></p><h2 id="Spring-Boot-项目引入activemq（一）"><a href="#Spring-Boot-项目引入activemq（一）" class="headerlink" title="Spring Boot 项目引入activemq（一）"></a>Spring Boot 项目引入activemq（一）</h2><p>以下步骤完全使用springboot/spring的支持，不额外管理或配置连接工厂、监听容器、生产者、消费者</p><h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>引入activemq相关依赖，配合 spring-boot-autoconfigure 使用 （**@onConditional条件注册**）</p><p><code>org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p><code>ActiveMQProperties.class, JmsProperties.class</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    activemq:</span><br><span class="line">        # max-connections: 10   #连接池最大连接数</span><br><span class="line">        # idle-timeout: 30000   #空闲的连接过期时间，默认为30秒</span><br><span class="line">      brokerUrl: tcp:&#x2F;&#x2F;ts-ecloud-mq.vecrp.com:61617</span><br><span class="line">      user: admin</span><br><span class="line">      password: Nascent@2019</span><br><span class="line">      pubSubDomain: true # 发布订阅模式</span><br><span class="line">      pool:</span><br><span class="line">        enabled: false # 先不使用连接池</span><br><span class="line">    jms: # jmsTemplate</span><br><span class="line">      pubSubDomain: true # 发布订阅模式</span><br><span class="line">      cache:</span><br><span class="line">        enabled: false</span><br><span class="line">      template:</span><br><span class="line">        deliveryMode: PERSISTENT # 持久化</span><br></pre></td></tr></table></figure><h3 id="JmsListener-监听器注册"><a href="#JmsListener-监听器注册" class="headerlink" title="@JmsListener 监听器注册"></a>@JmsListener 监听器注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JmsListener(destination = &quot;topic.employees&quot;, // 监听目的地</span></span><br><span class="line"><span class="meta">        id = &quot;ecrp-sg:employee&quot;, // 消息监听容器的ID</span></span><br><span class="line"><span class="meta">        selector = &quot;$&#123;topic.employee.selector&#125;&quot;, // 选择器，用于过滤不同的消息（这里使用配置文件方式动态指定）</span></span><br><span class="line"><span class="meta">        subscription = &quot;持久化订阅&quot;)</span><span class="comment">// 持久化订阅的备注信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGuideMessage</span><span class="params">(ActiveMQMessage message)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">    <span class="comment">// 消息来源公司</span></span><br><span class="line">    String groupId = message.getStringProperty(CloudPlatformMessagePropertyName.COMPANY_ID);</span><br><span class="line">    TextMessage textMessage = (TextMessage) message;</span><br><span class="line">    log.info(<span class="string">&quot;[消息推送][员工] 推送员工数据：&#123;&#125;&quot;</span>, textMessage.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnableJms-启用JMS"><a href="#EnableJms-启用JMS" class="headerlink" title="@EnableJms 启用JMS"></a>@EnableJms 启用JMS</h3><p>让Spring自动扫描JMS相关的Bean，并加载JMS配置文件<code>jms.properties</code></p><p>自动扫描带有<code>@JmsListener</code>的Bean方法，并为其创建一个<code>MessageListener</code>把它包装起来。</p><h3 id="项目启动时自定义监听器配置"><a href="#项目启动时自定义监听器配置" class="headerlink" title="项目启动时自定义监听器配置"></a>项目启动时自定义监听器配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPropertySettingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AbstractEnvironment environment;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; SOURCE_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态属性配置名称（仅用于区分当前配置集合所属分类而已）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DYNAMIC_CONFIG = <span class="string">&quot;dynamicSetting&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新属性配置</span></span><br><span class="line">        reloadPropertySource();</span><br><span class="line">        <span class="comment">// 加载到spring环境配置</span></span><br><span class="line">        environment.getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(DYNAMIC_CONFIG, SOURCE_MAP));</span><br><span class="line">        <span class="comment">// 注册jms监听器实例（该方式仅能在容器启动时注册监听器到Spring维护的监听容器中管理，spring项目启动完成后修改注册监听器不会再影响spring监听容器，所以当前该代码示例仅用于spring项目启动之前需要动态获取待注册容器，但是spring项目启动之后不需要动态更新容器的场景。）</span></span><br><span class="line">        <span class="comment">// 其实可以省略registerJmsListenerBean()，直接在监听器注解中使用配置文件属性指定，项目启动时根据需要重写配置文件属性值即可实现</span></span><br><span class="line">        registerJmsListenerBean();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新属性配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reloadPropertySource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SgGroupDao&gt; sgGroupDaos = SgGroupDao.dao().findAllGroup(SystemConstant.STATE_1);</span><br><span class="line">        String groupIds = Joiner.on(<span class="string">&quot;,&quot;</span>).join(sgGroupDaos.stream()</span><br><span class="line">                .map(item -&gt; <span class="string">&quot;&#x27;&quot;</span> + item.getGroupId() + <span class="string">&quot;&#x27;&quot;</span>).collect(Collectors.toList()));</span><br><span class="line">        String selectorExpression = <span class="string">&quot;companyId in (&quot;</span> + groupIds + <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        <span class="comment">// 更新属性配置</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(SOURCE_MAP.get(DynamicConstant.DYNAMIC_GROUP_ID_LIST), groupIds)) &#123;</span><br><span class="line">            SOURCE_MAP.put(DynamicConstant.DYNAMIC_GROUP_ID_LIST, groupIds);</span><br><span class="line">            SOURCE_MAP.put(DynamicConstant.DYNAMIC_SHOP_SELECTOR, selectorExpression);</span><br><span class="line">            SOURCE_MAP.put(DynamicConstant.DYNAMIC_EMPLOYEE_SELECTOR, selectorExpression);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册jms监听器实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJmsListenerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory =</span><br><span class="line">                (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">        <span class="comment">// 若存在监听器则移除再重新注册</span></span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(DynamicConstant.DYNAMIC_JMS_LISTENER)) &#123;</span><br><span class="line">            beanFactory.removeBeanDefinition(DynamicConstant.DYNAMIC_JMS_LISTENER);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinitionBuilder definitionBuilder =</span><br><span class="line">        BeanDefinitionBuilder.genericBeanDefinition(CloudPlatformMessageListener.class);</span><br><span class="line">        <span class="comment">// 注册监听器实例</span></span><br><span class="line">        beanFactory.registerBeanDefinition(DynamicConstant.DYNAMIC_JMS_LISTENER,</span><br><span class="line">                definitionBuilder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态注册jms消息监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Scheduled(fixedRate = 10000)</span></span><br><span class="line"><span class="comment">//    public void dynamicRegisterJmsListenerBean() &#123;</span></span><br><span class="line"><span class="comment">//        // 更新属性配置成功才重新注册监听器</span></span><br><span class="line"><span class="comment">//        if (reloadPropertySource()) &#123;</span></span><br><span class="line"><span class="comment">//            // 注册jms监听器实例</span></span><br><span class="line"><span class="comment">//            registerJmsListenerBean();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicConstant</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态监听器命名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DYNAMIC_JMS_LISTENER = <span class="string">&quot;cloudPlatformMessageListener&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态公司ID集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DYNAMIC_GROUP_ID_LIST = <span class="string">&quot;dynamic_group_id_list&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态门店选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DYNAMIC_SHOP_SELECTOR = <span class="string">&quot;topic.shop.selector&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态员工选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DYNAMIC_EMPLOYEE_SELECTOR = <span class="string">&quot;topic.employee.selector&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JmsListenerAnnotationBeanPostProcessor-Bean后置处理器"><a href="#JmsListenerAnnotationBeanPostProcessor-Bean后置处理器" class="headerlink" title="JmsListenerAnnotationBeanPostProcessor Bean后置处理器"></a>JmsListenerAnnotationBeanPostProcessor Bean后置处理器</h3><p>配合 <code>JmsListenerEndpointRegistrar</code> 、<code>JmsListenerEndpointRegistry</code> 注册消息监听容器，并启动消息监听器。</p><p>@JmsListener注解的函数都会被解析成一个消息处理器并交给Spring管理。</p><h2 id="Spring-Boot-项目引入activemq（二）"><a href="#Spring-Boot-项目引入activemq（二）" class="headerlink" title="Spring Boot 项目引入activemq（二）"></a>Spring Boot 项目引入activemq（二）</h2><h4 id="动态注册消息监听器容器"><a href="#动态注册消息监听器容器" class="headerlink" title="动态注册消息监听器容器"></a>动态注册消息监听器容器</h4><p>不使用Spring管理的消息监听容器，项目自行维护管理，步骤如下</p><ol><li><p>定义消息监听类（员工/门店），确认 destination 目的地</p><ul><li><code>? extends AbstractMessageListener</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目的地</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">destination</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否使用发布订阅模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">pubSubDomain</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定时器-定时获取有效集团信息，并注册消息监听器 <code>DynamicMessageListenerContainerConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态监听容器配置类，注册不同公司的消息监听器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yuye.huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2021/1/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicMessageListenerContainerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要动态注册的监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;? extends AbstractMessageListener&gt;&gt; messageListenerList</span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;Class&lt;? extends AbstractMessageListener&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2351177971062352088L</span>;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            add(SgGuideMessageListener.class);</span><br><span class="line">            add(SgShopMessageListener.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态注册消息监听容器，查询有效的公司集合注册监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dynamicRegisterMessageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询有效的公司集合</span></span><br><span class="line">        List&lt;SgGroupDao&gt; sgGroupDaos = SgGroupDao.dao().findAllGroup(SystemConstant.STATE_1);</span><br><span class="line">        <span class="comment">// 注册消息监听容器</span></span><br><span class="line">        refreshMessageListenerContainer(</span><br><span class="line">                sgGroupDaos.stream().map(SgGroupDO::getGroupId).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态注册jms消息监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 3000L, fixedRate = 10000L)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dynamicRegisterJmsListenerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dynamicRegisterMessageListenerContainer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听容器集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; k-clientId v-监听器 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MessageListenerContainer&gt; listenerContainers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停的监听容器集合（clientId）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stoppedContainers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新消息监听器容器列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupIds 公司ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshMessageListenerContainer</span><span class="params">(List&lt;Long&gt; groupIds)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 公司被删除，暂停对应的监听器容器</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, MessageListenerContainer&gt; entry : listenerContainers.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stoppedContainers.contains(entry.getKey())</span><br><span class="line">                    &amp;&amp; !groupIds.contains(resolveGroupIdFromClientId(entry.getKey()))) &#123;</span><br><span class="line">                stopMessageListener(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新增公司，注册监听器容器</span></span><br><span class="line">        groupIds.forEach(groupId -&gt; &#123;</span><br><span class="line">            <span class="comment">// 注册公司[员工\门店消息]监听器</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;? extends AbstractMessageListener&gt; aClass : messageListenerList) &#123;</span><br><span class="line">                AbstractMessageListener messageListener;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    messageListener = aClass.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;[动态JMS监听] 监听器实例创建失败：[&#123;&#125;]&quot;</span>, aClass.getName());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String clientId = buildClientId(messageListener.destination(), groupId);</span><br><span class="line">                <span class="comment">// 创建监听器容器</span></span><br><span class="line">                <span class="keyword">if</span> (!listenerContainers.containsKey(clientId)) &#123;</span><br><span class="line">                    registerMessageListenerContainer(groupId, messageListener);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重新启动被关闭的监听容器</span></span><br><span class="line">                <span class="keyword">if</span> (stoppedContainers.contains(clientId)) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;[动态JMS监听] 重启监听器：[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">                    listenerContainers.get(clientId).start();</span><br><span class="line">                    stoppedContainers.remove(clientId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册消息监听容器：根据不同公司创建selector</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId                公司ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sgGuideMessageListener 消息监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMessageListenerContainer</span><span class="params">(Long groupId, AbstractMessageListener sgGuideMessageListener)</span> </span>&#123;</span><br><span class="line">        registerMessageListenerContainer(sgGuideMessageListener,</span><br><span class="line">                sgGuideMessageListener.destination(),</span><br><span class="line">                buildClientId(sgGuideMessageListener.destination(), groupId),</span><br><span class="line">                <span class="string">&quot; companyId = &#x27;&quot;</span> + groupId + <span class="string">&quot;&#x27;&quot;</span>,</span><br><span class="line">                sgGuideMessageListener.pubSubDomain());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建消息监听容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId        客户端ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageListener 消息监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageSelector 消息选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerMessageListenerContainer</span><span class="params">(MessageListener messageListener, String destination,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String clientId, String messageSelector, <span class="keyword">boolean</span> pubSubDomain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listenerContainers.containsKey(clientId)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;[动态JMS监听] 注册监听器：[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        DefaultMessageListenerContainer messageListenerContainer = <span class="keyword">new</span> DefaultMessageListenerContainer();</span><br><span class="line">        listenerContainers.put(clientId, messageListenerContainer);</span><br><span class="line">        messageListenerContainer.setConnectionFactory(SpringContext.me().getBean(ActiveMQConnectionFactory.class));</span><br><span class="line">        messageListenerContainer.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        messageListenerContainer.setConcurrency(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        messageListenerContainer.setMessageListener(messageListener);</span><br><span class="line">        messageListenerContainer.setPubSubDomain(pubSubDomain);</span><br><span class="line">        messageListenerContainer.setDestination(pubSubDomain</span><br><span class="line">                ? <span class="keyword">new</span> ActiveMQTopic(destination) : <span class="keyword">new</span> ActiveMQQueue(destination));</span><br><span class="line">        messageListenerContainer.setClientId(clientId);</span><br><span class="line">        messageListenerContainer.setMessageSelector(messageSelector);</span><br><span class="line">        messageListenerContainer.afterPropertiesSet();</span><br><span class="line">        messageListenerContainer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止监听容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId 客户端ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMessageListener</span><span class="params">(String clientId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;[动态JMS监听] 停止并移除监听：[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">        MessageListenerContainer messageListenerContainer = listenerContainers.get(clientId);</span><br><span class="line">        messageListenerContainer.stop(() -&gt; stoppedContainers.add(clientId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建客户端ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination 目的地</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId     公司ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildClientId</span><span class="params">(String destination, Long groupId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> destination + DynamicConstant.CLIENT_ID_SPLIT_CHAR + groupId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从客户端ID从解析出公司ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId 客户端ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">resolveGroupIdFromClientId</span><span class="params">(String clientId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(clientId.substring(</span><br><span class="line">                clientId.lastIndexOf(DynamicConstant.CLIENT_ID_SPLIT_CHAR)</span><br><span class="line">                        + DynamicConstant.CLIENT_ID_SPLIT_CHAR.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据不同集团、订阅主题生成不同的 clientId 并创建不同的消息监听器  refreshMessageListenerContainer(List<Long> groupIds)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientId生成规则：$&#123;destination&#125; + <span class="string">&quot;::&quot;</span> + $&#123;groupId&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>若集团状态被删除，则暂停对应的消息监听器.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageListenerContainer.stop()</span><br></pre></td></tr></table></figure><ol start="5"><li>若集团状态从删除变更为正常，则重新启动对应的消息监听器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageListenerContainer.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h3 id=&quot;JMS提出背景&quot;&gt;&lt;a href=&quot;#JMS提出背景&quot; class=&quot;headerlink&quot; title=&quot;JMS提出背景&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="mq" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/mq/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis 框架快速理解与应用</title>
    <link href="https://huangyuye.github.io/2021/05/06/yuque/Mybatis%20%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://huangyuye.github.io/2021/05/06/yuque/Mybatis%20%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-06T02:26:54.000Z</published>
    <updated>2021-05-24T12:55:41.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="#DSTAT">Mybatis</a></li><li><input checked="" disabled="" type="checkbox"> <a href="#QAHsL">Spring/SpringBoot 整合 MyBatis</a></li><li><input checked="" disabled="" type="checkbox"> <a href="#FdsR7">MyBatis-Plus</a></li></ul><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>是一款 ORM 持久层框架，致力于减少使用成本，让用户能更专注于 SQL 代码</li><li>免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作</li><li>可以通过简单的 <code>XML</code> 或 <code>注解</code> 来配置和映射原始类型、接口和 Java POJO 为数据库中的记录（ORM）<blockquote><p>摘自官网</p></blockquote></li></ul><p><a href="https://mybatis.org/mybatis-3/zh/index.html">官网地址</a></p><h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><p><code>SqlSessionFactory</code> &amp; <code>SqlSession</code></p><h3 id="核心对象作用域（Scope）和生命周期"><a href="#核心对象作用域（Scope）和生命周期" class="headerlink" title="核心对象作用域（Scope）和生命周期"></a>核心对象作用域（Scope）和生命周期</h3><h4 id="SqlSession-amp-映射器"><a href="#SqlSession-amp-映射器" class="headerlink" title="SqlSession &amp; 映射器"></a>SqlSession &amp; 映射器</h4><p>在每次数据库访问时都会构造实例，方法作用域，不能复用<br>需是线程安全的、基于事务的 SqlSession 和映射器</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>单例，在应用中主要负责在访问数据库的时候构建 <code>SqlSession</code> 实例<br>系统运行过程中会涉及 N 次数据库访问，所以需要频繁构建<code>SqlSession</code>实例，所以应用程序需要持有<code>SqlSessionFactory</code>实例并重复利用</p><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>一次性，在构造出 <code>SqlSessionFactory</code>后直接销毁即可</p><h3 id="核心对象装配"><a href="#核心对象装配" class="headerlink" title="核心对象装配"></a>核心对象装配</h3><p>两种装配方式（摘自<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">官网</a>）</p><ul><li><code>JavaConfig</code></li><li><code>XML 配置</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用xml配置文件(文件流)或Java配置类作为build()方法入参</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(xxx);</span><br><span class="line">从 SqlSessionFactory 中获取 SqlSession,并执行sql语句</span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">session.xxxMethodInvoke(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sql-语句映射"><a href="#Sql-语句映射" class="headerlink" title="Sql 语句映射"></a>Sql 语句映射</h3><h4 id="两种定义方式"><a href="#两种定义方式" class="headerlink" title="两种定义方式"></a>两种定义方式</h4><ol><li>使用 xml 文件定义 Sql 语句<ul><li>头部和文档类型声明</li><li>sql 语句全限定名：命名空间 + ID</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在映射器中使用注解定义 Sql 语句（<code>映射器是一些绑定映射语句的接口，实例由SqlSession创建</code>）<ul><li>注意映射器类的包名与 sql 映射语句的命名空间相同</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example.BlogMapper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种调用方式"><a href="#两种调用方式" class="headerlink" title="两种调用方式"></a>两种调用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// eg：xxx为 org.mybatis.example.BlogMapper.selectBlog</span></span><br><span class="line">  <span class="comment">// 命名空间 “org.mybatis.example.BlogMapper” 下定义的名为&quot;selectBlog&quot;的sql映射语句的方法调用</span></span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">&quot;xxx&quot;</span>, <span class="number">101</span>);</span><br><span class="line">  <span class="comment">// 使用全限定名调用 Java 对象的方法（映射器类）</span></span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上第二种方式中，说明可以直接映射到在与 sql 映射语句<strong>相同命名空间</strong>的<strong>映射器类</strong>，并将已映射的 sql 语句匹配到映射器类中对应名称、参数和返回类型的方法，调用该方法等同于执行 sql 映射语句<ul><li>映射器类方法与 sql 语句的绑定：拥有<strong>相同全限定名</strong>的<code>sql语句</code>与<code>映射器类方法</code><ul><li>SQL 语句：命名空间 + ID</li><li>映射器类方法：类全限定名 + 方法名</li></ul></li></ul></li><li><strong>注意</strong>：使用 sql 语句全限定名方式调用的时候，调用的是 session.selectOne 方法，而映射器类可以直接调用到具体的类方法</li><li>直接使用映射器类的优势：<ul><li>不依赖于字符串字面值，会更安全一点</li><li>代码补全可以帮你快速选择到映射好的 SQL 语句</li></ul></li></ul><h3 id="框架配置-XML-配置项"><a href="#框架配置-XML-配置项" class="headerlink" title="框架配置-XML 配置项"></a>框架配置-XML 配置项</h3><ul><li>configuration（配置）<ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a><blockquote><p>摘自官网，传送门：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">配置</a></p></blockquote></li></ul></li></ul><p><strong>TODO… 配置示例</strong></p><h3 id="SQL-映射-XML-配置项"><a href="#SQL-映射-XML-配置项" class="headerlink" title="SQL 映射-XML 配置项"></a>SQL 映射-XML 配置项</h3><ul><li>cache– 该命名空间的缓存配置。</li><li>cache-ref– 引用其它命名空间的缓存配置。</li><li>resultMap– <strong>描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</strong></li><li><del>parameterMap~~~~– 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del></li><li>sql– 可被其它语句引用的可重用语句块。</li><li>insert– 映射插入语句。</li><li>update– 映射更新语句。</li><li>delete– 映射删除语句。</li><li>select– 映射查询语句。<blockquote><p>摘自官网，传送门：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">XML 映射器</a></p></blockquote></li></ul><p><strong>TODO… 开发示例</strong></p><h2 id="Spring-SpringBoot-整合-MyBatis"><a href="#Spring-SpringBoot-整合-MyBatis" class="headerlink" title="Spring/SpringBoot 整合 MyBatis"></a>Spring/SpringBoot 整合 MyBatis</h2><p><a href="https://mybatis.org/spring/zh/index.html">MyBatis-Spring 官网</a><br><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">Mybatis-spring-boot-starter 官网</a></p><p>一般项目开发过程需要根据项目使用的框架自行选用</p><ol><li>单独使用 MyBatis</li><li>Spring 整合 Mybatis</li><li>Spring Boot 整合</li></ol><p>不过使用哪种方式，你都需要了解 MyBatis 框架本身的核心对象和工作原理，Spring 或者 Spring Boot 的集成只是简化了 MyBatis 的配置及使用方式，底层核心对象工作原理不变。<br>由于我这里直接选用了 MyBatis 框架的增加版本 MyBatis-Plus，所以该章节讲到的两种方式还没有用到，下次回来补充。</p><p><strong>TODO…</strong></p><h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baomidou.com/guide/">MyBatis-Plus</a> 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作<blockquote><p>摘自官网</p></blockquote></li></ul><h3 id="从零开始引用步骤"><a href="#从零开始引用步骤" class="headerlink" title="从零开始引用步骤"></a>从零开始引用步骤</h3><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ul><li>Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- 按需调整版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 基础依赖：数据库驱动 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SpringBoot 启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跳过打包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加skipTests属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 使用以下maven插件 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h4><ul><li>Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>SpringBoot 启动类使用<code>@MapperScan</code>注解指定映射类路径</li></ul><h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><ul><li>Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis封装的多数据源控制 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-dynamic-datasource.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yaml 配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master_1</span> <span class="comment">#设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span> <span class="comment">#设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master_1:</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br></pre></td></tr></table></figure><ul><li>根据需要，在方法或类上使用 <code>@DS</code> 注解指定数据源</li><li>工作原理核心类<ul><li><code>DynamicDataSourceAnnotationInterceptor</code>：<ul><li>@DS 注解拦截器，获取注解中指定的数据源并切<strong>换线程本地变量</strong></li></ul></li><li><code>com.baomidou.dynamic.datasource.ds.AbstractRoutingDataSource.getConnection()</code>：<ul><li>数据库访问获取数据库连接时根据<strong>线程本地变量</strong>切换不同数据源</li></ul></li></ul></li></ul><h4 id="使用内存数据库"><a href="#使用内存数据库" class="headerlink" title="使用内存数据库"></a>使用内存数据库</h4><ul><li>Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- h2内存数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;h2database.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yaml 文件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    <span class="keyword">dynamic</span>:</span><br><span class="line">      <span class="keyword">primary</span>: master_1 #设置默认的数据源或者数据源组,默认值即为master</span><br><span class="line">      strict: <span class="literal">false</span> #设置严格模式,默认<span class="literal">false</span>不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.</span><br><span class="line">      datasource:</span><br><span class="line">        master_1:</span><br><span class="line">          driver<span class="operator">-</span>class<span class="operator">-</span>name: org.h2.Driver</span><br><span class="line">          schema: classpath:db<span class="operator">/</span>schema<span class="operator">-</span>h2.sql</span><br><span class="line">          data: classpath:db<span class="operator">/</span>data<span class="operator">-</span>h2.sql</span><br><span class="line">          url: jdbc:h2:mem:test</span><br></pre></td></tr></table></figure><ul><li>db/schema-h2.sql（按需修改 DDL 语句）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>db/data-h2.sql（按需修改 DDL 语句）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="配置文件加解密"><a href="#配置文件加解密" class="headerlink" title="配置文件加解密"></a>配置文件加解密</h4><p>配置文件中的敏感内容如果以明文形式保存，一旦泄露出去可能对资产安全造成威胁，所以一般需要对配置文件敏感信息进行加密，以下使用的是 Jasypt 加解密工具</p><ul><li>Maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件加密 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jasypt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>加解密工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huangyuye.dbmigrate.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jasypt.util.text.BasicTextEncryptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: yuye.huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>: 2021/5/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JasyptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        jasypt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Scanner</span></span><br><span class="line"><span class="comment">     * 优点一: 可以获取键盘输入的字符串</span></span><br><span class="line"><span class="comment">     * 优点二: 有现成的获取int,float等类型数据，非常强大，也非常方便；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jasypt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 监听输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Use Jasypt Encrypt, Please Enter Secret:&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取字符串型输入</span></span><br><span class="line">        String secret = sc.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(secret)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Blank Secret, Exit&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(sc, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Scanner sc, String secret)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Use Jasypt Encrypt, Encrypt(1) Or Decrypt(2) Or Exit(3)? (1/2/3)：&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取整型输入</span></span><br><span class="line">        <span class="keyword">int</span> type = sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Use Jasypt Encrypt, Please Enter Text：&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Use Jasypt Decrypt, Please Enter EncryptedText：&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bye Bye&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        String text = sc.nextLine();</span><br><span class="line">        String output = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            output = encrypt(text, secret);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            output = decrypt(text, secret);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Use Jasypt Encrypt, Output: &quot;</span> + output);</span><br><span class="line">        <span class="comment">// 空行</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 继续执行</span></span><br><span class="line">        process(sc, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String text, String secret)</span> </span>&#123;</span><br><span class="line">        BasicTextEncryptor encryptor = <span class="keyword">new</span> BasicTextEncryptor();</span><br><span class="line">        encryptor.setPassword(secret);</span><br><span class="line">        <span class="keyword">return</span> encryptor.encrypt(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String text, String secret)</span> </span>&#123;</span><br><span class="line">        BasicTextEncryptor encryptor = <span class="keyword">new</span> BasicTextEncryptor();</span><br><span class="line">        encryptor.setPassword(secret);</span><br><span class="line">        <span class="keyword">return</span> encryptor.decrypt(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>yaml 配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件加密密钥，建议放到环境变量</span></span><br><span class="line"><span class="attr">jasypt:</span></span><br><span class="line">  <span class="attr">encryptor:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;WM_PASSWORD&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 已加密的配置使用 `ECN()` 包围</span></span><br></pre></td></tr></table></figure><ul><li>想要对文本进行加解密时，执行<code>JasyptTest</code>的<code>main</code>方法根据提示执行即可。注意在使用该工具类解密时输入的密文不需要使用**”ENC()”<strong>包围，但是加密后的密文在配置文件中需要使用</strong>“ENC()”**包围以提供给框架识别</li></ul><h4 id="MybatisX-插件"><a href="#MybatisX-插件" class="headerlink" title="MybatisX 插件"></a>MybatisX 插件</h4><p><a href="https://baomidou.com/guide/mybatisx-idea-plugin.html#%E5%8A%9F%E8%83%BD">在 idea 中下载该插件</a>，使用该插件快速生成 xml、mapper、entity，且可以帮助你在 idea 中更智能进行文件切换</p><h4 id="mybatis-plus-代码生成工具"><a href="#mybatis-plus-代码生成工具" class="headerlink" title="mybatis-plus 代码生成工具"></a>mybatis-plus 代码生成工具</h4><ul><li><p>参考链接：<a href="https://www.jianshu.com/p/33b643bf001f">https://www.jianshu.com/p/33b643bf001f</a></p></li><li><p>Maven 依赖</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>部分信息使用配置文件方式配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle rb = ResourceBundle.getBundle(<span class="string">&quot;mybatis-plus&quot;</span>);</span><br><span class="line"><span class="comment">// todo rb.get...</span></span><br></pre></td></tr></table></figure><p>[</p><p>](<a href="https://www.jianshu.com/p/33b643bf001f">https://www.jianshu.com/p/33b643bf001f</a>)</p><h4 id="Mybatis-查询映射-DTO"><a href="#Mybatis-查询映射-DTO" class="headerlink" title="Mybatis 查询映射 DTO"></a>Mybatis 查询映射 DTO</h4><p>todo</p><h4 id="Test-注解"><a href="#Test-注解" class="headerlink" title="@Test  注解"></a><a href="/Test">@Test </a> 注解</h4><p>使用 <code>@org.junit.jupiter.api.Test</code> 而非 <code>@org.junit.Test</code>，后者会导致不能正常注册 springboot 应用</p><h4 id="表字段默认值填充：自动填充功能"><a href="#表字段默认值填充：自动填充功能" class="headerlink" title="表字段默认值填充：自动填充功能"></a>表字段默认值填充：自动填充功能</h4><ul><li>注解填充字段 @TableField(.. fill = FieldFill.INSERT) 生成器策略部分也可以配置！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意！这里需要标记为填充字段</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> String fillField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现元对象处理器接口：<code>com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</code><ul><li>自定义实现类 MyMetaObjectHandler</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now()); <span class="comment">// 起始版本 3.3.0(推荐使用)</span></span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;createTime&quot;</span>, () -&gt; LocalDateTime.now(), LocalDateTime.class); <span class="comment">// 起始版本 3.3.3(推荐)</span></span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="keyword">this</span>.fillStrategy(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.now()); <span class="comment">// 也可以使用(3.3.0 该方法有bug)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：目前测试只对单个对象的操作有效</li></ul><h4 id="配置分页拦截器（不配置-IPAGE-分页无效）"><a href="#配置分页拦截器（不配置-IPAGE-分页无效）" class="headerlink" title="配置分页拦截器（不配置 IPAGE 分页无效）"></a>配置分页拦截器（不配置 IPAGE 分页无效）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">/*旧版本配置</span></span><br><span class="line"><span class="comment">@Bean</span></span><br><span class="line"><span class="comment">public PaginationInterceptor paginationInterceptor()&#123;</span></span><br><span class="line"><span class="comment">return new PaginationInterceptor();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line"><span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> configuration -&gt; configuration.setUseDeprecatedExecutor(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sql-映射语句"><a href="#sql-映射语句" class="headerlink" title="sql 映射语句"></a>sql 映射语句</h4><ul><li>定义通用的语句并在其他语句中复用 <code>&lt;include&gt;</code>标签</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用sql */</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">sql</span> id<span class="operator">=</span>&quot;Base_Column_List&quot;<span class="operator">&gt;</span></span><br><span class="line">    id,create_time,update_time, table_schema,table_name,need_migrate, priority,filter_mark</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">sql</span><span class="operator">&gt;</span></span><br><span class="line"><span class="comment">/* 使用&lt;include refid=“”/&gt;标签引用sql */</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> id<span class="operator">=</span>&quot;insertIgnore&quot;<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">insert</span> ignore <span class="keyword">into</span> db_migrate_table_info(</span><br><span class="line">  <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot; <span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">  )</span><br><span class="line">  select null, now(), now(), #&#123;tableSchema&#125;,`TABLE_NAME`, null, null, null</span><br><span class="line">  <span class="keyword">from</span> information_schema.TABLES</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">insert</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>遍历参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该语句接收一个名为&quot;dbValues&quot;的集合类型的参数，并以&quot;,&quot;分隔集合元素，且集合的元素仍为集合； */</span></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">sql</span> id<span class="operator">=</span>&quot;values&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>foreach item<span class="operator">=</span>&quot;item&quot; collection<span class="operator">=</span>&quot;dbValues&quot; separator<span class="operator">=</span>&quot;,&quot; <span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;item&quot; item<span class="operator">=</span>&quot;detailItem&quot; index<span class="operator">=</span>&quot;index&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot;</span><br><span class="line">                 <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot;  separator<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;detailItem&#125;</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">sql</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul><li><p>参数：</p><ul><li>corePoolSize：线程池中核心线程数的数量</li><li>maximumPoolSize：在线程池中允许存在的最大线程数</li><li>maximumQueueSize： 线程缓冲队列数量</li><li>workQueue：工作队列，线程池中的当前线程数大于核心线程的话，那么接下来的任务会放入到队列中</li></ul></li><li><p>逻辑：</p><ul><li>前 corePoolSize 个任务时，来一个任务就创建一个线程</li><li>如果此时线程池中的当前线程大于了 maximumPoolSize 最大线程数，那么就会执行我们刚才设置的 handler 拒绝策略</li><li>handler：如果超过了最大线程数 maximumPoolSize，那么就会执行我们设置的拒绝策略</li></ul></li></ul><p>理解：</p><ul><li><p>maximumPoolSize + maximumQueueSize = 同一时刻线程池能处理的线程数量</p></li><li><p>maximumPoolSize = 线程池中存在的线程数量大小（若设置为 32，则只会有 32 个线程处理请求）</p></li><li><p>maximumQueueSize：将超过 maximumPoolSize 的请求线程放到队列中，队列能存放的大小</p></li><li><p>java 获取核心数：Runtime.getRuntime().availableProcessors()</p></li></ul><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><ul><li>Logback, Log4J2 , java util logging<ul><li>Spring Boot 默认使用 Logback 作为日志记录工具</li><li>如果希望引入其他日志框架，需要在引用 springboot 的时候排除依赖：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yaml 配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="comment"># 日志级别，后面跟类路径，给不同路径设置不同日志级别</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">security:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">hibernate:</span> <span class="string">DEBUG</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">logs</span> <span class="comment"># 日志文件路径(相对于项目的路径)</span></span><br><span class="line">  <span class="attr">pattern:</span> <span class="comment"># 日志输出格式</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&quot;%d&#123;yyyy-MMM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;15&#125; - %msg%n&quot;</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">&quot;%d&#123;yyyy-MMM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;15&#125; - %msg%n&quot;</span></span><br></pre></td></tr></table></figure><ul><li>参考链接：<a href="https://www.jianshu.com/p/1fa12b92d5c4">https://www.jianshu.com/p/1fa12b92d5c4</a></li></ul><h4 id="HikariCP-配置"><a href="#HikariCP-配置" class="headerlink" title="HikariCP 配置"></a>HikariCP 配置</h4><ul><li>出现问题：<code>java.sql.SQLException: Connection reset</code><ul><li>解决方案：<ul><li>配置连接池的 validationQuery 属性，检查不可用连接</li></ul></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>以下内容尚未整理</strong></p><ul><li>嵌套语句：如关联查询主表+子表</li><li>自定义 sql 解析的类型处理器<ul><li>实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler</li></ul></li><li>本地缓存和二级缓存</li><li><strong>与 mybatis-plus、spring-data-jpa 实现的对比</strong></li><li><a href="http://mybatis.org/spring/zh/batch.html"><strong>springbatch</strong></a></li><li><strong>多数据源</strong><ul><li><a href="https://baomidou.com/guide/dynamic-datasource.html#%E6%96%87%E6%A1%A3-documentation">https://baomidou.com/guide/dynamic-datasource.html#%E6%96%87%E6%A1%A3-documentation</a></li><li><a href="https://blog.csdn.net/u013360850/article/details/78861442">https://blog.csdn.net/u013360850/article/details/78861442</a></li><li><a href="https://blog.csdn.net/w57685321/article/details/106823660">https://blog.csdn.net/w57685321/article/details/106823660</a></li><li><a href="https://dynamic-datasource.com/">https://dynamic-datasource.com/</a></li></ul></li><li>lombok @Accessors</li><li><a href="https://www.codenong.com/cs106097869/">mybatis insert 动态生成插入的列及批量插入值</a></li><li>配置文件加解密与监听控制台输入<ul><li><a href="https://blog.csdn.net/wangmx1993328/article/details/106421101">https://blog.csdn.net/wangmx1993328/article/details/106421101</a></li></ul></li><li>springboot 整合 mybatis<ul><li><a href="https://www.jianshu.com/p/1601f466fa90">https://www.jianshu.com/p/1601f466fa90</a></li></ul></li><li>springboot 整合 mybatis-plus 生成器<ul><li><a href="https://www.jianshu.com/p/33b643bf001f">https://www.jianshu.com/p/33b643bf001f</a></li></ul></li><li>引入迁移工具</li><li>@SqlProvider<ul><li>CRUD：@SelectProvider</li><li>Sql 类构造 sql</li><li>参考链接：<ul><li><a href="https://www.geek-share.com/detail/2804291685.html">https://www.geek-share.com/detail/2804291685.html</a></li><li><a href="https://mybatis.org/mybatis-3/zh/statement-builders.html">https://mybatis.org/mybatis-3/zh/statement-builders.html</a></li></ul></li></ul></li><li>使用不同的 <code>@Test</code>注解，结果不一样<ul><li>org.junit.jupiter.api</li><li>org.junit：不能正常注册 springboot 应用</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文章内容&quot;&gt;&lt;a href=&quot;#文章内容&quot; class=&quot;headerlink&quot; title=&quot;文章内容&quot;&gt;&lt;/a&gt;文章内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;a href=&quot;</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库迁移记录</title>
    <link href="https://huangyuye.github.io/2021/04/29/yuque/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
    <id>https://huangyuye.github.io/2021/04/29/yuque/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-29T07:59:05.000Z</published>
    <updated>2021-05-24T12:55:41.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="简单场景数据迁移"><a href="#简单场景数据迁移" class="headerlink" title="简单场景数据迁移"></a>简单场景数据迁移</h2><h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><h4 id="导出表结构和表数据"><a href="#导出表结构和表数据" class="headerlink" title="导出表结构和表数据"></a>导出表结构和表数据</h4><p>1、导出数据库為 dbname 的表结构（其中用戶名為 root,密码為 dbpasswd,生成的脚本名為 db.sql）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pdbpasswd <span class="operator">-</span>d dbname <span class="operator">&gt;</span>db.sql;</span><br></pre></td></tr></table></figure><p>2、导出數據库為 dbname 某张表(test)结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pdbpasswd <span class="operator">-</span>d dbname test<span class="operator">&gt;</span>db.sql;</span><br></pre></td></tr></table></figure><p>3、导出數據库為 dbname 所有表结构及表數據（不加-d）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pdbpasswd  dbname <span class="operator">&gt;</span>db.sql;</span><br></pre></td></tr></table></figure><p>4、导出數據库為 dbname 某张表(test)结构及表數據（不加-d）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pdbpasswd dbname test<span class="operator">&gt;</span>db.sql;</span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="按条件导出"><a href="#按条件导出" class="headerlink" title="按条件导出"></a>按条件导出</h4><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名 表名 <span class="comment">--where=&quot;筛选条件&quot; &gt; 导出文件路径</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h11<span class="number">.11</span><span class="number">.11</span><span class="number">.63</span> <span class="operator">-</span>uroot <span class="operator">-</span>p09327399 shentb<span class="operator">-</span>pro tbl_addresslist <span class="comment">--where=&quot;createtime &gt; &#x27;2019-02-27 00:00:00&#x27; and</span></span><br><span class="line">createtime <span class="operator">&lt;</span> <span class="string">&#x27;2019-02-27 23:59:00&#x27;</span>&quot; &gt; tbl_addresslist.sql</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="导入目标库"><a href="#导入目标库" class="headerlink" title="导入目标库"></a>导入目标库</h3><p>导出的文件是标准的 sql 语句，可直接导入至新库。<strong>登入 Mysql：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h xxxx <span class="operator">-</span>uroot <span class="operator">-</span>pxxxx shentb<span class="operator">-</span>pro</span><br><span class="line">mysql <span class="operator">-</span>h11<span class="number">.11</span><span class="number">.11</span><span class="number">.11</span> <span class="operator">-</span>uroot <span class="operator">-</span>ppassword</span><br></pre></td></tr></table></figure><p><strong>显示数据库列表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p><strong>切换到要操作的数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use database_name;</span><br></pre></td></tr></table></figure><p><strong>执行导入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="operator">/</span>root<span class="operator">/</span>file.txt</span><br></pre></td></tr></table></figure><h2 id="特殊场景"><a href="#特殊场景" class="headerlink" title="特殊场景"></a>特殊场景</h2><p>假设系统版本将从 v1 升级到 v2，但是旧系统存量客户并不想升级，此时会出现两个版本系统线上并行情况。<br>且系统使用的是单实例数据库，若新版本系统还继续迭代，很可能就会出现表结构变更且旧版本系统不能兼容的情况，此时就需要将系统数据源拆分成不同实例，原有数据库的业务数据需要同步到新的数据库，此时新旧系统分别实体 db1 和 db2 数据库，且后续还会陆续将旧系统升级并迁移旧系统数据库。</p><p>而部分数据库表设计中，可能会使用数据库自增 id 作为其他业务表的关联键，那么新旧系统并行过程中就要保证两个数据库的 id 号不能冲突，解决冲突的方式有：</p><ul><li><strong>将新系统相关业务表的自增 id 号翻倍，预留出充足的 id 号供旧系统使用</strong><ul><li>梳理出使用自增 id 作为关联键的数据表，查询出当前最大自增 id 号 N，将新数据库中该表的 id 号修改为 N 的倍数（<strong>倍数根据场景修改</strong>）</li></ul></li><li><strong>修改新旧系统的自增 id 号的步长和偏移量，保证两个数据库产生的 id 号不重复（需重启数据库）</strong><ul><li><code>auto_increment_increment</code>：id 号增量值，也就是步长</li><li><code>auto_increment_offset</code>：id 号起始值</li></ul></li></ul><p>一般建议系统先做好数据库主从，这样在迁移的时候能保证只停从库，不对其他客户的业务产生影响。且有临时库可以让你更方便的做迁移准备工作</p><h3 id="如何修改数据表的自增-id-号？"><a href="#如何修改数据表的自增-id-号？" class="headerlink" title="如何修改数据表的自增 id 号？"></a>如何修改数据表的自增 id 号？</h3><p>除此之外，你将会遇到的问题是如何将旧数据库的 id 号同步到新数据库中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table #&#123;tableName&#125; AUTO_INCREMENT = #&#123;toId&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何修改自增-id-号的步长和偏移量？"><a href="#如何修改自增-id-号的步长和偏移量？" class="headerlink" title="如何修改自增 id 号的步长和偏移量？"></a>如何修改自增 id 号的步长和偏移量？</h3><p><strong>查看当前数据库配置</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;auto_inc%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>两种方式可以修改自增 id 号的步长和偏移量</strong></p><ul><li>修改 mysql 配置文件方式</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="operator">/</span>etc<span class="operator">/</span>my.cnf</span><br><span class="line">auto_increment_increment = &#123;n1&#125;;</span><br><span class="line">auto_increment_offset = &#123;n2&#125;;</span><br></pre></td></tr></table></figure><ul><li>sql 语句修改（仅同一连接会话生效）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="operator">&gt;</span> <span class="number">1227</span> <span class="operator">-</span> Access denied; you need (<span class="keyword">at</span> least <span class="keyword">one</span> <span class="keyword">of</span>) the SUPER privilege(s) <span class="keyword">for</span> this operation</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> auto_increment_increment <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">10</span>;  <span class="operator">/</span><span class="operator">/</span>设置步长</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> auto_increment_offset <span class="operator">=</span> <span class="number">10000</span>;  <span class="operator">/</span><span class="operator">/</span>设置起始偏移量</span><br><span class="line"># 系统定义的全局变量（又称系统变量）都是以@@开头，用户自定义变量（简称用户变量）以@开头</span><br></pre></td></tr></table></figure><p>会话 session：只对当前会话产生影响,退出 mysql 后失效<br>全局 GLOBAL：对以后的 mysql 的连接都生效的，重启 mysql 后失效（reload 重载不会）<br>/etc/my.cnf 修改后重启永久生效</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="Mysql-变量"><a href="#Mysql-变量" class="headerlink" title="Mysql 变量"></a>Mysql 变量</h3><p>1、局部变量(存储过程变量 declare)<br>2、用户变量：用户变量 在客户端链接到数据库实例整个过程中用户变量都是有效的<br>3、会话变量<br>4、全局变量</p><h3 id="定义变量方式"><a href="#定义变量方式" class="headerlink" title="定义变量方式"></a>定义变量方式</h3><ul><li>使用 set 或 select 直接赋值，变量名以 @ 开头.</li><li>以 DECLARE 关键字声明的变量，只能在存储过程中使用，称为存储过程变量</li></ul><h3 id="存储过程语法"><a href="#存储过程语法" class="headerlink" title="存储过程语法"></a>存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    [DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">　<span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">    [ <span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span> ] param_name type</span><br><span class="line"></span><br><span class="line">characteristic:</span><br><span class="line">    COMMENT <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  <span class="operator">|</span> <span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">  <span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line">  | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">  | SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line"></span><br><span class="line">routine_body:</span><br><span class="line">　　Valid <span class="keyword">SQL</span> routine statement</span><br><span class="line">[begin_label:] <span class="keyword">BEGIN</span></span><br><span class="line">　　[statement_list]</span><br><span class="line">　　　　……</span><br><span class="line"><span class="keyword">END</span> [end_label]</span><br></pre></td></tr></table></figure><h3 id="存储过程实例"><a href="#存储过程实例" class="headerlink" title="存储过程实例"></a>存储过程实例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> demo_out_parameter(<span class="keyword">OUT</span> p_out <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_out;</span><br><span class="line">    <span class="keyword">SET</span> p_out<span class="operator">=</span></span><br><span class="line">    <span class="keyword">SELECT</span> p_out;</span><br><span class="line">    <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@p</span>_out<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">CALL</span> sp_demo_out_parameter(<span class="variable">@p</span>_out);</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/7b2d74701ccd">mysql 存储过程详细教程</a><br><a href="https://segmentfault.com/a/1190000039248897">针对新手的 MYSQL 存储过程详解</a><br><a href="https://segmentfault.com/a/1190000022856142">MySQL 存储过程编写指南</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>雪花算法<ul><li><a href="https://www.cnblogs.com/wuzhenzhao/p/13295382.html">分布式 ID 常见生成策略</a></li><li><a href="https://www.jianshu.com/p/0a7c527ccc13">数据库 ID 生成方案：号段模式</a></li></ul></li><li>Mysql 设置 auto_increment_increment 和 auto_increment_offset<ul><li>show variables like ‘%auto_inc%’;</li></ul></li><li><a href="https://segmentfault.com/a/1190000018780990">关于自增 id 你可能还不知道</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;简单场景数据迁移&quot;&gt;&lt;a href=&quot;#简单场景数据迁移&quot; class=&quot;headerlink&quot; title=&quot;简单场景数据迁移&quot;&gt;&lt;/a&gt;简单场</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>Java代码生成工具</title>
    <link href="https://huangyuye.github.io/2021/04/21/yuque/Java%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangyuye.github.io/2021/04/21/yuque/Java%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/</id>
    <published>2021-04-21T03:47:05.000Z</published>
    <updated>2021-05-24T12:55:41.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li>根据<strong>ddl</strong>生成<code>实体</code>、<code>controller</code>、<code>service</code>、<code>dao</code><ul><li>可使用<code>懒猴子CG</code>在线生成工具</li></ul></li><li>根据<strong>json</strong>生成<code>实体</code><ul><li>可使用<code>BEJSON</code>在线生成工具</li><li>json 还可以用来生成.http 文件实例数据</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://cn2oo8.github.io/molicode_doc/">molicode 官网</a></li><li><a href="https://www.oschina.net/news/109592/molicode-2-1-released">MoliCode 2.1 发布，自定义模板在线代码生成器</a></li><li><a href="https://zhuanlan.zhihu.com/p/348315400">推荐几个代码自动生成器，神器！！！</a></li><li><a href="https://www.bejson.com/json2javapojo/new/">BEJSON 在线 json 转 Java</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见场景&quot;&gt;&lt;a href=&quot;#常见场景&quot; class=&quot;headerlink&quot; title=&quot;常见场景&quot;&gt;&lt;/a&gt;常见场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据&lt;strong&gt;ddl&lt;/strong&gt;生成&lt;code&gt;实体&lt;/code&gt;、&lt;code&gt;controller</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>PicGo + GitHub 创建自己的免费图床</title>
    <link href="https://huangyuye.github.io/2021/04/17/yuque/PicGo%20+%20GitHub%20%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
    <id>https://huangyuye.github.io/2021/04/17/yuque/PicGo%20+%20GitHub%20%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</id>
    <published>2021-04-17T12:38:26.000Z</published>
    <updated>2021-05-24T12:55:41.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>这个星球上最流行的开源托管服务器，用它来作为你的图片存储服务器，即图床<br><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618668906947-261d1e65-e855-489b-9a6d-7bb0f117c9ca.png#clientId=ue52606ac-79c2-4&from=paste&height=656&id=u34160917&margin=%5Bobject%20Object%5D&originHeight=656&originWidth=1350&originalType=binary&size=637965&status=done&style=none&taskId=uc320dc79-8208-49bf-ba29-76d1cfa0048&width=1350"></p><h3 id="创建你的仓库存放图片"><a href="#创建你的仓库存放图片" class="headerlink" title="创建你的仓库存放图片"></a>创建你的仓库存放图片</h3><p>登陆 <a href="https://github.com/">Github</a> 创建属于你自己的 GitHub 账号之后，新建一个 Repository（即仓库，无脑创建即可），用来存放你的图片<br>接下来，为了随时随地都能将电脑本地的图片上传到你的图片存储服务器上，你还需要拿到对 Github Repository 的访问&amp;操作权限，即需要获取到仓库的 access_token。有了访问令牌，你就可以随时向仓库上传本地文件，以下是配置访问令牌的步骤（**直达步骤 4 的链接点 **<a href="https://github.com/settings/tokens/new"><strong>这里</strong></a>** **）</p><ol><li>登录 Github，点击右上角头像后下拉选项中的 <code>Settings</code></li><li>点击左侧侧边栏 <code>Developer Settings</code></li><li>点击左侧侧边栏 <code>Personal access tokens</code></li><li>点击 <code>Generates new token</code> (Note 随意填，repo 勾选后下拉到页尾点击 <code>Generate token</code>)</li><li>该 token 记得保存起来，页面只会在你创建完之后明文显示一次</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618664979729-db94f685-9c6d-45c7-84f8-b86028406175.png#clientId=ue52606ac-79c2-4&from=paste&height=594&id=u71b5ab83&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=1001&originalType=binary&size=55457&status=done&style=none&taskId=u48655feb-8986-49e7-aaff-87e5331d780&width=1001"></p><h3 id="如何为你的图片生成访问链接？"><a href="#如何为你的图片生成访问链接？" class="headerlink" title="如何为你的图片生成访问链接？"></a>如何为你的图片生成访问链接？</h3><p>图片存储到 github 仓库，自己或者别人想要快速访问的话，还需要使用接下来讲到的 <code>PicGo</code> 工具为你的图片生成访问链接</p><h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>一个用于快速上传图片并获取图片 URL 链接的工具，重点是免费。<br>有了它，可以快速地将我们的本地图片上传到图片服务器<br><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618668807333-44bad13a-9208-4d66-85fe-50b589907e4b.png#clientId=ue52606ac-79c2-4&from=paste&height=605&id=LqSbj&margin=%5Bobject%20Object%5D&originHeight=605&originWidth=1351&originalType=binary&size=54209&status=done&style=none&taskId=u3c3a37a5-682f-4737-810d-07badb7d497&width=1351"></p><h3 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h3><p>官网地址点 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/">这里</a><br>也可以直接点 <a href="https://github.com/Molunerfinn/PicGo/releases">这里</a> 下载安装后看下面的配置教程（Windows 用户直接下载<code>.exe</code>文件）<br>安装无脑安装即可，也可以自定义安装目录</p><h3 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h3><p>在第一节我们已经创建了 GitHub 图床，所以接下来可以配置 PicGo 的图片上传服务器为我们的 GitHub 图床<br><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618666126174-6fceecfb-516e-41a1-8dc2-56fc6f5edecd.png#clientId=ue52606ac-79c2-4&from=paste&height=450&id=u0960d7c6&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=800&originalType=binary&size=61363&status=done&style=none&taskId=ubb162e4f-eebc-4e99-a37b-fca88989b3b&width=800"></p><blockquote><p><strong>自定义域名格式：</strong><a href="https://raw.githubusercontent.com/[username]/[%E4%BB%93%E5%BA%93%E5%90%8D]/$%7B%E5%88%86%E6%94%AF%E5%90%8D%7D">https://raw.githubusercontent.com/[username]/[仓库名]/${分支名}</a><br>那这里我的自定义域名就为：<a href="https://raw.githubusercontent.com/huangyuye/huangyuye.github.io/data">https://raw.githubusercontent.com/huangyuye/huangyuye.github.io/data</a></p></blockquote><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>接下来，你可以使用多种方式上传你的图片，比如拖动图片到上传区、复制图片或者截图到你的剪贴板，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618666433026-0719bb2e-37a5-4678-8d99-0ab64b650fcb.png#clientId=ue52606ac-79c2-4&from=paste&height=450&id=u28f0996f&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=800&originalType=binary&size=29965&status=done&style=none&taskId=u1b65f923-3a8c-42f3-8519-f24790239bf&width=800"></p><ul><li>上传成功后，PicGo 自动会将图片的访问链接复制到你的剪贴板（可配置），你就可以随意使用啦</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618666555459-b6ef720d-d453-438b-ae51-e69115f99098.png#clientId=ue52606ac-79c2-4&from=paste&height=450&id=u0ef2f8f2&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=800&originalType=binary&size=30661&status=done&style=none&taskId=ue1bf144f-3e4c-4803-9a76-95c2027a1c0&width=800"></p><p><strong>到这里，你就已经拥有属于你自己的图床，并且可以快速的上传图片到你的图床啦</strong></p><h2 id="jsDelivr：加速图片访问"><a href="#jsDelivr：加速图片访问" class="headerlink" title="jsDelivr：加速图片访问"></a>jsDelivr：加速图片访问</h2><p>放在 Github 的资源在国内加载速度比较慢，因此可以使用<strong>CDN</strong>加速来优化网站打开速度，<code>jsDelivr</code>便是免费且好用的 CDN，非常适合博客网站使用</p><blockquote><p>CDN 的全称是 Content Delivery Network，即内容分发网络，可以加速资源的访问</p></blockquote><p>这里只要改下 PicGo 配置的自定义域名即可，像这样</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data">https://cdn.jsdelivr.net/gh/huangyuye/huangyuye.github.io@data</a><br>固定格式为：<a href="https://cdn.jsdelivr.net/gh/$%7BGitHub%E7%94%A8%E6%88%B7%E5%90%8D%7D/$%7B%E4%BB%93%E5%BA%93%7D@$%7B%E5%88%86%E6%94%AF%E5%90%8D%7D">https://cdn.jsdelivr.net/gh/${GitHub用户名}/${仓库}@${分支名}</a></p></blockquote><p>这样配置之后你就可以使用 PicGo 快速地上传图片，并且也可以快速地访问你 GitHub 存储的图片啦！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Typora-编辑器"><a href="#Typora-编辑器" class="headerlink" title="Typora 编辑器"></a>Typora 编辑器</h3><p>Typora 是一个优秀的 markdown 文本编辑工具，如果你没有使用过这款软件写 markdown 文件的话，那我在这里墙裂安利一下</p><p>使用这款软件码字经常需要插入图片资源，插入图片后 Typora 会默认给你存储到电脑本地目录，这样如果你写好的文档需要发出的话，别人就没办法加载文件中的图片。如果你想要别人也能看到你的图片的话，那你在往文档中插入图片之前就需要先把图片上传你的图片服务器并获取到图片访问外链，即使用我们这篇文章讲到的<strong>PicGo + GitHub</strong>啦。</p><p>这样当我们每次插入图片时都要手动使用<code>PicGo</code>这个工具先上传图片，再把上传成功后的图片外链复制到<code>**Typora**</code>文档中，这样虽然也很简单，但是我们还可以给<code>Typora</code>配置配置 <strong>上传服务</strong>，可以在往文档插入图片之后智能提示是否需要帮我们上传到图片服务器，具体步骤如下：</p><ol><li>打开 Typora 菜单：<strong>文件</strong> -&gt; <strong>偏好设置</strong></li><li>配置 <strong>图像 -&gt; 上传服务：</strong><ol><li>选择上传服务选项为 <code>PicGo(app)</code></li><li>PicGo 路径为你的工具下载路径</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618668573492-917a134b-3b6d-445c-b251-f00feca62fc3.png#clientId=ue52606ac-79c2-4&from=paste&height=693&id=u1eefe0a3&margin=%5Bobject%20Object%5D&originHeight=693&originWidth=786&originalType=binary&size=44987&status=done&style=none&taskId=uda10e895-f740-4bc9-b4b2-e35689dcd81&width=786"></p><ol start="3"><li>配置完成之后尽管往你的文档中插入图片，然后自己选择要不要上传到图片服务器</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1618668654780-ae508e6a-6fed-4007-a06c-83995f648ac8.png#clientId=ue52606ac-79c2-4&from=paste&height=693&id=uc199f491&margin=%5Bobject%20Object%5D&originHeight=693&originWidth=786&originalType=binary&size=78601&status=done&style=none&taskId=uf89af5bd-91cf-4db2-85aa-2aaf01ea45e&width=786"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GitHub&quot;&gt;&lt;a href=&quot;#GitHub&quot; class=&quot;headerlink&quot; title=&quot;GitHub&quot;&gt;&lt;/a&gt;GitHub&lt;/h2&gt;&lt;p&gt;这个星球上最流行的开源托管服务器，用它来作为你的图片存储服务器，即图床&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo主题美化</title>
    <link href="https://huangyuye.github.io/2021/04/11/yuque/Hexo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <id>https://huangyuye.github.io/2021/04/11/yuque/Hexo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</id>
    <published>2021-04-11T10:52:23.000Z</published>
    <updated>2021-05-24T12:55:41.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-概述"><a href="#Hexo-概述" class="headerlink" title="Hexo 概述"></a>Hexo 概述</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo?"></a>什么是 Hexo?</h2><p>Hexo 是一个博客框架，可以将 markdown 格式的文件解析成静态网页</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/">Hexo 官网</a></p><h2 id="基础文件"><a href="#基础文件" class="headerlink" title="基础文件"></a>基础文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站配置</span></span><br><span class="line">├── package.json <span class="comment"># 打包依赖</span></span><br><span class="line">├── scaffolds <span class="comment"># 模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件</span></span><br><span class="line">├── source <span class="comment"># 资源文件夹是存放用户资源的地方</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿箱</span></span><br><span class="line">|   └── _posts <span class="comment"># 源码</span></span><br><span class="line">└── themes <span class="comment"># 网站主题文件，Hexo 会根据主题来生成静态页面</span></span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo 有三种默认布局：post、page 和 draft</span></span><br><span class="line">hexo new [<span class="type">layout</span>] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建这三种不同类型的文件时，它们将会被保存到不同的路径</span></span><br><span class="line"><span class="comment"># postsource/_posts</span></span><br><span class="line"><span class="comment"># pagesource</span></span><br><span class="line"><span class="comment"># draftsource/_drafts</span></span><br></pre></td></tr></table></figure><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以  <code>---</code>  分隔的区域，用于指定个别文件的变量</p><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>文章支持分类和标签，您可以在 Front-matter 中设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="bullet">-</span> Games</span><br><span class="line">  categories:</span><br><span class="line"><span class="bullet">-</span> [Diary, PlayStation]</span><br><span class="line"><span class="bullet">-</span> [Diary, Games]</span><br><span class="line"><span class="bullet">-</span> [Life]</span><br></pre></td></tr></table></figure><h1 id="使用主题美化"><a href="#使用主题美化" class="headerlink" title="使用主题美化"></a>使用主题美化</h1><p>可以到 <a href="https://hexo.io/themes/">Hexo</a> 官网下载主题，进入到你的 hexo 博客根路径下的 themes 文件夹，将对应主题下载下来。<br>我这里使用到了 <a href="https://github.com/theme-next/hexo-theme-next">next 主题</a>，具体引入步骤见<a href="http://theme-next.iissnan.com/">使用文档</a></p><ul><li>主站_config.yml 文件中指定主题名称、语言</li><li>主题目录下的_config.yml 文件中进行客制化配置</li></ul><h2 id="关于分类和标签"><a href="#关于分类和标签" class="headerlink" title="关于分类和标签"></a>关于分类和标签</h2><p>​</p><p>开启这两个菜单项之后需要在 source 目录底下手动创建文件夹与 index.md 文件，如标签项（~/source/tags/index.md）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: xxx</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="自动生成分类"><a href="#自动生成分类" class="headerlink" title="自动生成分类"></a>自动生成分类</h2><p>安装日志的自动分类插件 hexo-auto-category</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-auto</span><span class="literal">-category</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>在站点根目录下的_config.yml 添加：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate categories from directory-tree</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/xu-song/hexo-auto-category</span></span><br><span class="line"><span class="comment"># depth: the depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line">auto_category:</span><br><span class="line"> enable: true</span><br><span class="line"> depth:</span><br></pre></td></tr></table></figure><p>参考文章<a href="https://blog.eson.org/pub/e2f6e239/">【Hexo 插件系列】日志的自动分类插件 hexo-auto-category</a></p><h2 id="自动生成标题"><a href="#自动生成标题" class="headerlink" title="自动生成标题"></a>自动生成标题</h2><p>Hexo 功能增强插件<a href="https://segmentfault.com/a/1190000018402194"> hexo-enchancer</a>（使用该插件，替代插件<code>hexo-auto-category</code>）</p><p><code>npm install hexo-enhancer _--save_</code><br>或<br><code>yarn add hexo-enhancer</code></p><p>hexo-enhancer 解析文件名的正则表达式如下:<br><code>/^.?(\d&#123;4&#125;)[-_]?(\d&#123;2&#125;)[-_]?(\d&#123;2&#125;).?[-_.@_# ]*(.*)$/_</code><br><em>​</em></p><p><em>​</em></p><h2 id="添加站点统计"><a href="#添加站点统计" class="headerlink" title="添加站点统计"></a>添加站点统计</h2><p>在每个页面添加 script 调用<code>_不算子_</code>API 记录访问记录，并使用<code>不算子</code>的变量显示对应访问值</p><p>在 <code>\themes\next\layout\_partials\footer.swig</code> 添加下列脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加不算子站点统计--&gt;</span><br><span class="line">&lt;script async src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Total &lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt; views.</span><br><span class="line">您是歪歪的第&lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;个小伙伴</span><br><span class="line">&lt;span id=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;/span&gt; Hits</span><br><span class="line"></span><br><span class="line">&lt;!-- 不算子 <span class="keyword">end</span> --&gt;</span><br></pre></td></tr></table></figure><p>注意：新版的 next 已经默认集成了不算子（busuanzi-counter.swig），在<code>_config.yml</code>中启用即可，不需要添加以上脚本<br><em>​</em></p><h2 id="添加评论区"><a href="#添加评论区" class="headerlink" title="添加评论区"></a>添加评论区</h2><p>[</p><p>](<a href="https://vincentqin.tech/posts/build-a-website-using-hexo/">https://vincentqin.tech/posts/build-a-website-using-hexo/</a>)<br>​</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://xfqwdsj.github.io/blog/2020/03/20/hexo-comments/">Hexo Next 主题的评论功能</a><br><a href="https://www.zhihu.com/question/267598518">Hexo（NexT 主题）评论系统哪个好？</a><br><a href="https://vincentqin.tech/posts/build-a-website-using-hexo/">Hexo+Github+jsDelivr+Vercel 建站备忘录</a><br><a href="http://yearito.cn/posts/hexo-advanced-settings.html">Hexo 搭建个人博客系列：进阶设置篇</a><br><a href="http://ibruce.info/2015/04/04/busuanzi/">不算子站点统计</a><br><a href="https://vincentqin.tech/top/">https://vincentqin.tech/top/</a><br><a href="http://blog.pangao.vip/links/">http://blog.pangao.vip/links/</a><br><a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a><br><a href="http://yearito.cn/posts/hexo-advanced-settings.html">http://yearito.cn/posts/hexo-advanced-settings.html</a><br><a href="https://blog.cyfan.top/p/620f3e8d.html#1-%E6%B3%A8%E5%86%8CBlogger">https://blog.cyfan.top/p/620f3e8d.html#1-%E6%B3%A8%E5%86%8CBlogger</a><br><a href="https://chenjiabing666.github.io/2020/10/26/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9C%8B%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AF%B4%E5%A4%AALOW%E4%BA%86%EF%BC%8C%E4%BA%8E%E6%98%AF%E6%88%91%E6%8A%98%E8%85%BE%E4%BA%86%E4%B8%80%E5%A4%A9/">Hexo 的 Next 主题优化教程</a><br><a href="http://www.dragonbaby308.com/hexo-theme-next/">Hexo 主题 —— NexT 优化</a><br><a href="https://blog.csdn.net/weixin_43935927/article/details/110352226">【Hexo】记录 NexT 主题美化及域名配置（图示详解）</a><a href="http://yearito.cn/posts/hexo-advanced-settings.html"></a><a href="https://www.linjiexin.com/post/blog-seo/">Hexo + Next + Pages 个人博客 - SEO 优化</a>[</p><p>](<a href="https://www.linjiexin.com/post/blog-seo/">https://www.linjiexin.com/post/blog-seo/</a>)<br>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-概述&quot;&gt;&lt;a href=&quot;#Hexo-概述&quot; class=&quot;headerlink&quot; title=&quot;Hexo 概述&quot;&gt;&lt;/a&gt;Hexo 概述&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows 开箱</title>
    <link href="https://huangyuye.github.io/2021/04/06/yuque/Windows%20%E5%BC%80%E7%AE%B1/"/>
    <id>https://huangyuye.github.io/2021/04/06/yuque/Windows%20%E5%BC%80%E7%AE%B1/</id>
    <published>2021-04-06T15:19:54.000Z</published>
    <updated>2021-05-24T12:55:41.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>下载最新的 <a href="https://www.microsoft.com/zh-cn/edge">Microsoft Edge</a>，使用默认的必应搜索引擎</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果有 vpn 账号，下载 Vpn 客户端，开启 PAC，并自动配置系统代理<br>浏览器下载 SwitchyOmega 插件实现快速切换代理，可以选择直接连接或者使用系统代理（即 vpn 代理）</p><p><code>ss 与 gfwlist</code> <a href="https://github.com/gfwlist/gfwlist">https://github.com/gfwlist/gfwlist</a></p><h2 id="替换-CMD"><a href="#替换-CMD" class="headerlink" title="替换 CMD"></a>替换 CMD</h2><h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><p>Windows powershell 的升级版<br>下载地址：<a href="https://github.com/PowerShell/PowerShell">https://github.com/PowerShell/PowerShell</a></p><h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p>Microsoft Store 下载 Windows Terminal，可以集成各个命令行工具，如上述提到的 powershell，以及 cmder 等<br>除此之外，还可以使用 wsl windows 子系统的方式，集成 linux 子系统命令行工具</p><p>下载好终端之后，需要对终端进行美化，一般过程如下：</p><ol><li>下载字体，下载字体后一般到对应的<code>ttf</code>目录下全选字体并安装到 OS 系统中</li><li>下载 PowerShell</li><li>安装 power shell 插件模块（Install-Module）<ol><li>Install-Module oh-my-posh -Scope CurrentUser：<em>让你的命令行更酷炫、优雅</em></li><li>Install-Module posh-git -Scope CurrentUser：<em>让你的 git 更好用</em></li><li>Install-Module -Name PSReadLine -AllowPrerelease -Force：<em>让命令行很好用，类似 zsh</em></li><li>注意：Install-Module 下载插件一般可以使用-Verbose 参数用于查看具体的插件下载地址，浏览器输入下载地址直接下载用于解决命令行下载缓慢的问题。下载完成后将插件解压后放到 power shell 安装目录的 <code>module</code>文件夹下，注意格式为：<code>$&#123;powerShell.path&#125;/module/$&#123;插件名&#125;/$&#123;插件版本&#125;/</code></li></ol></li><li>打开 Windows Terminal 配置文件进行字体、主题配置</li><li>添加右键菜单：编写<code>terminal.reg</code>文件并以管理员命令执行（<strong>注意根据情况修改路径</strong>）</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\<span class="type">Background</span>\<span class="type">shell</span>\<span class="type">wt</span>]</span><br><span class="line"><span class="selector-tag">@</span>=<span class="string">&quot;Windows terminal here&quot;</span></span><br><span class="line"><span class="string">&quot;Icon&quot;</span>=<span class="string">&quot;C:\\Users\\16957\\AppData\\Local\\terminal\\wt_32.ico&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">Directory</span>\<span class="type">Background</span>\<span class="type">shell</span>\<span class="type">wt</span>\<span class="type">command</span>]</span><br><span class="line"><span class="selector-tag">@</span>=<span class="string">&quot;C:\\Users\\16957\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>添加 Powershell 启动参数：<code>notepad.exe $Profile</code><ol><li>import 插件模块</li><li>设置主题</li><li>设置热键、函数、别名等</li></ol></li></ol><p><strong>其他</strong></p><ul><li><strong>Windows Terminal 分屏操作：</strong><code>ctrl + shrift + d</code></li><li><code>chocolate</code> ：windows 下的软件安装管理器<ul><li><code>@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot; [System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></li></ul></li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://zhuanlan.zhihu.com/p/137595941">Windows Terminal 完美配置 PowerShell 7.1</a><br><a href="https://zhuanlan.zhihu.com/p/272082726">Windows Terminal 完整指南</a>​<br><a href="https://blog.csdn.net/zhouchen1998/article/details/107484782">Windows Terminal 美化教程</a></p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>使用 <a href="https://www.cnblogs.com/Eric-jx/p/10491922.html">vim</a> 快速的在命令行中操作文件</p><h4 id="vim-相关配置修改"><a href="#vim-相关配置修改" class="headerlink" title="vim 相关配置修改"></a>vim 相关配置修改</h4><ol><li> cmd 中执行 vim 命令，执行 vim 指令<code>:version</code>查看配置文件路径，可以看到配置文件为<code>C:\Program Files (x86)\Vim\_vimrc</code></li><li> 修改配置文件，关闭 un~临时文件的输出</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> noundofile</span><br><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"><span class="built_in">set</span> noswapfile</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 vim 操作的文件编码，可参考<a href="http://c.biancheng.net/view/3024.html">http://c.biancheng.net/view/3024.html</a></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C:\Program Files (x86)\Vim\_vimrc</span></span><br><span class="line"><span class="comment"># 编码设置 start http://c.biancheng.net/view/3024.html</span></span><br><span class="line"><span class="built_in">set</span> fileencodings=utf<span class="literal">-8</span>,ucs<span class="literal">-bom</span>,gb18030,gbk,gb2312,cp936</span><br><span class="line"><span class="built_in">set</span> termencoding=utf<span class="literal">-8</span></span><br><span class="line"><span class="built_in">set</span> encoding=utf<span class="literal">-8</span></span><br></pre></td></tr></table></figure><h2 id="NVM-下载"><a href="#NVM-下载" class="headerlink" title="NVM 下载"></a>NVM 下载</h2><blockquote><p>该标题下的内容建议仅开发同学关注</p></blockquote><p>不管是使用 windows 还是系统系统，很多时候我们都需要在本地电脑运行一些前端项目，这时候会用到 nodejs 环境以及 npm 包管理工具，所以下载 <a href="https://github.com/coreybutler/nvm-windows/releases">nvm</a> 可以帮助你方便的管理与切换 node 环境版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;nodejs.version&gt;</span><br><span class="line">nvm use &lt;nodejs.version&gt;</span><br></pre></td></tr></table></figure><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>npm 是 node 官方的包管理器。cnpm 是个中国版的 npm，是淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm。npm 和 cnpm 只是下载器的不同</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> cnpm -<span class="literal">-registry</span>=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><p>nrm 这个包的功能可以让我们随意的切换我们下载包的地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i nrm <span class="literal">-g</span></span><br><span class="line">nrm <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="Ruby-gem-下载"><a href="#Ruby-gem-下载" class="headerlink" title="Ruby gem 下载"></a>Ruby gem 下载</h3><p>使用 travis ci 时可能需要用到 <a href="https://rubyinstaller.org/">gem</a>下载 travis 工具</p><h4 id="命令权限"><a href="#命令权限" class="headerlink" title="命令权限"></a>命令权限</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned</span><br></pre></td></tr></table></figure><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p><a href="https://typora.io/windows/dev_release.html">Typora </a>是一款强大简洁的 markdown 文本编辑器，可以使用它高效的编码 md 文档</p><h2 id="listary"><a href="#listary" class="headerlink" title="listary"></a>listary</h2><p><a href="https://www.listary.com/download">Listary</a> 是一个革命性的 Windows 搜索工具，可以帮你快速查找文件和启动应用程序</p><h2 id="snipaste"><a href="#snipaste" class="headerlink" title="snipaste"></a>snipaste</h2><p>很好用的截图工具，支持多张截图拼图，快捷键—F1：截图；F3：将截图放在桌面进行拼图，下载地址点<a href="https://zh.snipaste.com/">这里</a></p><h2 id="GitHub-Gist-管理工具"><a href="#GitHub-Gist-管理工具" class="headerlink" title="GitHub Gist 管理工具"></a>GitHub Gist 管理工具</h2><p>Gist 是基于 Github 的 code snippet 仓库，Github Gist 的可操作性比较少，一般会下载 Gist 管理工具提供更多功能支持。<br>一般的 GitHub Gist 管理工具有：gisto、gistbox、lepton</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; class=&quot;headerlink&quot; title=&quot;浏览器&quot;&gt;&lt;/a&gt;浏览器&lt;/h2&gt;&lt;p&gt;下载最新的 &lt;a href=&quot;https://www.microsoft.com/zh-cn/edge&quot;&gt;Microsoft Edg</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>语雀-Hexo-GitHub</title>
    <link href="https://huangyuye.github.io/2021/04/05/yuque/%E8%AF%AD%E9%9B%80-Hexo-GitHub/"/>
    <id>https://huangyuye.github.io/2021/04/05/yuque/%E8%AF%AD%E9%9B%80-Hexo-GitHub/</id>
    <published>2021-04-05T11:17:36.000Z</published>
    <updated>2021-05-24T12:55:41.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h2><h3 id="语雀"><a href="#语雀" class="headerlink" title="语雀"></a>语雀</h3><p>云端写作工具</p><h4 id="Web-Hook"><a href="#Web-Hook" class="headerlink" title="Web Hook"></a>Web Hook</h4><p>可以创建写作时的钩子，即可以监听文章内容的变更事件（更新、新建、删除等）并请求某接口（get 请求）</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://hexo.io/zh-cn/index.html">Hexo</a>是一个博客框架，支持专注于.md 格式的内容编辑后快速生成静态博客页面<br>​</p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br><span class="line"><span class="comment"># 对于熟悉 npm 的进阶用户，可以仅局部安装hexo包。</span></span><br><span class="line"><span class="variable">$</span> npm install hexo</span><br></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li>npx hexo <command></li><li>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：<table><thead><tr><th>echo ‘PATH=”$PATH:./node_modules/.bin”‘ &gt;&gt; ~/.profile</th></tr></thead></table></li></ol><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>提供托管生成的静态页面的功能</p><h4 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h4><p>可以作为 travis ci 的替代方案（travis ci 的构建任务的触发也是通过 GitHub 的组件<code>Github WebHook</code>来支持的）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/10363384/1621391502370-3546e6ca-93b3-43aa-8ecb-75be46f1d651.png#clientId=u6236cb25-c3e3-4&from=paste&height=977&id=u1de82d50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=977&originWidth=1600&originalType=binary&size=106078&status=done&style=none&taskId=u5e85f72d-890c-4927-ad3d-0fc7a822406&width=1600" alt="image.png"></p><h3 id="Travis"><a href="#Travis" class="headerlink" title="Travis"></a>Travis</h3><p><a href="https://travis-ci.com/">Travis</a>是一个提供 github 项目的 CI 持续集成的免费平台<br>Travis 可以通过 api 的方式触发构建过程</p><h3 id="腾讯云函数-serverless"><a href="#腾讯云函数-serverless" class="headerlink" title="腾讯云函数 serverless"></a>腾讯云函数 serverless</h3><p>使用平台支持的语言（如 php、python 等）编写核心代码并设置代码运行的条件（可定时触发或者 API 触发等），代码即可在腾讯云基础设施上弹性、安全地运行。</p><h2 id="角色关系"><a href="#角色关系" class="headerlink" title="角色关系"></a>角色关系</h2><ul><li>可以在 GitHub 中创建 github pages 作为 <code>博客</code>  项目 ，用于保存自己的博客的前端资源文件，且可以通过 github 提供的个人博客域名展示自己的博客内容</li><li>Hexo 为博客框架，可以将编写的<code>文章</code>(.md 文件)按照 <code>hexo模板</code>  格式生成前端静态资源文件。hexo 框架支持配置在生成前端资源文件之后将你的文件推送部署到 github 进行托管</li><li>Travis 为持续集成工具，可以为你免去使用 hexo 框架带来的一些冗余且重复性的操作，但在此之前你需要像下面这样做：<ul><li>你需要维护你的 <code>文章</code> （.md 文件）到 github 的某个项目中，当然你可以选择复用博客项目，使用该项目的另一个分支即可</li><li>登入 travis，关联你的 gitHub 项目（托管 <code>文章</code>  的项目与分支）</li><li>在托管 <code>文章</code> 的项目根目录下配置好 travis 的配置文件，配置内容包括将 hexo 构建生成博客内容、hexo 部署博客内容到 <code>博客</code>  项目、访问 <code>博客</code>  项目的授权信息等（涉及到博客项目的 push 操作）</li><li>登入 travis，配置好相关的 gitHub 访问授权</li><li>以上配置结束后，后续你只需要专心关注你的文章，必及时将你的文章内容推送到 github，travis 就会自动化地帮你构建出博客内容，并发布最新内容到你的个人博客了</li></ul></li><li>语雀为写作工具，写作内容自带云同步效果，且拥有较好的写作用户体验，所以可以考虑放弃在本地机器中用 typora 等工具写文章，直接到语雀上进行云写作。这样就衍生出一个新问题，之前本地写的文章都可以推送到 github，且由 travis 和 hexo 帮你生成并搭建出你的个人博客内容，那语雀上写的文章能不能也达到这效果？答案是可以的</li><li>语雀 web hook 可以监听你的写作行为，可以在更新文章时触发调用某个外部的 API 接口，而 travis 恰好提供了这种机制，提供了 travis api 接口，允许外部触发 github 项目的 build 流程，该 api 方法为 post 请求</li><li>但是语雀 web hook 限制了调用的 API 必须是 get 请求的，不能是 post 请求的，所以就需要使用腾讯云函数</li></ul><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h2 id="授权问题"><a href="#授权问题" class="headerlink" title="授权问题"></a>授权问题</h2><ol><li>travis ci 可以使用两种方式访问 Github：<ul><li>一种是使用 github 的 personal access token（使用环境变量的方式配置到 travis）</li><li>一种是使用 ssh key 的方式，将 ssh 公钥配置到 github 的 travis 项目中，前提会将公钥文件通过 travis 的加密方式加密，生成 xxx.enc 文件，并将密钥配置到 travis 环境变量中，明文显示的公钥文件可删除</li></ul></li><li>同上，travis ci 同步语雀文章需要使用到语雀的 <a href="https://www.yuque.com/settings/tokens">personal access token</a></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>调用 travis api 时，语雀 webhook 以及 serverless 云函数中的<code>仓库slug</code>参数值（user_name/repo_name）必须先进行 urlencode，否则接口调用会报 404 错误。（<strong>一定要注意，这个坑折腾了很长时间</strong>）</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@type&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;error_type&quot;</span>: <span class="string">&quot;not_found&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;error_message&quot;</span>: <span class="string">&quot;resource not found (or insufficient access)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建议先根据仓库 slug 查询仓库 id 避免后续修改仓库名称导致 404 等错误<ul><li>api.travis-ci.org/repo/3121806s7/requests</li></ul></li><li>语雀 webhook 不能直接构建脚本直接发起 POST 请求到 Travis，所以可以通过代理服务触发 Travis CI API<ul><li>腾讯云函数作为代理服务，Web Hook 的请求发送至该服务后，该服务去触发 Travis 的 CI 构建。</li></ul></li><li>针对语雀图片无法正常显示的解决办法（语雀防盗链）<ul><li>在主题的 layout 文件夹中的 post.ejs 文件请求头中加上一句</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="为你的博客搭建图床"><a href="#为你的博客搭建图床" class="headerlink" title="为你的博客搭建图床"></a>为你的博客搭建图床</h2><p><a href="https://www.yuque.com/huangyuye/blog/qabgtz">PicGo + GitHub 创建自己的免费图床</a></p><h2 id="美化你的博客主题"><a href="#美化你的博客主题" class="headerlink" title="美化你的博客主题"></a>美化你的博客主题</h2><p>参考我另一篇文章 <a href="https://www.yuque.com/huangyuye/blog/eqqt0i">Hexo 主题美化</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>《<a href="https://www.yuque.com/hxfqg9/web/gtb5ck">语雀自动同步到 hexo 博客</a>》</li><li>《<a href="https://www.yuque.com/joashzhao/blog/sync-yuque-to-hexo#egrli">语雀自动同步 HEXO 机器人——搭建细节</a>》</li><li>《<a href="https://segmentfault.com/a/1190000017797561">Hexo 博客终极玩法：云端写作，自动部署</a>》</li><li>《<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/#%E4%BB%8B%E7%BB%8D">利用 Github Actions 自动部署 Hexo 博客</a>》</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>了解 GitHub Pages，需要搭建 github.io 的 repo_name 可否自定义？可否自定义 repo_branch？</li><li>语雀 - Hexo - Github 同步之后，能否在博客中加上本地机器写的文章？</li><li>博客主题：Hexo 美化 与 GitHub Pages 美化</li><li>使用 GitHub Actions 替代 Travis</li><li>学会云管理自己的配置—<a href="https://www.cnblogs.com/thinkam/p/10922920.html">Gist</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2 id=&quot;角色介绍&quot;&gt;&lt;a href=&quot;#角色介绍&quot; class=&quot;headerlink&quot; title=&quot;角色介绍&quot;&gt;&lt;/a&gt;角色介绍&lt;/h2&gt;&lt;h3 id</summary>
      
    
    
    
    <category term="yuque" scheme="https://huangyuye.github.io/categories/yuque/"/>
    
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="https://huangyuye.github.io/2020/11/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20201124-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangyuye.github.io/2020/11/24/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20201124-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2020-11-24T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h3><p>单元测试是指对软件中的<strong>最小可测单元</strong>进行检查和验证；</p><p>根据测试金字塔原理，越往上层的测试，所需测试投入比例越大，效果也越差。单测成本小，且更容易发现问题。（效果：单元测试 &gt; 集成测试 &gt; UI测试）</p><h3 id="分层测试"><a href="#分层测试" class="headerlink" title="分层测试"></a><strong>分层测试</strong></h3><p>Service =&gt; Biz层 =&gt; （外部服务访问层、DAO层、Redis访问层）</p><p>每一层均使用mock 框架屏蔽下层的具体实现。</p><h3 id="单元测试过程"><a href="#单元测试过程" class="headerlink" title="单元测试过程"></a><strong>单元测试过程</strong></h3><p>数据准备 =&gt; 构造参数（+打桩）=&gt; 执行测试 =&gt; 结果验证 =&gt; 清理（必要）</p><ol><li>数据准备：测试用例需要依赖一些数据，数据来源一般是数据库，而又不能依赖DAO层的代码，需要使用原生jdbc去插入数据，<strong>测试代码编写效率低</strong></li><li>构造参数：入参赋值（<strong>代码行数多</strong>）</li><li>执行测试：直接调用被测方法</li><li>结果验证：验证方法的返回值、数据库数据是否正确、某外部方法是否被调用过n次等</li><li>必要的清理：对打桩进行清理、对数据库脏数据进行清理</li></ol><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a><strong>痛点</strong></h3><ol><li>重构代码需要改写大量单元测试用例<ol><li>大量的Service 层单元测试,biz层单元测试都要重写；有时候Service调用biz层接口时，参数传错了，而由于开发人员编写单元测试时不规范，参数匹配使用了 anyxxx()，导致参数传错的bug未被发现。</li></ol></li><li>测试库数据随意修改导致的单元测试不稳定<ol><li>DAO层单元测试直连测试库，由于测试库的数据可以被任意修改，从而导致测试依赖的数据被更改，单元测试不通过，另外开发在编写单元测试时，没有清理意识，导致测试库大量垃圾数据。</li></ol></li><li>单元测试结果校验缺失<ol><li>例如一个SaveItem()接口，执行完成后除了要验证执行成功以外，还应该验证落库数据的正确性，而编写这部分测试代码需要大量的使用原生jdbc 接口查询sql，并逐字段验证正确性，代码编写效率低下。</li></ol></li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://tech.youzan.com/youzan-test-practice/">《有赞单元测试实践》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;&lt;strong&gt;单元测试&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;单元测试是指对软件中的&lt;strong&gt;最小可测单元&lt;/strong&gt;进行检查和验证；&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="软件开发流程" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="https://huangyuye.github.io/2020/11/07/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20201107-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://huangyuye.github.io/2020/11/07/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20201107-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-07T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="算法与数据结构常见问题场景"><a href="#算法与数据结构常见问题场景" class="headerlink" title="算法与数据结构常见问题场景"></a>算法与数据结构常见问题场景</h2><ol><li>字符串匹配<ol><li>暴力匹配（回溯匹配，回溯次数多，速度慢）</li><li>KMP算法（ -&gt; 建立部分匹配表）</li></ol></li><li>汉诺塔问题（大方块不能在小方块下面）</li><li>八皇后问题：92种算法</li><li>马踏棋盘算法（骑士周游算法）</li></ol><h2 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h2><p>数据结构是<strong>研究组织数据方式</strong>的学科</p><p>数据结构是算法的基础</p><p><strong>数据结构包括：线性结构/非线性结构</strong></p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ol><li>数据元素之间存在一对一线性关系</li><li>两种不同的存储结构：<strong>顺序存储结构&amp;链式存储和结构</strong> (数组&amp;链表)——元素节点中存放数据元素及相邻元素的地址信息不连续</li><li>常见的线性结构有：数组、队列、链表和栈</li></ol><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><ol><li>数组元素之间不是一对一的线性关系</li><li>场景的非线性结构：多维数组、广义表、树结构、图结构</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="稀疏数组（sparse-array）"><a href="#稀疏数组（sparse-array）" class="headerlink" title="稀疏数组（sparse array）"></a>稀疏数组（sparse array）</h3><p><strong>场景：</strong></p><p>编写五子棋程序，且有存盘和续上盘的功能；</p><p><strong>问题：</strong></p><p>使用二维数组记录棋盘，存在很多值为0的元素</p><p><strong>稀疏数组介绍：</strong></p><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来表示</p><p><strong>使用稀疏数组的处理方法：</strong></p><p>1、第一行记录一共有几行几列，有多少个不同得值</p><p>2、把具有不同值得行列及值记录在一个小规模得数组中，从而缩小程序的规模</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个有序列表，可以用数组或链表来实现</p><p>遵循先进先出的原则</p><p><strong>使用数组模拟队列：</strong></p><p>保存两个变量-front &amp; rear （头尾的下标）；maxSize为数组容量，若rear=maxSize-1则队列满（front和rear从-1/0开始）（front：指向队列头的前一个位置；rear指向队列尾最后一个位置）; front=rear则队列为空</p><p><strong>问题：</strong></p><p>单向队列：数组使用一次就不能用，没有达到复用效果</p><p><strong>解决方案：</strong>改为环形队列</p><p><strong>环形队列调整思路：</strong></p><ol><li><p>front指向队列的第一个元素；front初始值为0</p></li><li><p>rear指向队列的最后一个元素的后一个位置；rear初始值为0</p></li><li><p>判断队列满的条件为：(rear+1)%maxSize=front</p></li><li><p>队列中有效的数据个数：(rear + maxSize - front) % maxSize  （为什么要+maxSize？因为是环形队列，rear的下标有可能小于front的下标，这里是为了避免为负数）</p></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是有序的列表，内存不一定连续；每个节点包含data域，next域</p><p>可区分为有头节点或无头节点的链表</p><p><strong>链表排序</strong></p><p>新增节点时进行排序：遍历链表，找到新添加节点的位置（<strong>遍历，比较节点的值，直到遍历节点的值大于待插入节点的值</strong>），将新节点的next指向插入位置的节点的next，将插入位置的节点的next指向新节点。</p><p><strong>遍历链表节点逻辑</strong></p><p>使用辅助变量，从head节点开始，通过next指向遍历</p><p><strong>排序和限制重复的思考</strong></p><ol><li>若要支持排序，则定义比较大小的规则，如实现comparable接口重写compare方法</li><li>若要支持更新或者唯一限制，则要定义节点判断唯一的规则，如重写equals方法(以及hashcode())</li></ol><p><strong>链表反转</strong></p><ol><li>创建一个新的头节点 newHead</li><li>遍历原链表,<ol><li>temp辅助变量记录newHead.next</li><li>每次遍历都将 newHead指向遍历的节点node，遍历的节点node.next指向原先newHead的next，即temp（可使用辅助变量）</li></ol></li></ol><p>其他方案：可以使用临时数组  </p><p><strong>链表逆序打印</strong></p><p>实现思路1：利用栈<strong>先进后出</strong>特性</p><p><strong>栈</strong></p><p>栈的底层实现是数组，父类是Vector矢量类</p><p><strong>应用场景</strong></p><p><strong>单向环形链表</strong>——约瑟夫环问题（丢手帕）</p><p>单向环形链表：最后一个节点的next指向头节点</p><p>丢手帕报数过程：head和tail指针同时移动，报数出队时，head节点修改，且tail节点的next指针指向新的head节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他参数校验</span></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == head) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">tail = tail.next;</span><br><span class="line">first = first.next;</span><br><span class="line">&#125;</span><br><span class="line">sout(first);</span><br><span class="line">first=first.next;</span><br><span class="line">tail.next=first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个先进后出的有序列表(FILO first in last out)</p><p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行操作的一种特殊线性表。允许插入和删除的一端为变化端，即栈顶。另一端为栈底。</p><p><strong>应用场景</strong></p><ul><li>子程序的调用</li><li>处理递归调用</li><li>表达式的转换[中缀表达式转后缀表达式]与求值</li><li>二叉树的遍历</li><li>图形的深度优先搜索法</li></ul><p><strong>需求场景</strong></p><p>前端输入一个表达式，编写一个函数进行计算：String str = 7*2</p><p>栈的应用场景、实现原理、<strong>实现计算器</strong></p><p><strong>实现计算器</strong></p><p>两个栈，一个存放数，一个存放操作符，遍历字符时若当前字符是操作符，则判断优先级是否小于或等于操作符栈的上一个操作符，是的话则从数栈pop出两个数，从操作符栈pop出一个符号进行计算，然后将当前的符号入符号栈；否则直接入符号栈（中缀表达式）</p><h3 id="前缀-amp-中缀-amp-后缀表达式"><a href="#前缀-amp-中缀-amp-后缀表达式" class="headerlink" title="前缀&amp;中缀&amp;后缀表达式"></a>前缀&amp;中缀&amp;后缀表达式</h3><p>前缀表达式：运算符位于操作符之前</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表同时记录了头尾节点，且每个节点增加prev上一节点引用指针</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法-递归"><a href="#算法-递归" class="headerlink" title="算法-递归"></a>算法-递归</h3><p>应用场景：阶乘、迷宫问题（回溯）、八皇后问题</p><h3 id="算法-排序"><a href="#算法-排序" class="headerlink" title="算法-排序"></a>算法-排序</h3><p>将一组数组，依据指定顺序进行排列的过程</p><p><strong>排序的分类</strong></p><ul><li><p>内部排序（使用内部存储进行排序）</p></li><li><p>外部排序（数据量大时使用外部存储进行排序）</p></li></ul><p><strong>内部排序分为</strong></p><ul><li>插入排序<ul><li><strong>直接插入排序</strong></li><li>希尔排序</li></ul></li><li>选择排序<ul><li><strong>简单排序</strong></li><li>堆排序</li></ul></li><li>交换排序<ul><li><strong>冒泡排序</strong></li><li>快速排序</li></ul></li><li>归并排序</li><li>基数排序（桶排序的升级）</li></ul><p><strong>度量程序、算法执行时间的两种方法</strong></p><ul><li>事后统计法（需要实际运行；依赖于软硬件等环境因素）</li><li>事前估算法：通过分析某算法的<strong>时间复杂度</strong>来判断</li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><strong>时间频度</strong> T(n)：一个算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法与数据结构&quot;&gt;&lt;a href=&quot;#算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构&quot;&gt;&lt;/a&gt;算法与数据结构&lt;/h1&gt;&lt;h2 id=&quot;算法与数据结构常见问题场景&quot;&gt;&lt;a href=&quot;#算法与数据结构常见问题场景&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="算法与数据结构" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>springCloud微服务</title>
    <link href="https://huangyuye.github.io/2020/10/31/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/20201031-springCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://huangyuye.github.io/2020/10/31/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/20201031-springCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-10-31T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-技术体系演变"><a href="#spring-技术体系演变" class="headerlink" title="spring 技术体系演变"></a>spring 技术体系演变</h2><ol><li>spring</li><li>springboot</li><li>spring cloud netflix</li><li>spring cloud alibaba （微服务开发的一站式解决方案）</li></ol><h2 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h2><ul><li><p>配置管理</p></li><li><p>服务管理</p></li></ul><p>服务注册中心 + 配置中心（涉及CAP理论）</p><h2 id="feign"><a href="#feign" class="headerlink" title="feign"></a>feign</h2><p>feign = ribbon + hystricx</p><p>feign 对微服务的调用实际上也是类似使用 restTemplate 进行http 调用，只是进行了封装。</p><h2 id="gateway-amp-feign"><a href="#gateway-amp-feign" class="headerlink" title="gateway &amp; feign"></a>gateway &amp; feign</h2><p>gateway(API路由管理方式)： 提供统一的路由方式，基于filter链的方式提供网关基本功能（如安全、监控/指标，和限流）</p><h2 id="sentinal"><a href="#sentinal" class="headerlink" title="sentinal"></a>sentinal</h2><p>以流量为切入点，从流量控制、熔断降级、系统负载保护等多维度保护服务的稳定性</p><p>sentinal的限流配置可以与nacos配合使用（除此之外，sentinal还有很多配置的持久化方式）</p><h2 id="fescar"><a href="#fescar" class="headerlink" title="fescar"></a>fescar</h2><p>即seata，分布式事务解决方案</p><h2 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h2><p>服务链路追踪</p><p>常见的<strong>APM</strong>系统对比：zipkin vs pinpoint vs skywalking （Application Performance Management应用性能管理）</p><h2 id="gateway、sentinal、feign的关系和配合？？"><a href="#gateway、sentinal、feign的关系和配合？？" class="headerlink" title="gateway、sentinal、feign的关系和配合？？"></a>gateway、sentinal、feign的关系和配合？？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spring-技术体系演变&quot;&gt;&lt;a href=&quot;#spring-技术体系演变&quot; class=&quot;headerlink&quot; title=&quot;spring 技术体系演变&quot;&gt;&lt;/a&gt;spring 技术体系演变&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;spring&lt;/li&gt;
&lt;li&gt;spri</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="SpringCloudAlibaba" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/SpringCloudAlibaba/"/>
    
    
  </entry>
  
  <entry>
    <title>容器&amp;同步&amp;并发容器</title>
    <link href="https://huangyuye.github.io/2020/10/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201027-%E5%AE%B9%E5%99%A8&amp;%E5%90%8C%E6%AD%A5&amp;%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>https://huangyuye.github.io/2020/10/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201027-%E5%AE%B9%E5%99%A8&amp;%E5%90%8C%E6%AD%A5&amp;%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2020-10-27T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20201027-并发-amp-同步容器"><a href="#20201027-并发-amp-同步容器" class="headerlink" title="20201027-并发&amp;同步容器"></a>20201027-并发&amp;同步容器</h1><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p>nanos 毫微秒</p><p>nil 零/无</p><p>Deque  双端队列容器</p><h2 id="常用容器相关超类"><a href="#常用容器相关超类" class="headerlink" title="常用容器相关超类"></a>常用容器相关超类</h2><ul><li>Iterator(迭代器)<ul><li>不同类型的集合的操作方法基本上都是使用抽象迭代器来遍历集合元素进行相关操作，需要具体的迭代器实现类来实现迭代细节。（Iterator中没有涉及具体的数据结构和算法）</li></ul></li><li>Collection(单个元素对象的序列，下面三个子接口设计目的：最大程度抽象出元素的操作)<ul><li>List：一个有序的Collection（或者叫做序列）</li><li>Set</li><li>Queue</li></ul></li><li>Map(“键值对”映射表)</li></ul><h3 id="Map（散列表）"><a href="#Map（散列表）" class="headerlink" title="Map（散列表）"></a>Map（散列表）</h3><ul><li>遍历函数<ul><li><strong>keySet：Set<K></strong> （hashSet又由HashMap实现）</li><li>values：Set<V></li><li>entrySet：Set&lt;Map.Entry&lt;K, V&gt;&gt;</li></ul></li><li>类型<ul><li>HashMap<ul><li>tab hash数组</li><li>hash冲突链表保存元素</li></ul></li><li>LinkedHashMap<ul><li>继承HashMap</li></ul></li><li>TreeMap</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>函数</p><ul><li>add()：<ul><li>modCount ++ </li><li>扩容检查（涉及数组复制）</li></ul></li><li>remove()：<ul><li>modCount++;</li><li>把需要删除index后面的都往前移一位然后再把最后一个去掉。<ul><li>numMoved = size - index - 1</li><li>System.arraycopy(elementData, index+1, elementData, index, numMoved)</li><li>elementData[–size] = null; </li></ul></li></ul></li></ul><p>有序，可以重复</p><p>List包含特殊的遍历器：ListIterator，支持双向访问、允许从一个指定位置开始遍历</p><p><strong>ArrayList 继承了AbstractList且实现了List，但是AbstractList已经实现了List</strong></p><p><strong>AbstractList 内部类：</strong>Itr implements ListIterator；ListItr extends  Itr</p><p>equals 和 contains方法都使用了迭代器遍历来实现</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>HashSet<ul><li><strong>使用HashMap实现</strong>，value是默认对象</li></ul></li><li>LinkedHashSet<ul><li>继承hashSet</li><li>使用LinkedHashMap实现</li><li>LinkedHashSet会根据add，remove这些操作的顺序在遍历时返回固定的集合顺序。这个顺序不是元素的大小顺序，而是可以保证2次遍历的顺序是一样的。</li></ul></li><li>TreeSet<ul><li>TreeSet内的元素必须实现Comparable接口</li></ul></li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>AbstractCollection<E>;、AbstractMap&lt;K,V&gt;、AbstractList<E>和AbstractSet<E></p><p>各个集合的关键区别就在每个集合所使用的数据结构和算法上，所以在<strong>抽象类</strong>层面都没有涉及具体的数据结构和算法，只对操作这些数据结构的方法做了基本实现。</p><h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList<E></h2><p><strong>AbstractList 内部类：</strong>Itr implements ListIterator；ListItr extends  Itr</p><h2 id="AbstractMap-lt-K-V-gt"><a href="#AbstractMap-lt-K-V-gt" class="headerlink" title="AbstractMap&lt;K,V&gt;"></a>AbstractMap&lt;K,V&gt;</h2><p>implements Map&lt;K,V&gt;，实现了除entrySet()方法外的基本所有方法；</p><p>返回键集的Set<K> keySet()和返回值集的Collection<V> values()：返回来一个实现Set<K>或Collection<V>的类对象，类对象的所有操作都是在原映射表的基础上进行的，这种操作叫视图。（重写AbstractSet的一个匿名内部类返回）</p><h2 id="ArrayList-amp-LinkList"><a href="#ArrayList-amp-LinkList" class="headerlink" title="ArrayList &amp; LinkList"></a>ArrayList &amp; LinkList</h2><p>ArrayList<E>通过数组实现：数组中元素间的内存地址是连续的、只能存储一种类数据类型的元素。数组长度固定</p><p>LinkList<E>使用了双向链表；LinkList继承了Deque<E>接口，实现<strong>双端队列</strong>头尾进出的特点。</p><p>链表的特点：长度不固定，可以随时增加和减少、链表中的元素在内存地址上可以是连续的，也可以是不连续的</p><p>ArrayList 继承了AbstractList且实现了List</p><p>ArrayList  在添加元素之前会进行容量检查；扩容目标容量大小为原容量的1.5倍；扩容涉及数组的复制</p><p>在遍历元素上ArrayList<E>存在更有效的方式，他实现了RandomAccess接口，代表ArrayList<E>支持快速访问。 RandomAccess本身是一个空接口，这种接口一般用来代表一类特征，RandomAccess代表实现类具有快速访问的特征。</p><p>LinkedList 添加对象时需要创建Node对象而开辟内存空间；</p><p>LinkedList元素在将元素插入到链表中间位置的场景耗时很久；插入到头部最快。</p><p>LinkedList添加第一个元素的时候，first=last=newNode;</p><p>LinkedList add(i, ele)时，将下标为i的元素的prev元素节点（如果为null，则ele为first节点），作为ele的prev元素节点，当前元素ele的next节点指向下标为i的元素；再将下标为i的元素的节点的prev元素节点指向当前元素ele；（linkBefore）</p><p>LinkedList根据下标i索引元素的方式：对比下标跟链表长度的一半，判断是在前半部分还是后半部分，若是前半部分，则从first节点向后遍历；否则从last节点前序遍历</p><p><strong>问题：</strong></p><p>1、为什么链表将元素插入到链表中间位置耗时最近？</p><p>2、为很么链表将元素插入到链表头部的时间与插入到尾部的时间不一致？</p><h2 id="红黑树、TreeMap与TreeSet"><a href="#红黑树、TreeMap与TreeSet" class="headerlink" title="红黑树、TreeMap与TreeSet"></a>红黑树、TreeMap与TreeSet</h2><p>Map&amp;Set: 不能添加重复元素的集，不能通过索引来访问的集; (由数组实现的散列表+链表/红黑树)</p><p>Set由Map实现,但是Set继承自Collection集合,而map为键值映射</p><p>TreeMap: 每次put元素时会遍历比较key值,优先使用比较器进行比较,后使用默认的compareTo方法比较;<strong>TreeMap.Entry</strong> implements Map.Entry, 即红黑树</p><h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteList&lt;&gt;(); <span class="comment">// list引用地址 #list001, list.array引用地址 # array001</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.sort(Integer.compareTo()); <span class="comment">// list引用地址不变，list.array引用地址 #array002</span></span><br><span class="line">list.add(<span class="number">2</span>); <span class="comment">// list引用地址不变，list.array引用地址 #array003</span></span><br></pre></td></tr></table></figure><ol><li>ArrayList 在add元素时不会修改数组的指向</li><li>ArrayList 和 CopyOnWriteList 在sort时都会修改数组的指向</li><li>ArrayList 在使用iterator遍历时，首先会记录当前list修改操作的次数n，后续遍历执行next()时会检查n是否修改，如果修改，则抛出ConcurrentModificationException（遍历外部类的最新数组）；CopyOnWriteList 则能正常遍历，因为遍历的是旧的引用数组。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;20201027-并发-amp-同步容器&quot;&gt;&lt;a href=&quot;#20201027-并发-amp-同步容器&quot; class=&quot;headerlink&quot; title=&quot;20201027-并发&amp;amp;同步容器&quot;&gt;&lt;/a&gt;20201027-并发&amp;amp;同步容器&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Git内容</title>
    <link href="https://huangyuye.github.io/2020/09/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20200925-Git%E5%86%85%E5%AE%B9/"/>
    <id>https://huangyuye.github.io/2020/09/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20200925-Git%E5%86%85%E5%AE%B9/</id>
    <published>2020-09-25T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git常用场景使用技巧"><a href="#git常用场景使用技巧" class="headerlink" title="git常用场景使用技巧"></a><strong>git常用场景使用技巧</strong></h3><ol><li><p>功能开发到一半，突然要修复线上问题 （保存现场）</p><ol><li>在开发分支上：<code>git stash</code> = <code>git stash save</code> 保存未提交的内容（<strong>前提是修改的文件已被版本库追踪过</strong>）<ol><li>想要添加保存信息则执行：<code>git stash save -a “message”</code> （git stash save 命令将来会被git stash push 代替）</li><li>默认情况下，<code>git stash</code> 只会贮藏已修改和暂存的 <strong>已跟踪</strong> 文件。如果指定 –include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。</li></ol></li><li>切换到其他分支修复bug</li><li>修复完后回到原开发分支，并执行 <code>git stash pop</code> (<code>git stash pop</code> = <code>git stash apply  stash@&#123;0&#125;</code> + <code>git stash drop  stash@&#123;0&#125;</code>)</li></ol></li><li><p>不小心把代码提交到错的分支上 （<strong>假设错误分支为test，目标分支为 dev</strong> ）</p><ol><li><strong>简易操作</strong>：切换到在目标分支dev下执行-&gt; <code>git cherry-pick commitId1 commitId2</code> …</li><li><strong>git rebase</strong>：<code>git rebase --onto dev &lt;开始的commitId&gt; &lt;结束的commitId&gt; </code><ol start="2"><li>执行上述操作后，实际上git 会将dev作为基底分支，将 &lt;开始的commitId&gt; &lt;结束的commitId&gt;  做的相应改变重做一遍，重做的commitId可能跟旧的commitId不一样（若是能ff，则commitId一样），重做后，HEAD指针指向最新的commitId上（游离状态，没有指向任何分支上）</li><li>切换到目标分支 <code> git checkout dev</code></li><li>将dev分支指向重做的最新的提交点上 <code>git reset --hard  commitId</code> （也属于变基操作，会产生线性提交历史）</li></ol></li></ol></li><li><p>需要将其他分支的文件复用过来：</p><ol><li><code>git checkout source_path(其他分支) filename1 filename2 ... (其他分支的文件) </code></li></ol></li><li><p>需要删除中途某次提交：git revert </p><ol><li><code>git revert commitID</code> 使用一次新的commit来回滚之前的commit</li><li>revert 是逆向回放</li></ol></li><li><p><strong>本地仓库</strong>需要回退到某个版本（亦可用于版本前进）：git reset</p><ol><li> <code>git reset --hard commitId</code> ： 将 commitId 和 commitId 之后的所有提交记录均删除；但是如果 merge 其他老的分支到该分支，commitId后面被回滚的commit应该还会被引入<strong>（一般在提交点push到公共分支之前操作）</strong></li><li><code>git reset --soft commitId</code>：此次提交之后的修改会被退回到暂存区。(回退版本<strong>commitId后的修改还保留在本地工作空间</strong>)</li><li><code>git reset commitId</code> 默认使用选项 –mixed，此次提交之后的修改会被退回到工作区</li><li><code>git reset</code> 用于将当前分支指向任意提交点，包括其他分支的提交点，即可在任意提交点来回穿梭</li></ol></li><li><p>代码版本回退错误，想要重新回到最新提交点，但是提交历史已丢失了（通过git log 查看不到提交记录）</p><ol><li>使用 <code>git reflog</code> 查看历史操作记录，找到对应要恢复的提交点，执行 git reset 相关方法</li></ol></li><li><p>已经推送到远程公共分支的代码版本正确的回退姿势（<strong>暂时未理解原理</strong>）</p><ol><li><code>git reset --hard commitId1</code>（要回退的版本）：该操作把 working, index, HEAD 都强行置为 commitId1</li><li><code>git reset --soft commitId2</code>（最新提交点）</li></ol></li><li><p><strong>本地仓库</strong>，存在多余的提交，想要压缩成一次提交</p><ol><li>将上一次提交和这次提交作为一次提交 <code>git commit --amend</code> </li><li>多次提交压缩：<code>git rebase -i HEAD~n</code>  (n表示要合并的最近提交的次数)</li><li><strong>（一般在提交点push到公共分支之前操作）</strong></li></ol></li><li><p><code>git merge</code> 合并时建议使用 <code>--no--ff</code> 选项保留完整的提交历史（<strong>否则该命令默认策略：“优先–ff，若不能ff则–no-ff”</strong>）</p></li><li><p>比较各个区域的修改差异</p><ol><li>git diff – cached：比较缓存区与本地库最近一次commit内容</li></ol><ul><li>git diff：比较缓存区与工作区 </li><li>git diff HEAD | git diff commitId 比较工作区与本地最近一次commit内容 （工作区会包含已暂存和未暂存的文件内容）</li></ul></li><li><p>想要查看某次提交做了哪些改动</p><ol><li><code>git show commitId</code> (相较以下命令常用)</li><li><code>git show HEAD@&#123;5&#125;</code>  查看仓库中 HEAD 在五次前的所指向的提交</li></ol></li><li><p>版本迭代发布之际，需要合并其他分支的代码时，查看哪些分支已合并或未合并到当前分支</p><ol><li>查看哪些分支已经合并到当前分支：git branch –merged </li><li>查看哪些分支没有合并到当前分支 git branch –no-merged </li></ol></li><li><p>查看某分支还有哪些提交尚未合并到主分支？</p><ol><li><strong>双点</strong>：<ol><li>在 feature 分支中而不在 master 分支中的提交：<code>git log master..feature</code> </li><li>在你当前分支中而不在远程 <code>origin</code> 中的提交：<code>git log origin/master..HEAD</code></li></ol></li><li><strong>三点</strong>：<ol><li>想看 master 或者 feature 中包含的但不是两者共有的提交：<code>git log master...feature</code> </li><li>增加 –left-right 选项可以显示每个提交到底处于哪一侧的分支</li></ol></li><li><strong>多点</strong>：<ol><li>^ 字符或者 –not 来指明你不希望提交被包含其中的分支（以下命令等价）<ol><li>git log refA..refB</li><li>git log ^refA refB</li><li>git log refB –not refA</li></ol></li></ol></li></ol></li></ol><p><strong>概念</strong></p><ol><li>本地跟踪分支、远程跟踪分支、远程分支 （pull = fetch + merge）</li></ol><hr><h3 id="其他知识点补充"><a href="#其他知识点补充" class="headerlink" title="其他知识点补充"></a><strong>其他知识点补充</strong></h3><ol><li><p>变基 &amp; git merge 区别、commitId 的时间线是否有序</p><ol><li>变基：以另一个分支为基底分支，保留基底分支在共同祖先之后的提交，再将两个分支<strong>最近的</strong>一个<strong>共同祖先</strong>之后的属于”当前变基操作分支”的提交点，<strong>重做</strong>到基底分支上(<strong>commitId会发生变化</strong>)，均作为当前变基操作分支的内容。</li><li>变基后将内容merge 到另一个分支时会丢失该分支提交历史</li></ol></li><li><p>git rebase –onto master &lt;开始的commitId&gt; &lt;结束的commitId&gt; （游离指针 HEAD)</p><ol><li>git rebase master feature ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍 （省去切换分支到feature上的操作）</li><li>git rebase –onto master feature feature-child1 ：将feature分支以master作为基底分支，将feature分支上在共同祖先之后的提交点重做一遍，但暂时并不想合并 feature-child1 中的修改 （feature-child1一般是feature的子分支）</li></ol></li><li><p>Git 合并两个分支时，<strong>如果顺着一个分支走下去可以到达另一个分支的话</strong>，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）（<strong>如果不能到达另一个分支，则会执行 –no-ff</strong> ）</p><ol><li>非ff：Merge made by the ‘recursive’ strategy. （通过“递归”策略进行合并）</li><li>merge 时可以指定提交信息 -m</li></ol></li><li><p>git reset –hard commitId 用于将当前分支指向任意提交点，包括其他分支的提交点</p></li><li><p>git checkout 可以将 HEAD 引用 指向到任意提交点（游离状态-HEAD指针没有指向对象的分支）</p></li><li><p>Git push 时如何避免出现 “Merge branch ‘master’ of …”</p><ol><li>每次从远程分支 pull 新的变动，其实都会执行一次 git merge &lt;远程仓库&gt;/&lt;远程分支&gt;</li><li>git pull = git fetch + git merge ：若你本地的远程跟踪分支落后于远程分支，且在这段时间你还在本地分支进行开发并且做了提交，之后你使用git fetch 拉取远程最新的改动，这个时候你的远程跟踪分支与本地开发分支的提交历史就会产生分叉，执行 git pull 或 git merge origin/master的话就会产生合并记录（**–no-ff**）</li><li>可以使用 git pull –rebase （git fetch + git rebase） 变基方式去除自动生成的 log 信息<ol><li>从 remote 分支拉取更新到本地时，使用 rebase。</li><li>当完成 bug 修复或新功能时，使用 merge 将子分支合并到主分支。</li><li>没有人应该 rebase 一根共享的分支。</li></ol></li></ol></li><li><p>HEAD：</p><ol><li>HEAD就是当前活跃分支的游标。</li><li>HEAD并非只能指向分支的最顶端，实际上它可以指向任何一个提交节点，它就是 Git内部用来追踪当前位置的东东。</li></ol></li><li><p><code>git checkout -b mybranch origin/mybranch</code> (可以指定本地分支名)</p><p>= <code>git checkout --track origin/mybranch</code></p><p>= <code>git checkout origin/mybranch</code> </p></li><li><p>查看某次提交的改动</p><ol><li><code>git show commitId</code></li></ol></li><li><p>查看二进制对象文件：</p><ol><li>git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li></ol></li><li><p>通过具体指定一个提交来拉取该文件的对应版本：</p><ol><li><code>git reset eb43bf file.txt</code></li></ol></li><li><p>查看某个文件中内容的更改记录：</p><ol><li>git blame -L 69,82 Makefile （每一行分别来自哪个提交和提交者，-L可以指定行数）</li></ol></li><li><p>二分查找 git bisect</p></li><li><p> <code>--patch</code> 选项</p></li><li><p>打包本地仓库：git bundle create repo.bundle HEAD master</p></li><li><p>git 撤销commit中单个文件的修改：（未验证）</p><ul><li>git log <fileName>（首先查询这个文件的log）</li><li>git reset <commit-id> <fileName> （其次查找到这个文件的上次commit id xxx，并对其进行reset操作）</li><li> git checkout <fileName> 撤销对此文件的修改</li><li>git commit –amend + git push origin <remoteBranch> （最后amend一下，再push上去）</li></ul></li></ol><hr><h3 id="Git开发工作流"><a href="#Git开发工作流" class="headerlink" title="Git开发工作流"></a>Git开发工作流</h3><p><a href="https://juejin.im/post/6844903635533594632#heading-0">https://juejin.im/post/6844903635533594632#heading-0</a></p><ol><li>可以 <strong>在本地</strong> 随便重写历史记录（推送到远程公共分支之前）。 但是在对提交内容感到满意并准备与他人分享之前，应当避免推送你的工作。</li></ol><h3 id="GIt工具"><a href="#GIt工具" class="headerlink" title="GIt工具"></a>GIt工具</h3><ol><li><p>如何选择修订版本（即提交点）</p><ol><li><strong>简短的 SHA-1</strong>：可使用简短的 SHA-1来指定唯一的修订版本</li><li><strong>祖先引用</strong>：使用 ~ 或者 ^ 指定上一个父提交，~n 或者 ^ n指向前N个父提交，用法如下<ol><li>HEAD~3：当前HEAD指针指向的提交点的第三父提交</li><li>commitId~~：该提交点的第二父提交点</li></ol></li></ol></li><li><p>交互式暂存 <code>git add -i</code> 更友好的操作界面</p></li><li><p>贮藏与清理</p><ol><li>从贮藏创建一个分支：git stash branch testchanges</li><li>清理工作目录：<ol><li>git clean；默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 </li><li>git clean -i：交互式清理</li><li> git clean -f -d：移除工作目录中所有未追踪的文件以及空的子目录。</li><li>git clean -n（或者–dry-run）：“做一次演习然后告诉你 将要 移除什么”；要查看空目录需加上-d选项</li></ol></li></ol></li><li><p>重写历史：</p><ol><li>修改提交记录：git rebase -i （可以压缩提交或者拆分提交）<ol><li>squash 压缩提交到前一次提交</li><li>edit 进入对应提交点上，可以在做相应修改并提交到历史线上。</li></ol></li><li>修改大批量的提交：(<strong>未测试通过</strong>)<ol><li>删除某次提交中引入的某个文件（如密码文件），且在所有的提交点中都恢复不了该文件： <code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD</code></li></ol></li></ol></li><li><p>关于重置（ <code>reset</code> 和 <code>checkout</code>）</p><ol><li>首先要了解git中的三棵树：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">上一次提交的快照，下一次提交的父结点</span><br><span class="line">Index</span><br><span class="line">预期的下一次提交的快照</span><br><span class="line">Working Directory</span><br><span class="line">沙盒</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>HEAD</strong> 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。<ol><li>递归查看树结构：git ls-tree -r HEAD</li><li>查看二进制对象文件：git的底层命令：git cat-file -p HEAD (-p： pretty-print object’s content)</li></ol></li><li><strong>索引</strong>是你的 预期的下一次提交。 <ol><li>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。（<strong>git的每次提交都是全量文件的快照</strong>） 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。</li><li>git ls-files -s</li></ol></li><li>可以把<strong>工作目录</strong>当做 沙盒。<ol><li>HEAD、索引树 将工作区的文件的内容存储在 .git 文件夹中。而工作目录会将它们解包为实际的文件以便编辑。</li><li>在将修改提交到暂存区并记录到历史之前，可以随意更改工作目录的文件内容。</li></ol></li><li><strong>切换分支或克隆的过程：</strong>当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照， 然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</li><li>git reset 到底做了什么？<ol><li>先了解文件提交到版本库的链路：工作树 -&gt; 索引树 -&gt; 对象区(HEAD所指向)；回退的链路则反之</li><li>移动 HEAD的指向：与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支所指向的提交点。（<strong>可以理解为，HEAD是一个引用/指针，指针指向分支对象，相当于HEAD的实际对象是分支对象，reset 是修改这个HEAD对象的commitId属性（调用分支对象的setter方法）；而checkout相当于修改HEAD的引用，引用另一个对象</strong>）</li><li>git reset –soft：（移动 HEAD 分支的指向）撤销了上一次 git commit 命令，<strong>然后停止</strong>；HEAD树回退到上一次提交的版本，工作区、索引树不变。</li><li>git reset –mixed：（使索引看起来像 HEAD）撤销 commit、取消暂存 add ，<strong>然后停止</strong></li><li>git reset –hard：（使工作目录看起来像索引）撤销 commit、取消暂存 add ，还原工作区内容</li></ol></li><li>通过具体指定一个提交来拉取该文件的对应版本：<ol><li><code>git reset eb43bf file.txt</code> (更新索引)</li><li><code>git checkout eb43bf file.txt</code>  (更新索引树和工作空间)</li></ol></li></ol></li><li><p>git commit操作逻辑：</p><ol><li>取得索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象</li><li>最后更新 master 来指向本次提交 （HEAD会一直指向当前分支，而该分支会指向最后一次提交的快照（即对象区的内容））</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git常用场景使用技巧&quot;&gt;&lt;a href=&quot;#git常用场景使用技巧&quot; class=&quot;headerlink&quot; title=&quot;git常用场景使用技巧&quot;&gt;&lt;/a&gt;&lt;strong&gt;git常用场景使用技巧&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;功能开发到一半，</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="版本控制" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://huangyuye.github.io/2020/09/18/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20200918-Git/"/>
    <id>https://huangyuye.github.io/2020/09/18/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20200918-Git/</id>
    <published>2020-09-18T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>git merge  加不加 –no-ff：fast-forward<br><a href="https://juejin.im/post/6844904013326991368">https://juejin.im/post/6844904013326991368</a></p><p>git rebase 推不推荐使用<br><a href="https://zhuanlan.zhihu.com/p/29682134">https://zhuanlan.zhihu.com/p/29682134</a></p><p>git 中HEAD的概念, 经过merge, pull等操作后, HEAD会否改变<br><a href="https://juejin.im/entry/6844903493078089736">https://juejin.im/entry/6844903493078089736</a></p><h2 id="git-基础"><a href="#git-基础" class="headerlink" title="git 基础"></a>git 基础</h2><h3 id="git-是什么？"><a href="#git-是什么？" class="headerlink" title="git 是什么？"></a>git 是什么？</h3><p>分布式版本控制系统</p><h3 id="git-有什么用？"><a href="#git-有什么用？" class="headerlink" title="git 有什么用？"></a>git 有什么用？</h3><p>分布式：相比集中式，有去中心化的优势<br>安全性：每个人电脑里都有完整的版本库</p><p>强大的分支管理？往下看</p><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>自己从官网下载</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li><p><code>repository</code>: Git仓库，是commit的集合，仅此而已</p></li><li><p><code>working tree</code>: 当前文件系统的工作目录，不包括.git</p></li><li><p><code>index</code>: 暂存区，即将成为一个新的commit的临时节点</p></li><li><p><code>commit</code>: 可以理解为working tree在某个时间点的一个快照(snapshot)，当然只记录了增量的文件修改</p></li><li><p><code>branch</code>: Git分支，实质是指向某个commit的指针，有一个别名如<strong>dev</strong>，随着这个分支的提交，这个分支对应指针会指向新的HEAD</p></li><li><p><code>tag</code>: tag和branch都是指向某个commit的指针，也有一个别名，唯一区别是，tag指向一个commit，指针不会再移动。</p></li><li><p><code>master</code>: 提交主要分支，系统建立的第一个分支</p></li><li><p>```plaintext<br>HEAD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  重要概念：一个commit指针，用于记录工作区当前checkout的分支状态</span><br><span class="line"></span><br><span class="line">  - 若checkout的是一个branch，那么HEAD指针直接指向该branch</span><br><span class="line">  - 若checkout的是一个tag或是一个commit的hash id，那么HEAD处于detatch状态</span><br><span class="line"></span><br><span class="line">- &#96;tree&#96;: Git中的的树形结构，类似于目录，tree可以包含多个tree，也可以包含blob，blob是叶子节点，tree是非叶子节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三个空间</span><br><span class="line"></span><br><span class="line">工作目录、暂存区域以及 Git 仓库</span><br><span class="line"></span><br><span class="line">- 工作区是对项目的某个版本独立提取出来的内容。</span><br><span class="line">- 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</span><br><span class="line">- Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 开始用Git</span><br><span class="line"></span><br><span class="line">### 命令说明</span><br><span class="line"></span><br><span class="line">git help &lt;verb&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 基本配置</span><br><span class="line"></span><br><span class="line">#### git config </span><br><span class="line"></span><br><span class="line">查看或设置：git config &lt;--system&#x2F;--global&#x2F;--local&gt; &lt;var-name&gt; &lt;var-value&gt; </span><br><span class="line"></span><br><span class="line">系统变量 -- global ：&#x2F;etc&#x2F;gitconfig</span><br><span class="line"></span><br><span class="line">用户变量 -- system：~&#x2F;.gitconfig</span><br><span class="line"></span><br><span class="line">仓库变量 -- local：.git&#x2F;config </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 查看所有的配置以及它们所在的配置文件路径</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;console</span><br><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure></li></ul><h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><p>user.name</p><p>user.email</p><p>命令别名：alias.co checkout （设置checkout别名为co)</p><h4 id="配置忽略版本控制"><a href="#配置忽略版本控制" class="headerlink" title="配置忽略版本控制"></a>配置忽略版本控制</h4><p>.gitignore 列出要忽略的文件的模式</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li></ul><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>命令说明：将尚未进行版本控制的本地目录转换为 Git 仓库；</p><p>命令结果：创建一个名为 <code>.git</code> 的子目录，含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。</p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库</p><h3 id="GIt的三种状态"><a href="#GIt的三种状态" class="headerlink" title="GIt的三种状态"></a>GIt的三种状态</h3><p>（已跟踪 或 未跟踪）</p><p>（未修改）已修改（modified）  已暂存（staged）已提交（committed）</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p><h3 id="使用git管理文件"><a href="#使用git管理文件" class="headerlink" title="使用git管理文件"></a>使用git管理文件</h3><h4 id="查看仓库文件状态"><a href="#查看仓库文件状态" class="headerlink" title="查看仓库文件状态"></a>查看仓库文件状态</h4><p><code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出</p><h4 id="查看仓库文件详细修改"><a href="#查看仓库文件详细修改" class="headerlink" title="查看仓库文件详细修改"></a>查看仓库文件详细修改</h4><p>git diff：比较工作目录中当前文件和<strong>暂存区域快照</strong>之间的差异</p><p>git diff –staged：比对已暂存文件与最后一次提交的文件差异</p><h4 id="提交暂存区的变化"><a href="#提交暂存区的变化" class="headerlink" title="提交暂存区的变化"></a>提交暂存区的变化</h4><p>git commit：提交时记录的是放在<strong>暂存区域的快照</strong>。</p><p>跳过使用暂存区域：git commit -a （跳过git add）</p><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>git rm：从 Git 中移除某个文件，即从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 </p><p>git rm –cached：从 Git 仓库中删除（亦即从暂存区域移除），但仍然保留在当前工作目录中</p><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>git log：列出每个提交的 SHA-1 校验和、提交时间以及提交说明。</p><p>git log -patch：显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。</p><p>git log -stat：看到每次提交的简略统计信息</p><p>git log –pretty：使用不同于默认格式的方式展示提交历史（git log –pretty=oneline）</p><p>git log –graph：添加了一些 ASCII 字符串来形象地展示你的分支、合并历史（图形化）</p><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>git commit –amend：最新的提交将代替上一次提交的结果。（且将当前暂存区中的文件提交）</p><p>git restore <file> ：to discard changes in working directory</p><p>git restore –staged <file>…：to unstage</p><p>git reset –hard HEAD^ / <commitId>：撤销提交</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="查看远程服务器列表"><a href="#查看远程服务器列表" class="headerlink" title="查看远程服务器列表"></a>查看远程服务器列表</h4><p>git remote</p><p>git remote -v：详细信息</p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>git remote add <shortname> <url> （shortname是别名、简写）</p><p>命令行中使用<strong>简写</strong>来代替整个 URL</p><p>git remote rename <shortname> <new-shortname></p><p>git remote remove <shortname></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>先不学它</p><h3 id="git特性-分支特性"><a href="#git特性-分支特性" class="headerlink" title="git特性-分支特性"></a>git特性-分支特性</h3><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>快照</strong> 。</p><p>在进行提交操作时，Git 会保存一个<strong>提交对象</strong>（commit object）。提交对象会包含一个指向暂存内容快照的指针。提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的<strong>父对象的指针</strong>。</p><ul><li>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象 </li></ul><p><code>git add</code> ：暂存操作会为每一个文件计算校验和（ <strong>SHA-1 哈希算法，长度为 40 的 SHA-1 值字符串</strong>），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 <strong><em>blob</em> 对象</strong>来保存它们），最终将校验和加入到暂存区域等待提交。</p><p><code>git commit</code> :</p><ol><li>Git 会先计算每一个子目录的校验和， 然后在 Git 仓库中这些校验和保存为树对象。</li><li>随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</li></ol><p><strong>Git 仓库包含对象</strong>：blob 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>是一个指针，指向当前所在的本地分支</p><h4 id="检出操作"><a href="#检出操作" class="headerlink" title="检出操作"></a>检出操作</h4><ol><li>使 HEAD 指回 <code>master</code> 分支</li><li>将工作目录恢复成 <code>master</code> 分支所指向的快照内容</li></ol><p>git log –oneline –decorate –graph –all</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>git merge</p><h5 id="快速合并—快进（fast-forward）"><a href="#快速合并—快进（fast-forward）" class="headerlink" title="快速合并—快进（fast-forward）"></a>快速合并—快进（fast-forward）</h5><p>简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧</p><h5 id="三方合并"><a href="#三方合并" class="headerlink" title="三方合并"></a>三方合并</h5><p>若当前分支所在提交并不是待合并分支所在提交的直接祖先，git不会进行 <code>ff</code>， 而会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p><p>Git 将三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。（指向 父提交对象 + 新的暂存文件快照？ ）</p><h5 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h5><p><code>HEAD</code> 所指示的版本即当前分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支</p><p>图形化工具：git mergetool</p><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch -v：查看每一个分支的最后一次提交</p><p>–merged 与 –no-merged 可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</p><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p> <code>git ls-remote &lt;remote&gt;</code> ：显式地获得远程引用的完整列表</p><p> <code>git remote show &lt;remote&gt;</code> 获得远程分支的更多信息</p><h4 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h4><p>本地会有指向远程分支的不可以修改的<strong>指针</strong>-跟踪分支（使用git fetch来同步本地和远程指针）</p><p>可以运行 <code>git merge 远程仓库别名/x远程分支名</code> 将这些工作合并到当前所在的分支。（远程跟踪分支）</p><p>如果想要在远程分支上工作，可以将其建立在远程跟踪分支之上</p><p><code>git checkout -b 本地分支名 远程仓库别名/远程分支名</code></p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>远程跟踪分支 vs 跟踪分支</p><p><code>git checkout -b 本地分支名 远程仓库别名/远程分支名</code></p><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>git checkout -b <branch> <remote>/<branch> 的简化操作：</p><p>git checkout –track <remote>/<branch></p><p>git checkout <remote>/<branch></p><h5 id="设置上游分支"><a href="#设置上游分支" class="headerlink" title="设置上游分支"></a>设置上游分支</h5><p>git branch -u <remote>/<branch></p><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项</p><p>git fetch –all; git branch -vv</p><ol><li>每次 git add 操作，暂存区 .git/index 文件 都会修改</li><li>每次 git commit 操作<ol><li>.git\refs\heads${分支名} 记录的 commitId会修改</li><li>./git/COMMIT_EDITMSG 保存提交信息；logs 保存分支详细的提交信息</li><li>对象区 .git/objects  都会增加对应的 对象二进制文件 （名称等于当前commitId的二进制文件 + 其他文件对象的二进制文件）<ol><li>数量跟文件数量 + 1 不一致</li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-amp-A&quot; class=&quot;headerlink&quot; title=&quot;Q&amp;amp;A&quot;&gt;&lt;/a&gt;Q&amp;amp;A&lt;/h2&gt;&lt;p&gt;git merge  加不加 –no-ff：fast-forward&lt;br&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="版本控制" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Excel操作_TODO</title>
    <link href="https://huangyuye.github.io/2020/09/14/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20200914-Excel%E6%93%8D%E4%BD%9C_TODO/"/>
    <id>https://huangyuye.github.io/2020/09/14/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20200914-Excel%E6%93%8D%E4%BD%9C_TODO/</id>
    <published>2020-09-14T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>HSSF (Horrible SpreadSheet Format（电子表格格式）的缩写)<ol><li>对应.xls 文件，兼容 Office97-2003 版本 ）（一个sheet最大行数65536，最大列数256）</li></ol></li><li>XSSF<ol><li>容 Office2007及以后版本 （一个sheet最大行数1048576，最大列数16384）</li></ol></li><li><strong>SXSSF</strong> （低内存占用的操作方式）<ol><li>SXSSFWorkbook w3= new SXSSFWorkbook(100);//内存中保留100条数据，其余写入硬盘临时文件</li></ol></li></ol><h2 id="文档结构类"><a href="#文档结构类" class="headerlink" title="文档结构类"></a>文档结构类</h2><p>HSSFWorkbook excel文档对象<br>HSSFSheet excel的sheet<br>HSSFRow excel的行<br>HSSFCell excel的单元格<br>HSSFFont excel字体<br>HSSFName 名称<br>HSSFDataFormat 日期格式<br>HSSFHeader sheet头<br>HSSFFooter sheet尾<br>HSSFCellStyle cell样式<br>HSSFDateUtil 日期<br>HSSFPrintSetup 打印<br>HSSFErrorConstants 错误信息表</p><h3 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h3><h3 id="easyExcel"><a href="#easyExcel" class="headerlink" title="easyExcel"></a>easyExcel</h3><p><a href="https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java">https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/web/WebTest.java</a></p><h3 id="easyPoi"><a href="#easyPoi" class="headerlink" title="easyPoi"></a>easyPoi</h3><p><a href="https://gitee.com/lemur/easypoi">https://gitee.com/lemur/easypoi</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;HSSF (Horrible SpreadSheet Format（电子表格格式）的缩写)&lt;ol&gt;
&lt;li&gt;对应.xls 文件，</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="软件开发流程" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="https://huangyuye.github.io/2020/09/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangyuye.github.io/2020/09/09/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/20200909-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2020-09-09T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何进行单元测试"><a href="#如何进行单元测试" class="headerlink" title="如何进行单元测试"></a>如何进行单元测试</h2><p><strong>单元测试”称为“开发阶段的自动化测试“。</strong></p><ol><li> 由开发同学完成</li><li>测试是自动化的</li><li>不一定是只验证一个“单元”的正确性</li></ol><p><strong>单元测试在市面上的介绍存在的问题</strong></p><ol><li>仅集中在介绍某个工具或者框架怎么用（比如JUnit，mockito，jest等）</li><li>一些理论上的对这种测试好处的介绍，通篇是“应该做测试”，“这么做了就容易得到高内聚的代码“</li><li>只拿“纯函数”的测试举例子，几乎没有复杂的依赖（无法贴合实际项目：业务逻辑、数据分析的job代码）<ol><li>函数的输入就是其所有可见的上下文了。对于一个纯函数，开发者者很容易构造其<strong>上下文</strong>。</li></ol></li><li><strong>很少有关于真正为什么这个事情难以落地的讨论</strong></li></ol><p><strong>实践起来常见问题</strong></p><ol><li>没想明白要验证什么</li><li>对依赖的处理方式的拿捏是测试里最难的地方。（对不纯的依赖都要尽量mock）<ol><li>比如：验证一个下单打折的函数是否能计算出正确的折扣，往往先要从DB获取折扣数据(依赖)，才能做计算。</li><li>如果mock掉这个DB查询的依赖，那这个单元测试的假设是：<strong>“读取折扣的SQL本身是肯定没错的，因此不验证它，只验证读到折扣数据后，根据输入金额得到折扣金额的逻辑是正确的“</strong></li><li>如果不mock掉DB查询的依赖，即使用真的生产DB做验证，这里测试的目标就从“<strong>验证计算折扣的逻辑</strong>”变成“<strong>验证计算折扣这个功能是否正确</strong>“。<ol><li>這裏已经不是“单元”了，而是一个函数 + 一句SQL执行 + DB功能正确的（局部）“集成”测试，是几个组件一起测试才能实现这个验证。这样的测试代价是必须部署一个真的数据库，还要准备数据和<strong>后门</strong>。</li></ol></li></ol></li></ol><p><strong>到底要不要做”局部集成测试“而非实际的单元测试？</strong></p><ul><li>你的目标就是要测“一小段代码是不是正确”。你可以很有信心的保证其他依赖的正确性都能保证。那明显，这时就不用花精力做集成了。怎么简单怎么来。这样的测试甚至都不需要启动Spring这类框架，运行速度会很快。</li><li>你在开发一个小的lib。这个lib就很纯，没有任何复杂的依赖，那么单元测试就足够了。</li><li>如果团队已经安排了专人做这块的集成测试，开发人员就没必要做重复劳动了。如果这块测试的不好，应该优先去和那个测试同学沟通，看看怎么改善。沟通无效，在manager知情和同意下，再自己补。</li><li>如果开发自己做集成可以更容易构造全集成，而测试不太容易构造的例子，那么还是自己集成测试一下比较好。性价比高。</li><li>如果是要测试一个端到端的接口返回正确，那么唯一的办法就是集成测试——真的启动server，使用真的数据库、Redis、队列……，做端到端的测试。这时也许docker可以帮助你一键启动全套环境。</li><li>如果一个测试涉及到依赖的核心功能，也必须得做集成测试。比如要测试一个Exception是不是会让当前事务真的回滚，同时发生的其他事务因为隔离级别不会受到影响，那么你必须引入真的，和生产一模一样的支持事务的数据库才行。</li><li>如果是前端测试，基本上也必须得做集成测试。就算可以mock掉所有的后端接口，也得引入浏览器或者App框架才能测试。</li></ul><p><strong>单元测试目的</strong></p><p>验证“自己写的一小段代码是不是符合设计逻辑的“。</p><p><strong>单元测试的出发点</strong></p><p>开发人员为了保证代码质量应该怎样做</p><p><strong>单元测试怎么做？</strong></p><ul><li>确定测试的目标，到底想验证什么</li><li>基于这个目标，找到和维护需要的工具，比如Runner，Mock，覆盖率统计工具等，Embedded数据库等</li><li>留足给测试的时间，并通过code review的手段来保证写有效的测试</li><li>给一些典型的场景如何做测试写一写文档，积累经验（比如如何测试要模拟时间的案例？）</li><li>统计测试同学给开发同学报bug的数据，盯紧代码质量不高的同学，多做沟通</li><li>根据出现bug的数量和scope来推动部分关键代码的测试质量的改善</li><li>在能达成测试目标的前提下，看看能够整合一些工具，降低维护测试依赖的成本</li></ul><p><strong>单元测试的好处</strong></p><ol><li>让你写出更好的代码：只有高内聚、低耦合而且接口设计合理的代码才易于测试；</li><li>让你在修改代码时更有信心。</li></ol><h2 id="单元测试概念"><a href="#单元测试概念" class="headerlink" title="单元测试概念"></a>单元测试概念</h2><h3 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h3><h4 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h4><p>基本框架</p><h4 id="testNG"><a href="#testNG" class="headerlink" title="testNG"></a>testNG</h4><p>可以很容易地编写自定义测试。</p><p>如果您拥有执行测试所需的测试数据，TestNG可以轻松获取要编写单元测试的测试数据。</p><h3 id="模拟框架"><a href="#模拟框架" class="headerlink" title="模拟框架"></a>模拟框架</h3><h4 id="EasyMock"><a href="#EasyMock" class="headerlink" title="EasyMock"></a>EasyMock</h4><p>Mockito的替代品</p><ol><li>录制：EasyMock.expect(mock.someMethod())</li><li>执行：EasyMock.replay(mock)</li><li>验证期望：EasyMock.verify(mock)</li></ol><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h4 id="Mockito-amp-JMockit"><a href="#Mockito-amp-JMockit" class="headerlink" title="Mockito &amp; JMockit"></a>Mockito &amp; JMockit</h4><ol><li><h1 id="先进行Stub：when-mock-someMethod-then"><a href="#先进行Stub：when-mock-someMethod-then" class="headerlink" title="先进行Stub：when(mock.someMethod()).then()"></a>先进行Stub：when(mock.someMethod()).then()</h1><h4 id="Mockito-Vs-JMockit"><a href="#Mockito-Vs-JMockit" class="headerlink" title="Mockito Vs JMockit"></a>Mockito Vs JMockit</h4></li></ol><ol><li><p>Stub：when(mock.someMethod()).then()</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></li><li><p>验证行为：verify(mock).someMethod()</p></li></ol><h4 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h4><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>用于模拟复杂场景<br>=======<br>模拟复杂场景</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>想要模拟静态方法、构造函数和私有方法时，Powermock非常有用。</p><h3 id="结合项目框架使用的mock框架"><a href="#结合项目框架使用的mock框架" class="headerlink" title="结合项目框架使用的mock框架"></a>结合项目框架使用的mock框架</h3><p>Spring 有 Spring Test、Spring MVC Test</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h4 id="AssertJ-Hamcrest"><a href="#AssertJ-Hamcrest" class="headerlink" title="AssertJ / Hamcrest"></a>AssertJ / Hamcrest</h4><p>Hamcrest提供了AssertJ的替代方案来编写断言。</p><h3 id="Spring-Unit"><a href="#Spring-Unit" class="headerlink" title="Spring Unit"></a>Spring Unit</h3><p>Web层- Spring MockMVC</p><p>数据层- DataJpaTest</p><p>业务层-基于Mockito的测试，最好不要启动Spring Context</p><h3 id="断言JSON响应"><a href="#断言JSON响应" class="headerlink" title="断言JSON响应"></a>断言JSON响应</h3><h4 id="JSONAssert-JSONPath"><a href="#JSONAssert-JSONPath" class="headerlink" title="JSONAssert / JSONPath"></a>JSONAssert / JSONPath</h4><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>Cobertura</p><h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><p>利用 jenkins 等持续集成工具定时/有代码变更时运行单元测试，保证修改不会破坏已有的代码功能。</p><h3 id="Test-Doubles：Fakes、Mocks-以及-Stubs"><a href="#Test-Doubles：Fakes、Mocks-以及-Stubs" class="headerlink" title="Test Doubles：Fakes、Mocks 以及 Stubs"></a>Test Doubles：Fakes、Mocks 以及 Stubs</h3><p><strong>double：</strong>极相似的对应物</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>double存在的意义：用来对系统(或者将粒度放小为模块，单元)进行隔离<br>=======<br>用来对系统(或者将粒度放小为模块，单元)进行隔离</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p><strong>Dummy</strong></p><p>对象被四处传递，但是从不被真正使用。通常他们只是用来填充参数列表。</p><p><strong>Fake</strong><br>Fakes are objects that have working implementations, but not same as production one. Usually they take some shortcut and have simplified version of production code.Fake 是那些包含了生产环境下具体实现的简化版本的对象。（用于Test的测试实现类）</p><p><strong>Stub</strong></p><p>Stub is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don’t want to involve objects that would answer with real data or have undesirable side effects.Stub 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。（提供Query数据的对象）</p><p>stub是state-based，关注的是输入和输出。</p><p>stub意为踩熄</p><p><strong>Mock</strong></p><p>Mocks are objects that register calls they receive. In test assertion we can verify on Mocks that all expected actions were performed.Mocks 代指那些仅记录它们的调用信息的对象，在测试断言中我们需要验证 Mocks 被进行了符合期望的调用。(模拟行为的对象)</p><p>mock是interaction-based，关注的是交互过程。</p><p><a href="https://zhuanlan.zhihu.com/p/26942686">https://zhuanlan.zhihu.com/p/26942686</a></p><h3 id="Classical-和-Mockist-TDD-测试风格"><a href="#Classical-和-Mockist-TDD-测试风格" class="headerlink" title="Classical 和 Mockist  TDD 测试风格"></a>Classical 和 Mockist  TDD 测试风格</h3><p>验证状态 vs 验证行为</p><h3 id="SUT-amp-UUT-amp-AUT"><a href="#SUT-amp-UUT-amp-AUT" class="headerlink" title="SUT &amp; UUT &amp; AUT"></a>SUT &amp; UUT &amp; AUT</h3><p>SUT（system under test，被测试系统）</p><p>UUT（unit under test，被测试单元）</p><p>AUT（application under test，被测试应用软件）</p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ol><li><p>《单元测试之道》</p></li><li><p>《修改代码的艺术》</p></li><li><p>Mocks Aren’t Stubs</p></li></ol><h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/67801427">https://zhuanlan.zhihu.com/p/67801427</a></p><p><a href="http://tengj.top/2017/12/28/springboot12/">http://tengj.top/2017/12/28/springboot12/</a></p><h3 id="场景一、测试控制层"><a href="#场景一、测试控制层" class="headerlink" title="场景一、测试控制层"></a>场景一、测试控制层</h3><h5 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h5><ol><li>生成<code>TargetController</code>的单元测试类<code>TargetControllerTest</code>（一般包括整个controller的所有方法的testCase）</li></ol><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>2. 生成目标方法<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code><br>=======<br>2. 生成<code>targetMethod</code>的单元测试方法<code>testTargetMethod</code></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><ol start="3"><li><p>注解声明单元测试类</p><ol><li>方式一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明测试是在spring环境下运行的，这样就可以启用Spring的相关支持。</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 注解负责扫描配置来构建测试用的Spring上下文环境。它默认搜索@SpringBootConfiguration类，除非我们通过classes属性指定配置类，或者通过自定义内嵌的@Configuration类来指定配置。</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br></pre></td></tr></table></figure><ol><li><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 实例化一个MockMvc的bean + 可指定只实例化某一到多个Controller（但是同样也会遵从配置类的注解去做更多的工作）</span></span><br><span class="line"><span class="meta">@WebMvcTest(AppCustomerController.class)</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>准备MockMvc对象</p><ol><li><p>方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mvc = MockMvcBuilders.webAppContextSetup(wac).build(); <span class="comment">//初始化MockMvc对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><ol><li>可直接使用@WebMvcTest实例化的mockMvcBean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>只实例化目标类，避免其他无关类的实例化开销（自定义内嵌的@Configuration类来指定配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;xxx&quot;,</span></span><br><span class="line"><span class="meta">        useDefaultFilters = false,</span></span><br><span class="line"><span class="meta">        includeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.REGEX,</span></span><br><span class="line"><span class="meta">                pattern = &#123;&quot;xxx.TargetController&quot;&#125;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConfig</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>解决TargetController被测对象的其他依赖问题</p></li><li><p>将测试目标的所有依赖bean声明为<strong>模拟的bean</strong>，这些模拟的bean将<strong>被注入测试目标bean</strong>。</p></li><li><p>构建MockHttpSession，解决请求过程中的用户验证问题</p></li><li><p>绝大部分的方法受限于公司封装的底层框架，必须实例化对应的bean，且为带参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部嵌套javaConfig类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringContext <span class="title">springContext</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringContext(beanFactory); <span class="comment">// 由SqlContext实例化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">BaseService baseService;</span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line">CustomerSessionService customerSessionService;</span><br></pre></td></tr></table></figure></li><li><p>Mockito.spy()方法模拟出来的对象，调用该模拟对象的方法时，若该方法没有被”打桩“（预设），则会实际调用该方法真实逻辑。相比Mockito.mock()出来的模拟对象，若调用mock对象的方法没有被打桩，则返回默认值。</p></li><li><p>doReturn().when()与when().thenReturn()</p><ol><li>spy模拟对象<ol><li>when(…) thenReturn(…)会调用真实的方法</li><li> doReturn(…) when(…) 不会调用真实方法</li></ol></li></ol></li><li><p>2.1.0版本以前的<strong>Mockito</strong>是<strong>不能mock final类和final方法的</strong>，之后的也要通过配置一些相关文件才行(<a href="https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2#mock-the-unmockable-opt-in-mocking-of-final-classesmethods">Mock the unmockable: opt-in mocking of final classes/methods</a>)。因此，它的补充框架PowerMock也应运而生。</p><ol><li>创建配置文件 src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker</li><li>文件内容：mock-maker-inline</li></ol></li></ol><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>12. powerMock（未实践）<br>=======<br>12. powerMock</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span> <span class="comment">// 替代SpringRunner.class</span></span><br><span class="line"><span class="comment">// // powermock使用了自定义的PowerMockRunner，与spring集成时，可以代理至SpringJUnit4ClassRunner。</span></span><br><span class="line"><span class="meta">@PowerMockRunnerDelegate(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// @PowerMockRunnerDelegate(Parameterized.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;StaticService.class&#125;)</span> <span class="comment">// 包含静态类的方法</span></span><br></pre></td></tr></table></figure></code></pre><ol start="13"><li>powerMock + org.mockito.plugins.MockMaker 冲突问题<ol><li>org.mockito.internal.configuration.plugins.PluginLoader：java.lang.ClassNotFoundException: mock-maker-inline</li><li>删掉扩展文件后：java.lang.NoSuchMethodError: org.mockito.MockingDetails.getMockCreationSettings()</li></ol></li><li>@Mock 和 @InjectMocks 搭配使用（而非@MockBean）</li></ol><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>    1. 而 @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）<br>=======<br>    1. @MockBean是 springBootTest提供的注解，用于将响应的bean注册到spring容器（且可指定beanName）</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>1bd18958d9aa8a5bf6a3acce872ed9d752807f29</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MockBean(name = &quot;guide.SgGuide&quot;)</span></span><br><span class="line">SgGuide sgGuide;</span><br></pre></td></tr></table></figure></code></pre><ol start="16"><li><p>ArgumentMatchers.any() vs Mockito.any() 是同一个东西，<strong>Mockito 继承了 ArgumentMatchers</strong></p></li><li><p>doxxx().when() 不能用于 @MockBean 场景下??? （given().willReturn()）</p></li><li><p><strong>mockMvc添加过滤器</strong></p><ol><li>mMockMvc = MockMvcBuilders.webAppContextSetup(context).addFilter(new UserFilter()).build();</li></ol></li></ol><p><strong>参考链接：</strong></p><p><a href="https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn">https://www.zhihu.com/question/27313846/answer/853193909?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=983101242913976320&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何进行单元测试&quot;&gt;&lt;a href=&quot;#如何进行单元测试&quot; class=&quot;headerlink&quot; title=&quot;如何进行单元测试&quot;&gt;&lt;/a&gt;如何进行单元测试&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单元测试”称为“开发阶段的自动化测试“。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="软件开发流程" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程之CPU缓存</title>
    <link href="https://huangyuye.github.io/2020/09/06/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200906-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCPU%E7%BC%93%E5%AD%98/"/>
    <id>https://huangyuye.github.io/2020/09/06/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200906-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCPU%E7%BC%93%E5%AD%98/</id>
    <published>2020-09-06T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>多线程操作共享变量，变量值不一致。</p></li><li><p>使用volatile关键字修饰共享变量，保证共享变量在线程之间的可见性。</p><ul><li>synchronized 关键字也能保证共享变量在多个线程之间的可见性</li><li>CAS 机制也能保证共享变量在多个线程之间的可见性</li></ul></li><li><p>CPU读写模型是引发变量可见性的原因</p><ul><li> 主存RAM存取速度比 CPU操作慢得多，为避免CPU高速处理能力不能充分发挥作用，所以CPU处理器引入了高速缓冲存储器。（造价高，容量较主存小）</li><li>程序局部性原理（？？？）：CPU试图访问主存的某一单元时，会认为临近单元后续被利用的可能性很大，所以CPU在存取主存单元时，计算机硬件会自动把包括该单元在内的那一组单元调入高速缓存，之后CPU就可以直接对高速缓存数据进行存取。（一组单元称为内存块<code>block</code>，通常是连续的64个字节）</li></ul></li><li><p>CPU Cache相关术语</p><ul><li>Cache Line &amp; Slot &amp; Hot Data &amp; Cache Hit<ul><li>Cache Line = Slot </li><li>高速缓存会将其存储单元均分成若干等份，每一等份就是一个缓存行，如今主流CPU的缓存行一般都是64个字节</li><li>被缓存行缓存的数据称之为热点数据（hot data）</li></ul></li><li>Cache Hit &amp; Cache Miss &amp; Hit Latency<ul><li>Cache Hit：当CPU通过<code>寄存器</code>中存储的数据地址请求访问数据时（包括读操作和写操作），首先会在Cache中查找，如果找到了则直接返回Cache中存储的数据，这称为<strong>缓存命中</strong>（cache hit），根据操作类型又可分为读缓存命中和写缓存命中。</li><li>Hit Latency：命中延迟是指判断Cache中是否缓存了目标数据所花的时间。</li></ul></li><li>Cache分级：速度— L1 &gt; L2 &gt; L3（L3在CPU的多个核心之间共享）</li><li>Cache替换算法 &amp; Cache Line Conflict<ul><li>常用的算法：“最近最少使用算法”（LRU算法）least recently used；原理：为每行设置一个计数器，把名中行的计数器清零，其他各行计数器加1，当需要替换时淘汰行计数器计数值最大的数据行出局</li></ul></li><li>时钟周期：完成一次存取操作所需的时间—主频倒数（寄存器、高速缓存、主存都有主频）</li></ul></li><li><p>Cache结构设计和缓存关联性（<code>关联主内存</code>）</p><ul><li><strong>CPU高速缓存组成</strong>：整个Cache被分为S个组，每个组又有E行个最小的存储单元——Cache Line；而一个Cache Line中有B（B=64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据</li><li><strong>Cache Line组成</strong>：包含1个有效位（valid bit）、t个标记位（tag bit）、数据<ul><li>— valid bit用来表示该缓存行是否有效；tag bit用来协助寻址，唯一标识存储在Cache Line中的块；而Cache Line里的64个字节其实是对应内存地址中的数据拷贝。</li></ul></li><li>将高速缓存内的数据映射到主内存的数据（<strong>缓存关联性</strong>）<ul><li>完全关联(Fully associative cache) <ul><li>以32位操作系统（意味着到内存寻址时是通过32位地址）为例，，比如有一个0101…10 000000 - 0101…10 111111（为了节省版面省略了高26位中的部分bit位，这个区间代表高26位相同但低6位不同的64个地址，即64字节的内存块（主内存的存储单元：连续的64个字节））内存块需要缓存，那么它将会被随机存放到一个可用的Slot中，并将高26位作为该Slot的tag bit（前文说到每行除了存储内存块的64字节Cache Line，还额外有1个bit标识该行是否有效和t个bit作为该行的唯一ID，本例中t就是26）。这样当内存需要存取这个地址范围内的数据地址时，首先会去Cache中找是否缓存了高26位（tag bit）为0101…10的Slot，如果找到了再根据数据地址的低6位定位到Cache Line的某个存储单元上，这个低6位称为字节偏移（word offset）。<ul><li>6位字节偏移(2^6=64个字节)——<strong>主内存的存储单元block的大小固定位64个字节</strong></li><li>26位 tag bit 作为数据块唯一标识，用于寻址时轮询所有缓存行(slot)并匹配数据块</li></ul></li></ul></li><li>直接映射(Direct mapped cache) <ul><li>包含tag bit 位数据地址 + slot offset(定位slot) + word offset 字节偏移（缓存行）</li><li>对于给定的32位数据地址，首先不管低6位，取出中间的<code>slot offset</code>个bit位，定位出是哪一个Slot，然后比较该Slot的<code>tag bit</code>是否和数据地址的剩余高位匹配，如果匹配那么表示Cache Hit，最后在根据低6位从该Slot的Cache Line中找到具体的存储单元进行存取数据。</li><li>缺点：低位相同但高位不同的内存块会被映射到同一个Slot上（因为对SlotCount取模之后结果相同），如果碰巧CPU请求存取这些内存块，那么将只有一个内存块能够被缓存到Cache中对应的Slot上，也就是说容易发生Cache Line Conflict。</li></ul></li><li>N路组关联(N-way set associative cache) <ul><li>对Direct Mapped Cache和Full Associative Cache的一个结合，思路是不要对于给定的数据地址就定死了放在哪个Slot上。</li><li>先将Cache均分成S个组，每个组都有E个Slot。假设将我的L1 Cache 128KB按16个Slot划分为一个组，那么组数为：<code>128 * 1024 / 64</code>（Slot数）/ 16 = 128 个组（我们将每个组称为一个Set，表示一组Slot的集合）；与Direct Mapped Cache不同的地方就是将原本表示映射到哪个Slot的11个中间bit位改成了用7个bit位表示映射到哪个Set上，在确定Set之后，内存块将被放入该Set的哪个Slot是随机的（可能当时哪个可以用就放到哪个了），然后以剩余的高位19个bit位作为最终存放该内存块的<code>tag bit</code>。</li><li>对于一个给定的数据地址只会将其映射到特定的Set上，这样就大大减小了Cache Line Conflict的几率，并且CPU在查找Slot时只需在具体的某个Set中线性查找，而Set中的Slot个数较少（分组分得越多，每个组的Slot就越少），这样线性查找的时间复杂度也近似O(1)了。</li></ul></li></ul></li></ul></li><li><p>如何编写对Cache Hit友好的程序？为提高Cache命中率，要充分发挥局部性原理。</p><ul><li><p><strong>时间局部性</strong>：对于同一数据可能被多次使用，自第一次加载到Cache Line后，后面的访问就可以多次从Cache Line中命中，从而提高读取速度（而不是从下层缓存读取）。</p></li><li><p><strong>空间局部性</strong>：一个Cache Line有64字节块，我们可以充分利用一次加载64字节的空间，把程序后续会访问的数据，一次性全部加载进来，从而提高Cache Line命中率（而不是重新去寻址读取）。</p></li><li><p>实际操作：读取时尽量读取相邻的数据地址</p><ul><li><p>以上操作带来的负面影响：造成缓存一致性问题。</p></li><li><p>解决方案：（缓存一致性协议）</p><ul><li><pre><code>这是一个跟踪每个缓存行的状态的缓存子系统。该系统使用一个称为 “总线动态监视” 或者称为*“总线嗅探”* 的技术来监视在系统总线上发生的所有事务，以检测缓存中的某个地址上何时发生了读取或写入操作。当这个缓存子系统在系统总线上检测到对缓存中加载的内存区域进行的读取操作时，它会将该缓存行的状态更改为 “shared”。如果它检测到对该地址的写入操作时，会将缓存行的状态更改为 “invalid”。该缓存子系统想知道，当该系统在监视系统总线时，系统是否在其缓存中包含数据的惟一副本。如果数据由它自己的 CPU 进行了更新，那么这个缓存子系统会将缓存行的状态从 “exclusive” 更改为 “modified”。如果该缓存子系统检测到另一个处理器对该地址的读取，它会阻止访问，更新系统内存中的数据，然后允许该处理的访问继续进行。它还允许将该缓存行的状态标记为 shared。</code></pre></li><li><p>各CPU都会通过总线嗅探来监视其他CPU，一旦某个CPU对自己Cache中缓存的共享变量做了修改（能做修改的前提是共享变量所在的缓存行的状态不是无效的），那么就会导致其他缓存了该共享变量的CPU将该变量所在的Cache Line置为无效状态，在下次CPU访问无效状态的缓存行时会首先要求对共享变量做了修改的CPU将修改从Cache写回主存，然后自己再从主存中将最新的共享变量读到自己的缓存行中。（这里的CPU指的是CPU核心）</p></li><li><p>并且，缓存一致性协议通过缓存锁定来保证CPU修改缓存行中的共享变量并通知其他CPU将对应缓存行置为无效这一操作的原子性，即当某个CPU修改位于自己缓存中的共享变量时会禁止其他也缓存了该共享变量的CPU访问自己缓存中的对应缓存行，并在缓存锁定结束前通知这些CPU将对应缓存行置为无效状态。</p></li><li><p>在缓存锁定出现之前，是通过总线锁定来实现CPU之间的同步的，即CPU在回写主存时会锁定总线不让其他CPU访问主存，但是这种机制开销较大，一个CPU对共享变量的操作会导致其他CPU对其他共享变量的访问。(锁粒度由总线细化到CPU核心)</p></li></ul></li><li><p>缓存一致性协议带来的问题：<strong>伪共享</strong>——不同CPU核心对同一缓存行的不同字节数据的操作可能会导致缓存锁定（变成串行程序，降低了并发性（乒乓效应））</p></li><li><p>伪共享问题解决方案：</p><ul><li>缓存行填充（Cache Line Padding），通过增加两个变量的地址距离使之位于两个不同的缓存行上，如此对共享变量X和Y的操作不会相互影响。</li><li>线程不直接操作全局共享变量，而是将全局共享变量读取一份副本到自己的局部变量，局部变量在线程之间是不可见的因此随你线程怎么玩，最后线程再将玩出来的结果写回全局变量。（再进行锁定）</li></ul></li></ul></li></ul></li><li><p>并发编程的三要素是：原子性、可见性、有序性。</p></li><li><p><strong>锁释放有着volatile域写语义</strong>？？ &amp; 原子类CAS更新有着volatile域写语义</p></li><li><p>Unsafe类中的CAS自旋</p><ul><li>CAS操作在x86上是由cmpxchg（Compare Exchange）实现的（不同指令集有所不同）</li><li>JDK提供的AtomicXxx`系列原子操作类已能满足大多数需求</li><li><strong>原子类封装了一个volatile域</strong>：将改写立即刷新到主存；将改写立即刷新到主存</li></ul></li><li><p>volatile禁止重排序</p><ul><li>volatile产生的汇编指令lock具有个指令屏障使得该屏障之前的指令不能重排序到屏障之后。</li><li>volatile的作用案例：使用单例模式的并发优化案例<ul><li>懒加载模式<ul><li>利用类加载过程的初始化阶段会执行<strong>类构造器</strong><clinit>，按照显式声明为<strong>静态变量</strong>初始化的特点。</li><li><strong>当类被主动引用时应当立即对其初始化</strong>！！！</li><li>对类的主动引用：<ul><li>new、getStatic、putStatic、invokeStatic</li><li>通过java.lang.reflect包的方法对该类进行反射调用时</li><li>当初始化一个类时，如果他的父类没被初始化，那么先初始化其父类</li><li>当JVM启动时，首先会初始化main函数所在的类</li></ul></li><li>对类的被动引用：<ul><li>通过子类访问父类静态变量，子类不会被立即初始化</li><li>通过数组定义引用的类不会被立即初始化</li><li>访问某个类的常量，该类不会被立即初始化（因为经过编译阶段的常量传播优化，该常量已被复制一份到当前类的常量池中了）</li></ul></li></ul></li><li>饿汉模式1</li><li>饿汉模式2</li><li>DoubleCheckedLocking</li><li>DCL2</li><li>InstanceHolder</li><li>枚举实例的构造器只会被调用一次</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多线程操作共享变量，变量值不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用volatile关键字修饰共享变量，保证共享变量在线程之间的可见性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synchronized 关键字也能保证共享变量在多个线程之间的可见性&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程视频</title>
    <link href="https://huangyuye.github.io/2020/08/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200827-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91/"/>
    <id>https://huangyuye.github.io/2020/08/27/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200827-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%86%E9%A2%91/</id>
    <published>2020-08-27T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<ol><li>synchronized 默认是非公平锁，与线程申请锁顺序和等待锁时间无关</li><li>reentrantLock可实现公平锁，tryLock，lockInterruptablly</li><li>wait与notify结合与synchronized关键字使用建立同步模型<ol><li>避免在获得obj锁后才能够去调用obj的wait与notify/notifyAll三个方法，否则就会报错。（即synchronized代码块内）</li><li>在调用wait的时候，线程自动释放其占有的对象锁，同时不会去申请对象锁。当线程被唤醒的时候，它才再次获得了去获得对象锁的权利。（<strong>要等到获得锁后才真正可执行</strong>）</li><li>notify仅唤醒一个线程并允许它去获得锁（<strong>由JVM确定唤醒哪个线程</strong>），notifyAll是唤醒所有等待这个对象的线程并允许它们去获得对象锁。（<strong>要等到获得锁后才真正可执行</strong>）</li><li>notifyAll，虽然是对每个wait的对象都调用一次notify，但是这个还是<strong>有顺序的</strong>，每个对象都保存这一个等待对象链，调用的顺序就是这个链的顺序。</li><li>当线程B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1,A2,A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2,A3中的一个才有机会获得锁继续执行。（<strong>由JVM确定哪个线程获得锁-非公平</strong>）</li><li>永远选择使用notifyAll而非notify，notify容易造成死锁，所有线程都在wait</li></ol></li><li>生产者消费者问题：<ol><li>synchronized 同步生产方法，生产者线程获得锁进入代码块后，若容器容量达到上限，则调用对象.wait()方法释放锁，其他生产者线程可以获得对象锁并进入同步生成方法，再次判断容器元素数量，达到上限则同样调用wait()方法并释放锁。此时多个生产者线程均在wait()，等待被唤醒。</li><li>基于条件1情况下，此时消费者线程进入消费方法，消费了容器元素，并调用notifyAll()方法唤醒所有等待线程，此时等待中的所有生产者线程被唤醒，但是都在等待获得对象锁才能继续往前执行，得到对象锁的生产者线程需要再次判断元素数量，避免导致超出容器容量。</li></ol></li><li>使用 lock 和 condition 代替 synchronized + wait/notify<ol><li>lock.lock()，condition.await()，condition.signalAll() 一起使用</li><li>lock可以精确指定唤醒的线程</li></ol></li><li>ThreadLocal 线程局部变量<ol><li>内存泄漏：<a href="https://juejin.im/post/6844903683751149582">https://juejin.im/post/6844903683751149582</a></li><li>空间换时间</li></ol></li><li>socket长连接（TCP&amp;UDP）</li><li>Java的线程池是基于并发容器实现的</li><li>线程安全的单例模式—以下方式既不用加锁，也能实现懒加载<ol><li>使用静态内部类：访问静态内部类的时候才会加载静态内部类</li></ol></li><li>并发容器<ol><li>ConcurrentHashMap（分段同步锁，默认16段，细化锁的粒度；1.8后node cas替代了section分段锁）— HashTable 锁住整个容器对象</li><li>高并发且有排序需求，使用ConcurrentSkipMap替代TreeMap(SortedMap)<ol><li>排序map：插入慢</li></ol></li><li>CopyOnWriteList 对比 ArrayList和Vector<ol><li>适合写少读多的场景（如监听器队列）</li><li>写时复制列表：<ol><li>读的效率高，写效率低</li><li>写的时候，复制一份新的数据，不影响其他线程读数据旧的数据，写完后，将旧对象的引用指向新数据对象。</li><li><a href="http://ifeve.com/java-copy-on-write/">http://ifeve.com/java-copy-on-write/</a></li></ol></li></ol></li><li>queue 英 [kjuː] 并发场景使用的队列分为以下两种<ol><li>ConcurrentLinkedQueue  （并发<strong>加锁</strong>且<strong>无界</strong>单向队列-单向链表）<ol><li>offer() // 同 add 方法</li><li>poll()   //  获取第一个元素，且删除</li><li>peek() //  获取第一个元素，但不删除</li></ol></li><li>BlockingQueue 阻塞队列<ol><li>队列实现<ol><li>LinkedBlockingQueue (-)</li><li>ArrayBlockingQueue (有界)</li></ol></li><li>方法<ol><li>put()：如果满了，线程会等待</li><li>take()：如果空了，线程会等待</li><li>add()：如果满了，线程会抛异常</li><li>offer() // 同 add 方法，不会抛异常，而是返回添加结果boolean</li></ol></li></ol></li><li>DelayQueue 延迟队列，元素根据可消费时间排序<ol><li>元素要实现Delayed接口（Delayed接口实现了Comparable接口）</li><li>适用场景：执行定时任务</li></ol></li><li>TransferQueue：（效率较高）<ol><li>transfer() 场景：实时消息处理，生产者生产数据直接传送给消费者，若没有消费者或消费者来不及处理时，则生产者阻塞（如游戏服务器上接收消息传达给客户端）</li><li>put()：不会阻塞，直接放入队列</li><li>take()：消费</li></ol></li><li>SynchronousQueue：（特殊的TransferQueue，容量为0，生产者生产数据时必须要有消费者消费）<ol><li>put()：若没有消费者则阻塞</li><li>add()：若没有消费者会抛异常</li></ol></li></ol></li><li>deque 英 [dek] 双端队列 </li></ol></li><li>线程池<ol><li>需从Executor顶层接口说起，定义标准接口execute(Runnable r)</li><li>ExecutorService（interface 服务，执行任务）<ol><li>submit(Runnable r)</li><li>submit(Callable c)</li></ol></li><li>Runnable &amp; Callable<ol><li>Callable：有返回值，且可以捕获checked异常</li></ol></li><li>Executors：工具类（工厂方法&amp;工具方法）</li><li>ThreadPool 线程池<ol><li>ExecutorService executorService = Executors.newFixedThreadPool(size); // 固定线程数量线程池</li><li>Executors.newCachedThreadPool(); // 弹性数量的线程池，新增任务，若池子里没有空闲的线程，则新增线程执行任务，线程的空闲时间超过N秒后自动销毁，N秒可在创建线程池时可指定。</li><li>Executors.newScheduledThreadPool(); // 英 [ˈʃedjuːl] 美 [ˈskedʒuːl] 定时执行任务，参考DelayQueue，替代Timer（Scheduled复用线程，Timer每次都新起线程），定时模式如下：<ol><li>固定频率执行</li></ol></li><li>Executors.newSingleThreadPool();  // 任务需顺序执行的场景</li><li>Executors.newWorkStealingPool();  // daemon守护线程线程池（精灵线程、后台线程） （若没有非守护线程工作，则销毁？）// 0、1、2、3 四个线程<ol><li>内部机制：ForkJoinPool</li></ol></li><li>ForkJoinPool（精灵线程）</li></ol></li><li>Future &amp; FutureTask<ol><li>FutureTask 是 <strong>Future</strong> 和 <strong>Runnable 的实现类</strong>；FutureTask的重写的run方法中执行了Callable.call()方法</li><li>FutureTask <strong>包含Callable引用</strong>，包含Callable形参的构造器；</li><li>FutureTask.get()阻塞获取返回值的原理：(Future阻塞拿到返回值的原理)<ol><li>循环等待Task任务的结果(用outcome表示执行结果，state变量表示任务运行状态)</li></ol></li><li></li></ol></li></ol></li><li>synchronized是悲观锁，juc包中的原子类使用的是乐观锁测试，使用cas算法，由硬件直接支持原子性。<ol><li>存在ABA问题：A-&gt;B  的过程中已被其他线程执行了 A-&gt;B-&gt;A 操作</li><li>ABA漏洞可以采用 java 原子引用类解决？？</li></ol></li><li>越大的素数，需要计算的时间越长：</li></ol><p><code>for(int i=2;i&lt;num/2;i++)&#123;if(num%i==0) return false&#125;</code></p><ol start="14"><li>创建线程、销毁线程都要操作系统的用户态-&gt;内核态（消耗系统资源）</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>Java多线程之wait(),notify(),notifyAll()：</p><p><a href="https://blog.csdn.net/alex197963/article/details/6863662">https://blog.csdn.net/alex197963/article/details/6863662</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;synchronized 默认是非公平锁，与线程申请锁顺序和等待锁时间无关&lt;/li&gt;
&lt;li&gt;reentrantLock可实现公平锁，tryLock，lockInterruptablly&lt;/li&gt;
&lt;li&gt;wait与notify结合与synchronized关键</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程(二)</title>
    <link href="https://huangyuye.github.io/2020/08/26/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200826-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)/"/>
    <id>https://huangyuye.github.io/2020/08/26/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200826-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%BA%8C)/</id>
    <published>2020-08-26T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发历史"><a href="#并发历史" class="headerlink" title="并发历史"></a>并发历史</h2><ol><li>早期计算机执行程序时，只会顺序执行，且顺序使用计算机资源，其他空闲资源没有被充分利用。(其他程序不会得到执行)</li><li>操作系统的出现为程序带来了 并发性，使得计算机能同时运行多个程序，同时使用计算机资源。</li></ol><p>操作系统实现多个程序同时运行解决了单个程序无法做到的问题：</p><ol><li>资源利用率：单个进程存在资源浪费的情况，其他进程会等待正在执行的进程完成任务</li><li>公平性？操作系统会为不同的程序划分时间片来使用资源，每个进程都有能够公平享有资源的权利，且操作系统可以决定不同进程的优先级（低优先级进程会出现进程饥饿问题）</li><li>进程间信息交换</li></ol><p>单进程顺序编程-串行编程的好处：直观性、简单性。</p><p>多进程出现的同时，促使着线程的出现：</p><p><strong>进程是一个应用程序，而线程是应用程序中的一条顺序流</strong>。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一种<code>轻量级</code>的进程，轻量级体现在线程的创建和销毁要比进程的开销小很多。</p><p>线程私有：程序计数器、寄存器、堆栈、局部变量</p><p>线程会共享进程范围内的资源：xxx 不了解</p><p>单个CPU情况下，应用程序想要并发执行多个任务的话，会经历多次状态暂存任务切换，CPU在多个任务之间进行切换。</p><p>Java 很好的在<strong>用户空间</strong>实现了开发工具包，并在<strong>内核空间</strong>提供系统调用来支持多线程编程。Java 支持了丰富的类库 <code>java.util.concurrent</code> 和跨平台的<code>内存模型</code></p><p><strong>问题：</strong></p><p><strong>理解进程、线程、CPU、核心、寄存器、指令的关系：</strong> ？</p><p>指令是在 CPU 中执行的，单个 CPU 将在多个线程之间共享 CPU 的时间片，在给定的时间片内执行每个线程之间的切换，每个线程也可以由不同的 CPU 执行；</p><p>CPU 内部是寄存器的构造；</p><h2 id="并发为什么会出现"><a href="#并发为什么会出现" class="headerlink" title="并发为什么会出现"></a>并发为什么会出现</h2><p>CPU、内存和 I/O 设备一直存在速度差异性问题。</p><p>CPU 内部是寄存器的构造，寄存器的访问速度要高于CPU<code>高速缓存</code>，高速缓存的访问速度要高于内存（主存RAM），最慢的是磁盘访问。</p><p>因为 CPU 速度太快了，所以为了发挥 CPU 的速度优势，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li><strong>CPU</strong> 使用<strong>缓存</strong>来中和和内存的访问速度差异（CPU缓存）</li><li>操作系统提供<strong>进程和线程调度</strong>，让 CPU 在执行指令的同时分时复用线程，让内存和磁盘不断交互，不同的 <code>CPU 时间片</code> 能够执行不同的任务，从而均衡这三者的差异</li><li>编译程序提供优化指令的执行顺序，让缓存能够合理的使用？</li></ul><h2 id="线程带来的安全性问题"><a href="#线程带来的安全性问题" class="headerlink" title="线程带来的安全性问题"></a>线程带来的安全性问题</h2><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>单核时代，单核CPU调度多个线程执行任务，CPU缓存和主内存是一一对应关系，CPU缓存数据跟主内存数据版本一致。线程写操作会将数据同时写到CPU缓存和主内存，<strong>且多个线程共享同一个CPU下的缓存？？</strong></p><p>多核时代，每个CPU核心都有自己的缓存，当每个CPU分配时间片给线程执行时，每个线程都是直接读取CPU缓存，这时CPU缓存和内存的<strong>线程共享数据</strong>存在不一致问题。</p><p><code>synchronized</code>的<strong>锁释放-获取</strong>和<strong>CAS修改-读取</strong>都有着和<code>volatile</code>域的<strong>写-读</strong>有相同的语义。</p><h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>典型的 i++操作：（<strong>复合类操作</strong>）</p><ol><li>先读取到i值 （存储到CPU<strong>寄存器</strong>）</li><li>再进行 i+1操作 （此时可能发生线程切换）</li><li>将i+1赋值给i （将结果写入内存）</li></ol><p>线程的切换是产生线程安全性的必要条件。</p><p>线程切换是导致竞态条件出现的诱导因素。（<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong> ）</p><h3 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h3><p><strong>如果一组线程中的每个线程都在等待一个事件的发生，而这个事件只能由该组中正在等待的线程触发，这种情况会导致死锁</strong>。</p><h3 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h3><p>线程间的等待，以及无限等待造成死锁</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>与活跃性问题密切相关的是 <code>性能</code> 问题，如果说活跃性问题关注的是最终的结果，那么性能问题关注的就是造成结果的过程，性能问题有很多方面：比如<strong>服务时间过长，吞吐率过低，资源消耗过高</strong>，在多线程中这样的问题同样存在。</p><p><strong>最大的影响性能的因素：线程切换/上下文切换</strong></p><ol><li><p>挂起当前线程</p></li><li><p>保存和恢复上下文：</p><ol><li>保存线程、寄存器、程序计数器等状态</li><li>线程调度器：选择一个合适的线程</li><li>线程：加载程序计数器</li></ol></li></ol><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>多个线程可以同时安全调用的代码称为线程安全的，如果一段代码是安全的，那么这段代码就不存在 <code>竞态条件</code>。仅仅当多个线程共享资源时，才会出现竞态条件。</p><p><strong>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的</strong>。</p><h2 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h2><p>每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为 <code>内置锁(Instrinsic Lock)</code>或者 <code>监视器锁(Monitor Lock)</code>。</p><p>synchronized 是同步锁即互斥锁或独占锁，也是可重入锁，也是非公平锁。</p><p>锁重入支持子类和父类之间的重入；</p><p>volatile 是一种轻量级的 synchronized；volatile 的执行成本要比 <code>synchronized</code> 低很多，因为 volatile 不会引起线程的上下文切换。volatile 通过保证共享变量的可见性对对象进行加锁。（线程通信，保证可见性）；</p><p>还可以使用<code>原子类</code> 来保证线程安全；还可以使用 <code>java.util.concurrent</code> 工具包下的线程安全的集合类（并发容器）来确保线程安全。</p><h2 id="竞态条件和关键区域"><a href="#竞态条件和关键区域" class="headerlink" title="竞态条件和关键区域"></a>竞态条件和关键区域</h2><p>竞态条件是在关键代码区域发生的一种特殊条件。</p><p>关键区域是由多个线程同时执行的代码部分；</p><p>如果多个线程执行一段关键代码，而这段关键代码会因为执行线程的顺序不同而造成不同的结果时，那么这段代码就会包含竞争条件。</p><p>竞态条件：<strong>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong></p><h2 id="并发模型和分布式系统很相似"><a href="#并发模型和分布式系统很相似" class="headerlink" title="并发模型和分布式系统很相似"></a>并发模型和分布式系统很相似</h2><p>并发模型中是<code>线程</code>彼此进行通信；</p><p>在分布式系统模型中是 <code>进程</code> 彼此进行通信；</p><h2 id="共享状态-amp-独立状态"><a href="#共享状态-amp-独立状态" class="headerlink" title="共享状态&amp;独立状态"></a>共享状态&amp;独立状态</h2><p>并发模型的一个重要的方面是，线程是否应该<code>共享状态</code>，是具有<code>共享状态</code>还是<code>独立状态</code>。共享状态也就意味着在不同线程之间共享某些状态。</p><p>状态其实就是<code>数据</code>，比如一个或者多个对象。当线程要共享数据时，就会造成 <code>竞态条件</code> 或者 <code>死锁</code> 等问题。</p><h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><h3 id="并行-Worker"><a href="#并行-Worker" class="headerlink" title="并行 Worker"></a>并行 Worker</h3><p>客户端会把任务交给 <code>代理人(Delegator)</code>，然后由代理人把工作分配给不同的 <code>工人(worker)</code>。</p><p>Delegator 负责接收来自客户端的任务并把任务下发，交给具体的 Worker 进行处理，Worker 处理完成后把结果返回给 Delegator，在 Delegator 接收到 Worker 处理的结果后对其进行汇总，然后交给客户端。</p><p><strong>优点</strong>：</p><p>将一个任务拆分成多个小任务，并发执行，Delegator 在接受到 Worker 的处理结果后就会返回给 Client，整个 Worker -&gt; Delegator -&gt; Client 的过程是<code>异步</code>的。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>共享状态会变得很复杂</li><li>无状态的 worker（worker 必须在每次操作共享状态时重新读取）</li><li>作业顺序是不确定的</li></ol><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p><strong>流水线并发模型：</strong>像是工厂中装配线中的 worker，每个 worker 只完成全部工作的一部分，完成一部分后，worker 会将工作转发给下一个 worker。</p><p>每道程序都在自己的线程中运行，彼此之间不会共享状态，这种模型也被称为无共享并发模型。</p><p>使用流水线并发模型通常被设计为<code>非阻塞I/O</code>，也就是说，当没有给 worker 分配任务时，worker 会做其他工作。非阻塞I/O 意味着当 worker 开始 I/O 操作，例如从网络中读取文件，worker 不会等待 I/O 调用完成。因为 I/O 操作很慢，所以等待 I/O 非常耗费时间。在等待 I/O 的同时，CPU 可以做其他事情，I/O 操作完成后的结果将传递给下一个 worker。</p><p>使用流水线模型的系统有时也被称为 <code>响应式</code> 或者 <code>事件驱动系统</code>，这种模型会根据外部的事件作出响应，事件可能是某个 HTTP 请求或者某个文件完成加载到内存中。</p><h4 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h4><p>一个参与者<code>Actor</code>对接收到的消息做出响应，然后可以创建出更多的 Actor 或发送更多的消息，同时准备接收下一条消息。</p><h4 id="Channels-模型"><a href="#Channels-模型" class="headerlink" title="Channels 模型"></a>Channels 模型</h4><p>在 Channel 模型中，worker 通常不会直接通信，与此相对的，他们通常将事件发送到不同的 <code>通道(Channel)</code>上，然后其他 worker 可以在这些通道上获取消息；</p><p>有的时候 worker 不需要明确知道接下来的 worker 是谁，他们只需要将数据写入通道中，监听 Channel 的 worker 可以订阅或者取消订阅，这种方式<strong>降低</strong>了 worker 和 worker 之间的<strong>耦合性</strong>。（worker完成任务后回调channels（<strong>阿里云发送日志接口采用回调方式</strong>））</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>worker间不存在共享状态</li><li>单个worker有状态（无需再获取数据，执行更快）</li><li>更好的硬件整合：有状态的 worker 通常在 CPU 中缓存数据，这样可以更快地访问缓存的数据。</li></ol><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>worker分散</li><li>编写困难：设计嵌套回调</li></ol><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>可以对流水线并发模型中的任务进行排序，一般用来日志的写入和恢复。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ol><li>有状态：单个个体有状态</li><li>共享状态：多个个体共享数据</li></ol><h2 id="函数性并行"><a href="#函数性并行" class="headerlink" title="函数性并行"></a>函数性并行</h2><p>使用函数调用来实现</p><p>消息的传递就相当于是函数的调用。传递给函数的参数都会被拷贝，因此在函数之外的任何实体都无法操纵函数内的数据。这使得函数执行类似于<code>原子</code>操作。每个函数调用都可以独立于任何其他函数调用执行。</p><p>当每个函数调用独立执行时，每个函数都可以在单独的 CPU 上执行。这也就是说，函数式并行并行相当于是各个 CPU 单独执行各自的任务。</p><p>stream </p><h2 id="创建并启动线程"><a href="#创建并启动线程" class="headerlink" title="创建并启动线程"></a>创建并启动线程</h2><ol><li><strong>thread.join()<strong>：等待线程</strong>thread</strong>执行完毕<ol><li>导致当前运行的线程停止执行，直到它加入的线程<strong>thread</strong>完成其任务。</li></ol></li><li>继承Thread &amp; 实现 Runnable<ol><li>使用继承方式创建线程的优势：编写比较简单；可以使用 <code>this</code> 关键字直接指向当前线程，而无需使用 <code>Thread.currentThread()</code> 来获取当前线程。</li></ol></li><li>Callable 有返回值的线程 &amp; Runnable<ol><li>Callable（重写）的方法是 call 方法，而 Runnable（重写）的方法是 run 方法。</li><li>call 方法可以抛出异常，而 Runnable 方法不能抛出异常</li></ol></li><li><code>顶级接口 </code>Executor<ol><li> Executor 在客户端和任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor 允许你管理<code>异步</code>任务的执行，而无须显示地管理线程的生命周期。</li><li>线程池好处：<ol><li>复用线程、控制最大并发数</li><li>实现任务线程队列缓存策略和拒绝机制？ （CachedThreadPool）</li><li>实现某些与时间相关的功能，如定时执行、周期执行等。</li><li>隔离线程环境。（开启不同的线程池）</li></ol></li><li><code>ExecutorService</code> 是 Executor 的默认实现，也是 Executor 的扩展接口，ThreadPoolExecutor 类提供了线程池的扩展实现<ol><li><code>CachedThreadPool</code> 会为每个任务都创建一个线程</li><li>FixedThreadPool 使你可以使用有限的线程集来启动多线程 （固定线程数量）</li><li>SingleThreadExecutor 就是线程数量为 1 的 FixedThreadPool<ol><li>SingleThreadPool 会序列化所有提交给他的任务，并会维护它自己(隐藏)的悬挂队列。</li></ol></li></ol></li></ol></li><li><strong>后台/守护线程</strong>（daemon 英 [ˈdiːmən）：若无非守护线程执行，所有守护线程将终止执行</li><li>线程异常捕获：<ol><li>Thread.UncaughtExceptionHandler，允许你在每个 Thread 上都附着一个异常处理器。</li><li>Thread.UncaughtExceptionHandler.uncaughtException() 会在线程因未捕获临近死亡时被调用。</li></ol></li></ol><h3 id="线程执行控制"><a href="#线程执行控制" class="headerlink" title="线程执行控制"></a>线程执行控制</h3><ol><li>sleep 线程休眠 TimeUnit.sleep()</li><li>线程优先级：可以通过设置线程的优先级状态，告诉线程调度器哪个线程的执行优先级比较高（Thread.MAX_PRIORITY）</li><li>作出让步-Thread.yield()：建议执行切换CPU，而不是强制执行CPU切换。</li><li>后台线程：<code>后台(daemon) </code>线程，是指运行时在后台提供的一种服务线程，这种线程不是属于必须的。当所有非后台线程结束时，程序也就停止了，<strong>同时会终止所有的后台线程。</strong></li><li>加入一个线程：一个线程可以在其他线程上调用 <code>join()</code> 方法，其效果是等待一段时间直到第二个线程结束才正常执行。如果某个线程在另一个线程 t 上调用 t.join() 方法，此线程将被挂起，直到目标线程 t 结束才回复(可以用 t.isAlive() 返回为真假判断)。<ol><li>对 join 的调用也可以被中断，做法是在线程上调用 <code>interrupted</code> 方法，这时需要用到 try…catch 子句</li></ol></li><li>线程异常捕获： Thread.UncaughtExceptionHandler</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>Wait、Sleep和Yield方法的区别：（<a href="https://www.jianshu.com/p/25e959037eed%EF%BC%89">https://www.jianshu.com/p/25e959037eed）</a><ol><li>wait()和sleep()<ol><li>wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。</li><li>当一个线程调用wait()方法的时候，会释放它锁持有的对象的<strong>管程</strong>和锁，但是调用sleep()方法的时候，不会释放他所持有的**管程(Monitor)**。</li><li>wait方法应在同步代码块中调用，但是sleep方法不需要。</li><li>使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首<strong>先获得锁（译者注：阻塞态），然后再进入就绪态</strong>。</li><li>wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程。</li></ol></li><li>sleep()和yield()：<ol><li>yield() 仅释放线程所占有的CPU资源，从而让其他线程有机会运行</li><li>sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的</li><li>如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。</li><li>执行了yield方法的线程什么时候会继续运行由线程调度器来决定</li></ol></li></ol></li><li>有一个易错的地方，当调用t.sleep()的时候，会暂停线程t。这是不对的，因为Thread.sleep是一个静态方法，它会<strong>使当前线程而不是线程t</strong>进入休眠状态。</li><li>休眠的线程在唤醒之后不保证能获取到CPU，它会先进入就绪态，与其他线程竞争CPU。</li><li>sleep()放弃CPU执行权，休眠结束后进入就绪状态，等待再次获得CPU执行权；而wait()方法释放对象锁，要先获得锁，才能进入就绪态等待获得CPU执行权</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发历史&quot;&gt;&lt;a href=&quot;#并发历史&quot; class=&quot;headerlink&quot; title=&quot;并发历史&quot;&gt;&lt;/a&gt;并发历史&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;早期计算机执行程序时，只会顺序执行，且顺序使用计算机资源，其他空闲资源没有被充分利用。(其他程序不会得到执行)&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA容器</title>
    <link href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-JAVA%E5%AE%B9%E5%99%A8/"/>
    <id>https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-JAVA%E5%AE%B9%E5%99%A8/</id>
    <published>2020-08-25T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>组成结构：数组和链表</p><p>存储算法：根据key值的hashcode经过取余算法定位其所在数组的位置，再根据key的equals方法匹配相同key值获取对应相应的对象。</p><p>案例：</p><p><strong>（1）hashmap存储</strong></p><p>存值规则：把Key的hashCode 与HashMap的容量 取余得出该Key存储在数组所在位置的下标<strong>（源码定位Key存储在数组的哪个位置是以hashCode &amp; (HashMap容量-1)算法得出）</strong>这里为方便理解使用此方式；</p><p>//为了演示方便定义一个容量大小为3的hashMap（其默认为16）</p><p>HashMap map=newHashMap(3);</p><p>map.put(“a”,1); 得到key 为“a” 的hashcode 值为97然后根据 该值和hashMap 容量取余97%3得到存储位到数组下标为1;</p><p>map.put(“b”,2); 得到key 为“b” 的hashcode 值为98,98%3到存储位到数组下标为2;</p><p>map.put(“c”,3); 得到key 为“c” 的hashcode 值为99，99%3到存储位到数组下标为0;</p><p>map.put(“d”,4); 得到key 为“d” 的hashcode 值为100，100%3到存储位到数组下标为1;</p><p>map.put(“e”,5); 得到key 为“e” 的hashcode 值为101，101%3到存储位到数组下标为2;</p><p>map.put(“f”,6); 得到key 为“f” 的hashcode 值为102，102%3到存储位到数组下标为0;</p><p><img src="https://pic4.zhimg.com/80/v2-fceb57a8de2759203613d5bd343dc37d_1440w.jpg" alt="img"></p><p><strong>（2）hashmap的查找key</strong></p><p>得到key在数组中的位置：根据上图，当我们获取key 为“a”的对象时，那么我们首先获得 key的hashcode97%3得到存储位到数组下标为1;</p><p>匹配得到对应key值对象：得到数组下表为1的数据“a”和“c”对象， 然后再根据 key.equals()来匹配获取对应key的数据对象；</p><p>hashcode 对于HashMapde:如果没有hashcode 就意味着HashMap存储的时候是没有规律可寻的，那么每当我们map.get()方法的时候，就要把map里面的对象一一拿出来进行equals匹配，这样效率是不是会超级慢；</p><h2 id="5、hashcode方法文档说明"><a href="#5、hashcode方法文档说明" class="headerlink" title="5、hashcode方法文档说明"></a><strong>5、hashcode方法文档说明</strong></h2><p>在equals方法没被修改的前提下，多次调用同一对象的hashcode方法返回的值必须是相同的整数；</p><p>如果两个对象互相equals，那么这两个对象的hashcode值必须相等；</p><p>为不同对象生成不同的hashcode可以提升哈希表的性能；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h3&gt;&lt;p&gt;组成结构：数组和链表&lt;/p&gt;
&lt;p&gt;存储算法：根据key值的hashcode经过取余算法定位其所在数</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>equals&amp;hashcode</title>
    <link href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-equals&amp;hashcode/"/>
    <id>https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-equals&amp;hashcode/</id>
    <published>2020-08-25T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="默认的equals与hashcode"><a href="#默认的equals与hashcode" class="headerlink" title="默认的equals与hashcode"></a>默认的equals与hashcode</h1><ol><li>equals：判断两个对象的引用指向的是不是同一个对象</li><li>hashcode：根据对象地址生成一个整数数值；</li></ol><h2 id="重写场景"><a href="#重写场景" class="headerlink" title="重写场景"></a>重写场景</h2><p>需求：若对象间特定的几个属性值相等，则判定对象相等</p><p>问题：默认的equals和hashcode判定的是对象的引用，两个new出来的对象引用一定不同</p><p>解决方案：重写equals方法和hashcode方法</p><p>只重写equals方法的话会出现对象equals相等但是hashcode不等的情况（hashcode默认判断引用地址），放到hashSet中也有存在两个对象。</p><p>HashMap 则是先根据Key值的hashcode分配和获取对象保存数组下标的，然后再根据equals区分唯一值。也存在一样的问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为什么重写equals时必须重写hashCode方法？</p><p>前提：</p><p><strong>如果两个对象相等，则hashcode一定也是相同的；</strong><br><strong>两个对象相等,对两个对象分别调用equals方法都返回true；</strong></p><p>两个对象有相同的hashcode值，它们也不一定是相等的；（如HashMap）</p><p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖；<br>hashCode() 的<strong>默认行为是对堆上的对象产生独特值</strong>。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）；</p><p><a href="https://juejin.im/post/6844903854639693837#heading-3">https://juejin.im/post/6844903854639693837#heading-3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;默认的equals与hashcode&quot;&gt;&lt;a href=&quot;#默认的equals与hashcode&quot; class=&quot;headerlink&quot; title=&quot;默认的equals与hashcode&quot;&gt;&lt;/a&gt;默认的equals与hashcode&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-%E5%8F%8D%E5%B0%84/"/>
    <id>https://huangyuye.github.io/2020/08/25/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200825-%E5%8F%8D%E5%B0%84/</id>
    <published>2020-08-25T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>在不使用反射时，构造对象使用 new 方式实现，这种方式在<strong>编译期</strong>就可以把对象的类型确定下来。</p><p>使用反射后，在程序<strong>运行过程</strong>中<strong>动态</strong>获取类信息和调用类方法。</p><p>反射的<strong>思想</strong>：<strong>在程序运行过程中确定和解析数据类的类型。</strong></p><p>反射的<strong>作用</strong>：对于在<code>编译期</code>无法确定使用哪个数据类的场景，通过<code>反射</code>可以在程序运行时<strong>构造出不同的数据类实例</strong>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.im/post/6864324335654404104">https://juejin.im/post/6864324335654404104</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;p&gt;在不使用反射时，构造对象使用 new 方式实现，这种方式在&lt;strong&gt;编译期&lt;/strong&gt;就可以把对象的类型确定下来。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程(一)</title>
    <link href="https://huangyuye.github.io/2020/08/22/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200822-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)/"/>
    <id>https://huangyuye.github.io/2020/08/22/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200822-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%80)/</id>
    <published>2020-08-22T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程-amp-进程"><a href="#线程-amp-进程" class="headerlink" title="线程&amp;进程"></a>线程&amp;进程</h3><p><strong>进程：</strong>是程序的一次执行过程，是系统运行程序的基本单位</p><p><strong>线程：</strong>比进程更小的执行单位，一个进程的执行过程中会产生多个线程。</p><p><strong>不同点：</strong></p><ol><li>进程之间是完全独立的；多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源(线程间可能会相互影响)，但是每个线程有独立的程序计数器、虚拟机栈、本地方法栈。</li><li>线程间切换工作上下文时资源消耗比进程小（被称为轻量级线程）<ol><li>线程执行开销小，但不利于资源的管理和保护</li></ol></li></ol><p><strong>问题</strong>：</p><p>程序计数器、虚拟机栈、本地方法栈为什么是私有的？</p><p>首先先来了解<strong>程序计数器</strong>的作用—记住程序线程的运行位置：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环</li><li>多线程情况下，程序计数器用于记录当前线程执行位置，从而使得当线程被切换回来时能够知道该线程上次运行到哪里了。</li></ol><p>总结：所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><p><strong>虚拟机栈(Java方法)：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p><strong>堆</strong>和<strong>方法区</strong>是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><ol><li>线程间的切换和调度的成本远小于进程</li><li>充分利用多核CPU同时运行多个线程，提高系统并发能力和性能</li></ol><p>单核CPU时代：提高CPU和IO设备的综合利用率</p><p>多核CPU时代：提高CPU利用率</p><h4 id="多线程可能带来的问题"><a href="#多线程可能带来的问题" class="headerlink" title="多线程可能带来的问题"></a>多线程可能带来的问题</h4><ol><li>内存泄漏</li><li>死锁</li><li>线程不安全等</li></ol><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><ol><li>NEW</li><li>RUNNABLE</li><li>BLOCKED</li><li>WAITING、TIME_WATING</li><li>TERMINATED</li></ol><h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，</p><p>调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。</p><p>可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p><code>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态。所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</code></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，</p><p>而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。</p><p>当超时时间到达后 Java 线程将会返回到 <strong>RUNNABLE</strong> 状态。</p><p>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="关于线程上下文切换"><a href="#关于线程上下文切换" class="headerlink" title="关于线程上下文切换"></a>关于线程上下文切换</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而<strong>一个 CPU 核心在任意时刻只能被一个线程使用</strong>，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><h3 id="关于start-和run"><a href="#关于start-和run" class="headerlink" title="关于start()和run()"></a>关于start()和run()</h3><p><strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h3 id="sleep-方法和-wait-方法"><a href="#sleep-方法和-wait-方法" class="headerlink" title="sleep() 方法和 wait() 方法"></a>sleep() 方法和 wait() 方法</h3><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>死锁产生的四个必要条件：</p><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>循环等待条件</li></ol><p>通俗来讲，多个线程都在争夺相同的N个资源（<strong>均只有一份，互斥</strong>），等待缺少的资源时不丢掉本身已获取到的资源(<strong>请求与保持</strong>)，且不能抢夺别的线程占用的资源(<strong>不剥夺</strong>)，但是问题是想要正常运行，这些线程都需要别的线程已获取到的资源（<strong>循环等待</strong>）。</p><p>如每个线程都在同时执行“拼凑拼图”的任务，但拼图却只有一份(<strong>互斥</strong>)。或者说多个分别捡到不同星数的龙珠的人都想要召唤神龙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;线程-amp-进程&quot;&gt;&lt;a href=&quot;#线程-amp-进程&quot; class=&quot;headerlink&quot; title=&quot;线程&amp;amp;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>对象序列化</title>
    <link href="https://huangyuye.github.io/2020/08/19/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200819-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://huangyuye.github.io/2020/08/19/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200819-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-08-19T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象序列化概念"><a href="#对象序列化概念" class="headerlink" title="对象序列化概念"></a>对象序列化概念</h2><p><strong>把变量对象从内存中变成可存储或传输的过程称之为序列化。(字节序列)</strong></p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>对象的“序列化”并没有保存对象所有的内容，而仅仅保留了对象的属性，没有保留对象的方法。</p><ul><li>使用    ObjectOutputStream流 写一个被实例化的对象</li></ul><p><strong>把变量内容从序列化的对象重新读到内存里称之为反序列化。</strong></p><ul><li>使用 ObjectInputStream流 可以直接把被序列化的对象给反序列化出来。</li><li>当一个对象被反序列化时，这个对象的构造函数将不会在被调用的。</li></ul><h2 id="Serializable接口-amp-serialVersionUID"><a href="#Serializable接口-amp-serialVersionUID" class="headerlink" title="Serializable接口 &amp; serialVersionUID"></a><strong>Serializable接口 &amp; serialVersionUID</strong></h2><ul><li><p>serialVersionUID 用于解决对象序列化和反序列化的版本兼容问题.</p><ol><li><strong>类的serialVersionUID的默认值</strong>完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</li><li><strong>显式地定义serialVersionUID有两种用途：</strong><ol><li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li><li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li></ol></li></ol></li></ul><ul><li><p>Serializable是<a href="https://link.zhihu.com/?target=http://java.io">http://java.io</a>包中定义的、用于实现Java类的序列化操作而提供的一个<strong>语义级别</strong>的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。</p></li><li><ol><li>序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</li><li>如果父类已经实现了Serializable序列化接口的话，其子类就不用再实现这个接口了，但是反过来就不成立了。</li></ol></li></ul><h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>实现<strong>Externalizable</strong>接口</p><p>相对于Serializable接口的区别：实现该接口会调用无参构造方法</p><p>使用场景：对某些敏感数据进行加密操作后再序列化；反序列化对加密数据进行解密操作。</p><h2 id="阻止序列化"><a href="#阻止序列化" class="headerlink" title="阻止序列化"></a>阻止序列化</h2><p>阻止<strong>非静态属性</strong>的序列化，用transient关键词修饰</p><h2 id="可序列化的场景-amp-条件"><a href="#可序列化的场景-amp-条件" class="headerlink" title="可序列化的场景&amp;条件"></a>可序列化的场景&amp;条件</h2><ol><li>父类已经实现了Serializable序列化接口（递归）</li><li>非静态的数据成员才会通过序列化操作被序列化</li><li>未被<strong>transient</strong>标记的数据成员</li><li>子类是可序列化的，其父类不是可序列化的，但是其父类有无参的构造函数，可支持序列化，但子类继承自父类中的成员不会序列化输出到文件/网络。</li></ol><h3 id="关于无参构造函数"><a href="#关于无参构造函数" class="headerlink" title="关于无参构造函数"></a>关于无参构造函数</h3><ol><li><p>单一对象,无继承关系:若想实现序列化与反序列化,则必须实现序列化接口,否则报异常:NotSerializableException</p></li><li><p>对象间有继承关系,但无引用关系,若想实现序列化与反序列化,则父类必须实现序列化接口或提供无参构造函数,否则报invalidClassException</p></li><li><p>对象间有继承关系,并且有引用关系,若想实现序列化与反序列化,则父类必须实现序列化接口</p></li></ol><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="idea-生成serialVersionUID"><a href="#idea-生成serialVersionUID" class="headerlink" title="idea 生成serialVersionUID"></a>idea 生成serialVersionUID</h3><ul><li>Settings &gt; Editor &gt; Inspections &gt; 勾选 Serializable class without ‘serialVersionUID’</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/yaomingyang/article/details/79321939">https://blog.csdn.net/yaomingyang/article/details/79321939</a></p><p><a href="https://blog.csdn.net/qq_19782019/article/details/80422143">https://blog.csdn.net/qq_19782019/article/details/80422143</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-5things1/">https://www.ibm.com/developerworks/cn/java/j-5things1/</a></p><p><a href="https://www.cnblogs.com/huangdabing/p/9231948.html">https://www.cnblogs.com/huangdabing/p/9231948.html</a></p><p><a href="https://blog.csdn.net/m0_38001814/article/details/86584446">https://blog.csdn.net/m0_38001814/article/details/86584446</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象序列化概念&quot;&gt;&lt;a href=&quot;#对象序列化概念&quot; class=&quot;headerlink&quot; title=&quot;对象序列化概念&quot;&gt;&lt;/a&gt;对象序列化概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;把变量对象从内存中变成可存储或传输的过程称之为序列化。(字节序列)&lt;/strong&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://huangyuye.github.io/categories/Java/"/>
    
    <category term="知识库" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://huangyuye.github.io/categories/Java/%E7%9F%A5%E8%AF%86%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>日记</title>
    <link href="https://huangyuye.github.io/2020/06/20/%E6%97%A5%E8%AE%B0/20200620-%E6%97%A5%E8%AE%B0/"/>
    <id>https://huangyuye.github.io/2020/06/20/%E6%97%A5%E8%AE%B0/20200620-%E6%97%A5%E8%AE%B0/</id>
    <published>2020-06-20T00:00:00.000Z</published>
    <updated>2021-05-24T12:55:11.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="混过去的三年程序员生涯，你还要继续吗？"><a href="#混过去的三年程序员生涯，你还要继续吗？" class="headerlink" title="混过去的三年程序员生涯，你还要继续吗？"></a>混过去的三年程序员生涯，你还要继续吗？</h1><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>笔者是一名已经有三年开发经验的Java开发工程师，过去三年一直在同一家公司搬砖，也就是当下仍就职的公司。<br>我司是一家致力于为零售行业提供数字化、智能化客户资源管理云服务解决方案的企业，从我大四实习起就一直在这家公司工作。<br>作为非计算机科班出生的大四学生，本就输在了起跑线上，大四那年还放弃与同班同学为伍踏入培训机构的学习道路，<br>一股脑的把自己锁在出租屋里，跟着马士兵的视频捯饬了几个月。期间还有跑到过一家创业公司去，想着当个无薪劳动力，<br>也算是能积累点实习经验。奈何笔者本人是一名学渣，且前三年偷懒欠下不少帐，大四还是得花时间来还的，没错，多次“矿工”后这家创业公司还是跟我说了声再见。<br>不过后来想想也不是什么坏事，毕竟这家公司让我做的更多是前端的东西，也不符合我的java后端开发的职业规划。再后来呢到了大四秋招，<br>除了自己本校校招，笔者还经常跑到其他院校的宣讲会蹭下机会，但都因没有项目经验、非计算机科班生、没有参加正规计算机培训等原因屡屡碰壁，<br>不过归根结底还是只能怪自己没有学习扎实吧。虽然屡遭打击，但是我仍不放弃继续参加校招、宣讲、社招，这样反反复复坚持了2个月后，<br>终于被我现在这家公司收下啦，一直做到现在，说实话也是有点感激公司当时给我的这个机会，也是碰巧当年公司刚好开始在杭州筹备研发团队。</p><p>这三年呢，最开始是在项目研发团队工作，一开始什么都不太熟悉，没用过框架，没完整的做过项目，所以会遇到很多坎。也是好在当时有前辈带着做了个项目，<br>做的事情也是根据现成的系统做二开，所以项目进度不算急。笔者当时负责的是定时任务-客户模块，主要做外部接口数据定时获取与解析入库，对于当时的我来说，不管是业务还是技术对我来说<br>都是新的知识点，求知欲望强烈，常常是加班到凌晨，也少不了半夜call前辈咨询问题。文章开头也提到了，我司是客户资源管理系统，客户模块是最核心且很复杂的模块，<br>当时的主管让我去熟悉和梳理整个项目的数据库表，并输出客户合并的方案。没有错，是整个项目的数据表，涉及客户的表就有几十张。作为刚踏入职场的小白来说，我完全懵掉了，<br>但是又自认为不该逃避，最终花了整整一个多月的时间，反复梳理、讨论、确认，最终把客户合并的功能给做出来了，也是我踏入职场后第一个做出来的功能。<br>说实话，我现在还认为这个功能可能会存在风险或问题，但是那一个多月的经验让我印象深刻，所有问题都是能解决的，不放弃就有希望。也很幸运，在那之后没多久举办的年会上我荣获进步奖，<br>对我那段时间的努力表示了认可。</p><p>再后来呢，在公司一直兢兢业业，认真做好负责的工作内容，也一直对自己的编码规范有较高要求，至今我都认为，代码写的丑，架构再好也白搭。</p><p>后来就成为了略有经验的java工程师，做什么项目都有了底气。但也遇到过很坑的事故，比如说项目安全事件，数据库备份版本回退事件，<br>经历了一个研发独自驻点解决前人留下的烂摊子，三天就睡了几个小时处理，想想就脊椎骨疼，不过幸好咬咬牙都扛过去了，<br>对笔者来说也是作为程序员来说难忘的经历吧，毕竟不常见哈哈。</p><p>去年一年，笔者经历了两次部门调动，从储值产品研发，被调动到项目中心研发，再到导购产品研发，也就是我现在所在的团队部门。<br>虽说调整了两次部门，但是在相应的岗位下，笔者都尽力把认为最合适的方案引入到项目开发中。<br>比如说做储值产品时，为解决储值交易并发问题，引入了redis分布式锁 保证同一时刻同一储值客户不会发生重复交易问题；<br>为避免交易过程多系统交互时网络丢包或服务器宕机升级导致的分布式事务异常，数据不一致问题，笔者搭建了异步回调系统，<br>以及引入消息回查方式保证双系统间的数据一致。<br>在项目中心时，笔者考虑到所有项目实施时用到的基础功能或工具类都要反复开发，所以专门把基础模块抽取复用，<br>独立成基础依赖包，作为项目实施的脚手架。到导购产品项目时，导购项目分为两个服务端工程，一个是小程序，一个是管理后台，<br>两个工程使用到的model和service层都各自维护，没办法做到复用。笔者接到这个项目时，首先将两个项目整合到一起，<br>并且把基础的模块抽取复用 让导购系统更容易维护和拓展。</p><p>说了这么多，有没有觉得笔者的三年经历简简单单用几段话就说完了，确实是这样，<br>没有给自己布置任何的课余作业 没有去开源社区逛街的日常，也没有记录自己的程序员日记。<br>只能说，笔者只是规规矩矩的搬了三年的砖。肯定有很多同样三年的小伙伴此时已经有了属于自己的丰富的博客，<br>有自己完善的工具集合和代码段；当然也有跟笔者一样的小伙伴，总希望来点什么不一样的改变，但是总找不到方向，<br>找不到坚持，或许也在默默地等待同样的下一个三年了。难道，你还想这样继续吗？笔者不想，所以也就写下了这篇文章，<br>从这篇文章开始，去做下不一样的程序员。</p><p>那么 ，笔者接下来会做哪些调整呢，感兴趣的小伙伴，请继续跟着我往下看。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><h3 id="保持热情"><a href="#保持热情" class="headerlink" title="保持热情"></a>保持热情</h3><ol><li>做题</li></ol><p>每天都要保持好学的状态，作为一名程序员，笔者认为必须让你的脑细胞每天都在保持思考，每天不断思考加学习会让你对新事物更感兴趣。</p><ol start="2"><li>热点博文</li></ol><p>关注热点技术，与前沿技术不脱节，可以的话建议尝试动手。</p><ol start="3"><li>总结<br>坚持每日的小整理，每周的大总结，有可能的话可以输出博文，能够自己讲出所以然来的东西才真正属于你的。</li></ol><h3 id="课外功课"><a href="#课外功课" class="headerlink" title="课外功课"></a>课外功课</h3><ol><li>考虑做一个属于自己的项目，最好是能在日常使用的产品</li></ol><h3 id="把自己当新人"><a href="#把自己当新人" class="headerlink" title="把自己当新人"></a>把自己当新人</h3><ol><li>经常向自己提问，自己擅长什么技能？优势是什么？能做什么？公司为什么需要你？想象自己如果重新面试新公司，你能拿出什么来？</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="做题记录"><a href="#做题记录" class="headerlink" title="做题记录"></a>做题记录</h3><p>参考链接：<a href="https://baijiahao.baidu.com/s?id=1669904169998381448&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1669904169998381448&amp;wfr=spider&amp;for=pc</a></p><h4 id="数据结构篇"><a href="#数据结构篇" class="headerlink" title="数据结构篇"></a>数据结构篇</h4><ol><li>二叉树</li><li>链表</li><li>栈和队列</li><li>二进制</li></ol><h4 id="基础算法篇"><a href="#基础算法篇" class="headerlink" title="基础算法篇"></a>基础算法篇</h4><ol><li>二分搜索</li><li>排序算法</li><li>动态规划</li></ol><h4 id="算法思维"><a href="#算法思维" class="headerlink" title="算法思维"></a>算法思维</h4><ol><li>递归思维</li><li>滑动窗口思想</li><li>二叉搜索树</li><li>回溯法</li></ol><h4 id="基础算法篇-1"><a href="#基础算法篇-1" class="headerlink" title="基础算法篇"></a>基础算法篇</h4><h4 id="算法思维-1"><a href="#算法思维-1" class="headerlink" title="算法思维"></a>算法思维</h4><h3 id="课外功课-1"><a href="#课外功课-1" class="headerlink" title="课外功课"></a>课外功课</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;混过去的三年程序员生涯，你还要继续吗？&quot;&gt;&lt;a href=&quot;#混过去的三年程序员生涯，你还要继续吗？&quot; class=&quot;headerlink&quot; title=&quot;混过去的三年程序员生涯，你还要继续吗？&quot;&gt;&lt;/a&gt;混过去的三年程序员生涯，你还要继续吗？&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="日记" scheme="https://huangyuye.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
